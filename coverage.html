
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>docs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">rhapp/docs/docs.go (0.0%)</option>
				
				<option value="file1">rhapp/internal/domain/agregados/document_aggregate.go (0.0%)</option>
				
				<option value="file2">rhapp/internal/domain/agregados/employee_aggregate.go (0.0%)</option>
				
				<option value="file3">rhapp/internal/domain/agregados/location_aggregate.go (0.0%)</option>
				
				<option value="file4">rhapp/internal/domain/agregados/org_structure_aggregate.go (0.0%)</option>
				
				<option value="file5">rhapp/internal/domain/dtos/area_estudo.go (0.0%)</option>
				
				<option value="file6">rhapp/internal/domain/dtos/department.go (0.0%)</option>
				
				<option value="file7">rhapp/internal/domain/dtos/dependent.go (0.0%)</option>
				
				<option value="file8">rhapp/internal/domain/dtos/distrito.go (0.0%)</option>
				
				<option value="file9">rhapp/internal/domain/dtos/document.go (0.0%)</option>
				
				<option value="file10">rhapp/internal/domain/dtos/education.go (0.0%)</option>
				
				<option value="file11">rhapp/internal/domain/dtos/emp_status.go (0.0%)</option>
				
				<option value="file12">rhapp/internal/domain/dtos/employee.go (0.0%)</option>
				
				<option value="file13">rhapp/internal/domain/dtos/municipio.go (0.0%)</option>
				
				<option value="file14">rhapp/internal/domain/dtos/position.go (0.0%)</option>
				
				<option value="file15">rhapp/internal/domain/dtos/province.go (100.0%)</option>
				
				<option value="file16">rhapp/internal/domain/dtos/supervisor.go (0.0%)</option>
				
				<option value="file17">rhapp/internal/domain/dtos/work.go (0.0%)</option>
				
				<option value="file18">rhapp/internal/domain/entities/education.go (0.0%)</option>
				
				<option value="file19">rhapp/internal/domain/entities/employee.go (0.0%)</option>
				
				<option value="file20">rhapp/internal/domain/entities/supervisor.go (0.0%)</option>
				
				<option value="file21">rhapp/internal/domain/entities/work.go (0.0%)</option>
				
				<option value="file22">rhapp/internal/domain/vos/address.go (0.0%)</option>
				
				<option value="file23">rhapp/internal/domain/vos/bi.go (0.0%)</option>
				
				<option value="file24">rhapp/internal/domain/vos/birthdate.go (0.0%)</option>
				
				<option value="file25">rhapp/internal/domain/vos/contract_type.go (0.0%)</option>
				
				<option value="file26">rhapp/internal/domain/vos/district.go (0.0%)</option>
				
				<option value="file27">rhapp/internal/domain/vos/document_owner_type.go (0.0%)</option>
				
				<option value="file28">rhapp/internal/domain/vos/document_type.go (0.0%)</option>
				
				<option value="file29">rhapp/internal/domain/vos/document_url.go (0.0%)</option>
				
				<option value="file30">rhapp/internal/domain/vos/email.go (0.0%)</option>
				
				<option value="file31">rhapp/internal/domain/vos/emp_status.go (0.0%)</option>
				
				<option value="file32">rhapp/internal/domain/vos/emp_status_reason.go (0.0%)</option>
				
				<option value="file33">rhapp/internal/domain/vos/file_extension.go (0.0%)</option>
				
				<option value="file34">rhapp/internal/domain/vos/filename.go (0.0%)</option>
				
				<option value="file35">rhapp/internal/domain/vos/gender.go (0.0%)</option>
				
				<option value="file36">rhapp/internal/domain/vos/iban.go (0.0%)</option>
				
				<option value="file37">rhapp/internal/domain/vos/marital_status.go (0.0%)</option>
				
				<option value="file38">rhapp/internal/domain/vos/municipality.go (0.0%)</option>
				
				<option value="file39">rhapp/internal/domain/vos/nationality.go (0.0%)</option>
				
				<option value="file40">rhapp/internal/domain/vos/personal_name.go (0.0%)</option>
				
				<option value="file41">rhapp/internal/domain/vos/phone_number.go (0.0%)</option>
				
				<option value="file42">rhapp/internal/domain/vos/province.go (0.0%)</option>
				
				<option value="file43">rhapp/internal/domain/vos/relationship.go (0.0%)</option>
				
				<option value="file44">rhapp/internal/domain/vos/salary.go (0.0%)</option>
				
				<option value="file45">rhapp/internal/domain/vos/school_degree.go (0.0%)</option>
				
				<option value="file46">rhapp/internal/domain/vos/social_security.go (0.0%)</option>
				
				<option value="file47">rhapp/internal/infrastructure/persistence/aggregate_document.go (0.0%)</option>
				
				<option value="file48">rhapp/internal/infrastructure/persistence/aggregate_employee.go (0.0%)</option>
				
				<option value="file49">rhapp/internal/infrastructure/persistence/aggregate_location.go (0.0%)</option>
				
				<option value="file50">rhapp/internal/infrastructure/persistence/aggregate_org_structure.go (0.0%)</option>
				
				<option value="file51">rhapp/internal/infrastructure/persistence/area_estudo.go (0.0%)</option>
				
				<option value="file52">rhapp/internal/infrastructure/persistence/departamento.go (0.0%)</option>
				
				<option value="file53">rhapp/internal/infrastructure/persistence/dependent.go (0.0%)</option>
				
				<option value="file54">rhapp/internal/infrastructure/persistence/district.go (0.0%)</option>
				
				<option value="file55">rhapp/internal/infrastructure/persistence/document.go (0.0%)</option>
				
				<option value="file56">rhapp/internal/infrastructure/persistence/education.go (0.0%)</option>
				
				<option value="file57">rhapp/internal/infrastructure/persistence/employee.go (0.0%)</option>
				
				<option value="file58">rhapp/internal/infrastructure/persistence/employee_status.go (0.0%)</option>
				
				<option value="file59">rhapp/internal/infrastructure/persistence/municipality.go (0.0%)</option>
				
				<option value="file60">rhapp/internal/infrastructure/persistence/position.go (0.0%)</option>
				
				<option value="file61">rhapp/internal/infrastructure/persistence/provincia.go (97.0%)</option>
				
				<option value="file62">rhapp/internal/infrastructure/persistence/supervisor.go (0.0%)</option>
				
				<option value="file63">rhapp/internal/infrastructure/persistence/work.go (0.0%)</option>
				
				<option value="file64">rhapp/internal/infrastructure/postgresdb/postgres.go (0.0%)</option>
				
				<option value="file65">rhapp/internal/infrastructure/redisdb/redis.go (0.0%)</option>
				
				<option value="file66">rhapp/internal/interfaces/handlers/agregados.go (0.0%)</option>
				
				<option value="file67">rhapp/internal/interfaces/handlers/area_estudo.go (0.0%)</option>
				
				<option value="file68">rhapp/internal/interfaces/handlers/department.go (0.0%)</option>
				
				<option value="file69">rhapp/internal/interfaces/handlers/dependent.go (0.0%)</option>
				
				<option value="file70">rhapp/internal/interfaces/handlers/distrito.go (0.0%)</option>
				
				<option value="file71">rhapp/internal/interfaces/handlers/document.go (0.0%)</option>
				
				<option value="file72">rhapp/internal/interfaces/handlers/education.go (0.0%)</option>
				
				<option value="file73">rhapp/internal/interfaces/handlers/employee.go (0.0%)</option>
				
				<option value="file74">rhapp/internal/interfaces/handlers/employee_status.go (0.0%)</option>
				
				<option value="file75">rhapp/internal/interfaces/handlers/municipio.go (0.0%)</option>
				
				<option value="file76">rhapp/internal/interfaces/handlers/position.go (0.0%)</option>
				
				<option value="file77">rhapp/internal/interfaces/handlers/provincia.go (29.9%)</option>
				
				<option value="file78">rhapp/internal/interfaces/handlers/supervisor.go (0.0%)</option>
				
				<option value="file79">rhapp/internal/interfaces/handlers/work.go (0.0%)</option>
				
				<option value="file80">rhapp/internal/interfaces/middleware/authorization.go (0.0%)</option>
				
				<option value="file81">rhapp/internal/interfaces/middleware/body_limit.go (0.0%)</option>
				
				<option value="file82">rhapp/internal/interfaces/middleware/cors.go (0.0%)</option>
				
				<option value="file83">rhapp/internal/interfaces/middleware/json.go (0.0%)</option>
				
				<option value="file84">rhapp/internal/interfaces/middleware/logging.go (0.0%)</option>
				
				<option value="file85">rhapp/internal/interfaces/middleware/rate_limiting.go (0.0%)</option>
				
				<option value="file86">rhapp/internal/interfaces/middleware/recovery.go (0.0%)</option>
				
				<option value="file87">rhapp/internal/interfaces/middleware/request_id.go (0.0%)</option>
				
				<option value="file88">rhapp/internal/interfaces/middleware/trail_slash.go (0.0%)</option>
				
				<option value="file89">rhapp/internal/interfaces/middleware/user_context.go (0.0%)</option>
				
				<option value="file90">rhapp/internal/interfaces/middleware/validate_input.go (0.0%)</option>
				
				<option value="file91">rhapp/internal/interfaces/router/router.go (0.0%)</option>
				
				<option value="file92">rhapp/internal/usecase/agregados/agg_document.go (0.0%)</option>
				
				<option value="file93">rhapp/internal/usecase/agregados/agg_employee.go (0.0%)</option>
				
				<option value="file94">rhapp/internal/usecase/agregados/agg_location.go (0.0%)</option>
				
				<option value="file95">rhapp/internal/usecase/agregados/agg_org_structure.go (0.0%)</option>
				
				<option value="file96">rhapp/internal/usecase/areas_estudo/create_area_estudo.go (0.0%)</option>
				
				<option value="file97">rhapp/internal/usecase/areas_estudo/delete_area_estudo.go (0.0%)</option>
				
				<option value="file98">rhapp/internal/usecase/areas_estudo/get_area_estudo_by_id.go (0.0%)</option>
				
				<option value="file99">rhapp/internal/usecase/areas_estudo/list_area_estudo.go (0.0%)</option>
				
				<option value="file100">rhapp/internal/usecase/areas_estudo/search.go (0.0%)</option>
				
				<option value="file101">rhapp/internal/usecase/areas_estudo/update_area_estudo.go (0.0%)</option>
				
				<option value="file102">rhapp/internal/usecase/departments/create_department.go (0.0%)</option>
				
				<option value="file103">rhapp/internal/usecase/departments/delete_department.go (0.0%)</option>
				
				<option value="file104">rhapp/internal/usecase/departments/find_department_by_id.go (0.0%)</option>
				
				<option value="file105">rhapp/internal/usecase/departments/find_departments.go (0.0%)</option>
				
				<option value="file106">rhapp/internal/usecase/departments/search.go (0.0%)</option>
				
				<option value="file107">rhapp/internal/usecase/departments/update_department.go (0.0%)</option>
				
				<option value="file108">rhapp/internal/usecase/dependents/create_dependent_usecase.go (0.0%)</option>
				
				<option value="file109">rhapp/internal/usecase/dependents/delete_dependent_usecase.go (0.0%)</option>
				
				<option value="file110">rhapp/internal/usecase/dependents/find_dependent_by_id_usecase.go (0.0%)</option>
				
				<option value="file111">rhapp/internal/usecase/dependents/list_dependents_usecase.go (0.0%)</option>
				
				<option value="file112">rhapp/internal/usecase/dependents/search.go (0.0%)</option>
				
				<option value="file113">rhapp/internal/usecase/dependents/update_dependent_usecase.go (0.0%)</option>
				
				<option value="file114">rhapp/internal/usecase/distritos/create_district.go (0.0%)</option>
				
				<option value="file115">rhapp/internal/usecase/distritos/delete_district.go (0.0%)</option>
				
				<option value="file116">rhapp/internal/usecase/distritos/find_all_district.go (0.0%)</option>
				
				<option value="file117">rhapp/internal/usecase/distritos/find_one_district.go (0.0%)</option>
				
				<option value="file118">rhapp/internal/usecase/distritos/search.go (0.0%)</option>
				
				<option value="file119">rhapp/internal/usecase/distritos/update_district.go (0.0%)</option>
				
				<option value="file120">rhapp/internal/usecase/documents_uc/create.go (0.0%)</option>
				
				<option value="file121">rhapp/internal/usecase/documents_uc/delete.go (0.0%)</option>
				
				<option value="file122">rhapp/internal/usecase/documents_uc/find_all.go (0.0%)</option>
				
				<option value="file123">rhapp/internal/usecase/documents_uc/find_one.go (0.0%)</option>
				
				<option value="file124">rhapp/internal/usecase/documents_uc/update.go (0.0%)</option>
				
				<option value="file125">rhapp/internal/usecase/education/create.go (0.0%)</option>
				
				<option value="file126">rhapp/internal/usecase/education/delete.go (0.0%)</option>
				
				<option value="file127">rhapp/internal/usecase/education/find_all.go (0.0%)</option>
				
				<option value="file128">rhapp/internal/usecase/education/find_one.go (0.0%)</option>
				
				<option value="file129">rhapp/internal/usecase/education/update.go (0.0%)</option>
				
				<option value="file130">rhapp/internal/usecase/employee_status/create.go (0.0%)</option>
				
				<option value="file131">rhapp/internal/usecase/employee_status/delete.go (0.0%)</option>
				
				<option value="file132">rhapp/internal/usecase/employee_status/find_all.go (0.0%)</option>
				
				<option value="file133">rhapp/internal/usecase/employee_status/find_one.go (0.0%)</option>
				
				<option value="file134">rhapp/internal/usecase/employee_status/update.go (0.0%)</option>
				
				<option value="file135">rhapp/internal/usecase/employees/create_employee.go (0.0%)</option>
				
				<option value="file136">rhapp/internal/usecase/employees/delete_employee.go (0.0%)</option>
				
				<option value="file137">rhapp/internal/usecase/employees/find_by_id.go (0.0%)</option>
				
				<option value="file138">rhapp/internal/usecase/employees/list_employees.go (0.0%)</option>
				
				<option value="file139">rhapp/internal/usecase/employees/search.go (0.0%)</option>
				
				<option value="file140">rhapp/internal/usecase/employees/update_employee.go (0.0%)</option>
				
				<option value="file141">rhapp/internal/usecase/municipios/create_municipio.go (0.0%)</option>
				
				<option value="file142">rhapp/internal/usecase/municipios/delete_municipio.go (0.0%)</option>
				
				<option value="file143">rhapp/internal/usecase/municipios/find_all_municipios.go (0.0%)</option>
				
				<option value="file144">rhapp/internal/usecase/municipios/find_one_municipio.go (0.0%)</option>
				
				<option value="file145">rhapp/internal/usecase/municipios/search.go (0.0%)</option>
				
				<option value="file146">rhapp/internal/usecase/municipios/update_municipio.go (0.0%)</option>
				
				<option value="file147">rhapp/internal/usecase/positions/create_position.go (0.0%)</option>
				
				<option value="file148">rhapp/internal/usecase/positions/delete_position.go (0.0%)</option>
				
				<option value="file149">rhapp/internal/usecase/positions/find_all_positions.go (0.0%)</option>
				
				<option value="file150">rhapp/internal/usecase/positions/find_position_by_id.go (0.0%)</option>
				
				<option value="file151">rhapp/internal/usecase/positions/search.go (0.0%)</option>
				
				<option value="file152">rhapp/internal/usecase/positions/update_position.go (0.0%)</option>
				
				<option value="file153">rhapp/internal/usecase/provincias/create_provincia.go (100.0%)</option>
				
				<option value="file154">rhapp/internal/usecase/provincias/delete_provincia.go (0.0%)</option>
				
				<option value="file155">rhapp/internal/usecase/provincias/find_by_id_provincia.go (0.0%)</option>
				
				<option value="file156">rhapp/internal/usecase/provincias/list.go (0.0%)</option>
				
				<option value="file157">rhapp/internal/usecase/provincias/search.go (0.0%)</option>
				
				<option value="file158">rhapp/internal/usecase/provincias/update_provincia.go (0.0%)</option>
				
				<option value="file159">rhapp/internal/usecase/supervisor/create.go (0.0%)</option>
				
				<option value="file160">rhapp/internal/usecase/supervisor/delete.go (0.0%)</option>
				
				<option value="file161">rhapp/internal/usecase/supervisor/find_one.go (0.0%)</option>
				
				<option value="file162">rhapp/internal/usecase/supervisor/list.go (0.0%)</option>
				
				<option value="file163">rhapp/internal/usecase/supervisor/update.go (0.0%)</option>
				
				<option value="file164">rhapp/internal/usecase/workhistory/create.go (0.0%)</option>
				
				<option value="file165">rhapp/internal/usecase/workhistory/delete.go (0.0%)</option>
				
				<option value="file166">rhapp/internal/usecase/workhistory/find_one.go (0.0%)</option>
				
				<option value="file167">rhapp/internal/usecase/workhistory/list.go (0.0%)</option>
				
				<option value="file168">rhapp/internal/usecase/workhistory/update.go (0.0%)</option>
				
				<option value="file169">rhapp/internal/utils/errors.go (0.0%)</option>
				
				<option value="file170">rhapp/internal/utils/pagination.go (0.0%)</option>
				
				<option value="file171">rhapp/internal/utils/search.go (0.0%)</option>
				
				<option value="file172">rhapp/internal/utils/validate_json_fields.go (0.0%)</option>
				
				<option value="file173">rhapp/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://localhost:8080/terms",
        "contact": {
            "name": "Equipa de Desenvolvimento",
            "email": "suporte@empresa.com"
        },
        "license": {
            "name": "MIT",
            "url": "https://opensource.org/licenses/MIT"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/provinces/{id}": {
            "get": {
                "description": "Retorna os dados de uma província pelo seu ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Províncias"
                ],
                "summary": "Buscar Província por ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID da província",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.ProvinceResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/areas-estudo": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Áreas de Estudo"
                ],
                "summary": "Listar todas as áreas de estudo",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dtos.AreaEstudoResponseDTO"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "post": {
                "description": "Cria uma nova área de estudo com nome e descrição obrigatórios.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Áreas de Estudo"
                ],
                "summary": "Criar nova Área de Estudo",
                "parameters": [
                    {
                        "description": "Dados da Área de Estudo",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.CreateAreaEstudoDTO"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/dtos.AreaEstudoResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Dados inválidos ou campos obrigatórios não preenchidos",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "409": {
                        "description": "Área de estudo já existente",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Erro interno inesperado",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/areas-estudo/{id}": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Áreas de Estudo"
                ],
                "summary": "Obter área de estudo por ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID da área de estudo",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.AreaEstudoResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Áreas de Estudo"
                ],
                "summary": "Atualizar área de estudo",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID da área de estudo",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Dados atualizados",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.UpdateAreaEstudoDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.AreaEstudoResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "delete": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Áreas de Estudo"
                ],
                "summary": "Excluir área de estudo",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID da área de estudo",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Removido com sucesso"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/departments": {
            "get": {
                "description": "Retorna uma lista de todos os departamentos cadastrados",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Departamentos"
                ],
                "summary": "Listar todos os departamentos",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dtos.DepartmentResponseDTO"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "post": {
                "description": "Cria um novo departamento com nome único",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Departamentos"
                ],
                "summary": "Criar novo departamento",
                "parameters": [
                    {
                        "description": "Dados do departamento",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.CreateDepartmentDTO"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/dtos.DepartmentResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/departments/{id}": {
            "get": {
                "description": "Retorna os dados de um departamento específico",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Departamentos"
                ],
                "summary": "Buscar departamento por ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do departamento",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.DepartmentResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "put": {
                "description": "Atualiza os dados de um departamento existente",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Departamentos"
                ],
                "summary": "Atualizar departamento",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do departamento",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Dados atualizados",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.UpdateDepartmentDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.DepartmentResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "delete": {
                "description": "Exclui um departamento existente pelo ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Departamentos"
                ],
                "summary": "Remover departamento",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do departamento",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/departments/{id}/aggregate": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Agregados"
                ],
                "summary": "Buscar departamento com posições e funcionários",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do Departamento",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/agregados.OrgStructureAggregate"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    }
                }
            }
        },
        "/dependents": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Dependentes"
                ],
                "summary": "Listar dependentes",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Limite",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Offset",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dtos.DependentResponseDTO"
                            }
                        }
                    }
                }
            }
        },
        "/dependents/{id}": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Dependentes"
                ],
                "summary": "Buscar dependente por ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do dependente",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.DependentResponseDTO"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    }
                }
            },
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Dependentes"
                ],
                "summary": "Atualizar dependente",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do dependente",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Dados do dependente",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.UpdateDependentDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.DependentResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    }
                }
            },
            "delete": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Dependentes"
                ],
                "summary": "Deletar dependente",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do dependente",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    }
                }
            }
        },
        "/districts": {
            "get": {
                "description": "Retorna uma lista com todos os distritos cadastrados",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Distritos"
                ],
                "summary": "Lista todos os distritos",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dtos.DistritoResponseDTO"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "post": {
                "description": "Registra um novo distrito associado a um município",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Distritos"
                ],
                "summary": "Cria um novo distrito",
                "parameters": [
                    {
                        "description": "Dados do distrito",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.CreateDistritoDTO"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/dtos.DistritoResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/districts/{id}": {
            "get": {
                "description": "Retorna os dados de um distrito específico",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Distritos"
                ],
                "summary": "Busca um distrito pelo ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do distrito",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.DistritoResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "put": {
                "description": "Modifica o nome e/ou município de um distrito existente",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Distritos"
                ],
                "summary": "Atualiza os dados de um distrito",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do distrito",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Dados atualizados",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.UpdateDistritoDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.DistritoResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "delete": {
                "description": "Exclui um distrito pelo ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Distritos"
                ],
                "summary": "Remove um distrito",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do distrito",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/documents": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Documentos"
                ],
                "summary": "Listar Documentos",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Limite",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Offset",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dtos.DocumentResponseDTO"
                            }
                        }
                    }
                }
            }
        },
        "/documents/aggregate": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Agregados"
                ],
                "summary": "Buscar documentos por proprietário",
                "parameters": [
                    {
                        "type": "string",
                        "description": "employee ou dependent",
                        "name": "owner_type",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "UUID do proprietário",
                        "name": "owner_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/agregados.DocumentAggregate"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    }
                }
            }
        },
        "/documents/{id}": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Documentos"
                ],
                "summary": "Buscar Documento por ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do documento",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.DocumentResponseDTO"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    }
                }
            },
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Documentos"
                ],
                "summary": "Atualizar Documento",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do documento",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Dados atualizados",
                        "name": "data",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.UpdateDocumentDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.DocumentResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    }
                }
            },
            "delete": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Documentos"
                ],
                "summary": "Deletar Documento",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do documento",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    }
                }
            }
        },
        "/employee-status": {
            "get": {
                "tags": [
                    "EmployeeStatus"
                ],
                "summary": "Listar status de funcionário",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do funcionário",
                        "name": "employee_id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Limite de resultados",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Offset de paginação",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/employee_status.CreateEmployeeStatusInput"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    }
                }
            },
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "EmployeeStatus"
                ],
                "summary": "Criar status de funcionário",
                "parameters": [
                    {
                        "description": "Dados do status",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/employee_status.CreateEmployeeStatusInput"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/employee_status.CreateEmployeeStatusInput"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    }
                }
            }
        },
        "/employee-status/{id}": {
            "get": {
                "tags": [
                    "EmployeeStatus"
                ],
                "summary": "Buscar status por ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do status",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/employee_status.CreateEmployeeStatusInput"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    }
                }
            },
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "EmployeeStatus"
                ],
                "summary": "Atualizar status",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do status",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Atualização",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/employee_status.UpdateEmployeeStatusInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/employee_status.UpdateEmployeeStatusInput"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    }
                }
            },
            "delete": {
                "tags": [
                    "EmployeeStatus"
                ],
                "summary": "Remover status",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do status",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    }
                }
            }
        },
        "/employees": {
            "post": {
                "description": "Registra um novo funcionário no sistema com todos os dados obrigatórios",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Funcionários"
                ],
                "summary": "Cria um novo funcionário",
                "parameters": [
                    {
                        "description": "Dados do funcionário",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.CreateEmployeeDTO"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/dtos.EmployeeResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/employees/{employee_id}/work_history": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Histórico Profissional"
                ],
                "summary": "Listar históricos profissionais de um funcionário",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do Funcionário",
                        "name": "employee_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Limite",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Offset",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dtos.WorkResponseDTO"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/employees/{id}/aggregate": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Agregados"
                ],
                "summary": "Buscar dados completos de um funcionário",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do Funcionário",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/agregados.EmployeeAggregate"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    }
                }
            }
        },
        "/municipalities": {
            "get": {
                "description": "Retorna todos os municípios cadastrados",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Municípios"
                ],
                "summary": "Lista todos os municípios",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dtos.MunicipioResponseDTO"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "post": {
                "description": "Registra um novo município associado a uma província",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Municípios"
                ],
                "summary": "Cria um novo município",
                "parameters": [
                    {
                        "description": "Dados do município",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.CreateMunicipioDTO"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/dtos.MunicipioResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/municipalities/{id}": {
            "get": {
                "description": "Retorna os dados de um município específico",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Municípios"
                ],
                "summary": "Busca um município pelo ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do município",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.MunicipioResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "put": {
                "description": "Modifica o nome ou província associada a um município existente",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Municípios"
                ],
                "summary": "Atualiza os dados de um município",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do município",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Dados atualizados",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.UpdateMunicipioDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.MunicipioResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "delete": {
                "description": "Exclui um município pelo ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Municípios"
                ],
                "summary": "Remove um município",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do município",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/positions": {
            "get": {
                "description": "Lista todas as posições cadastradas",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Posições"
                ],
                "summary": "Listar posições",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dtos.PositionResponseDTO"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "post": {
                "description": "Cria uma nova posição (cargo) associada a um departamento",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Posições"
                ],
                "summary": "Criar nova posição",
                "parameters": [
                    {
                        "description": "Dados da posição",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.CreatePositionDTO"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/dtos.PositionResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/positions/{id}": {
            "get": {
                "description": "Retorna os dados de uma posição específica",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Posições"
                ],
                "summary": "Buscar posição por ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID da posição",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.PositionResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "put": {
                "description": "Atualiza os dados de uma posição existente",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Posições"
                ],
                "summary": "Atualizar posição",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID da posição",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Campos atualizados",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.UpdatePositionDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.PositionResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "delete": {
                "description": "Remove uma posição com base no ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Posições"
                ],
                "summary": "Remover posição",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID da posição",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/provinces": {
            "get": {
                "description": "Retorna a lista de todas as províncias cadastradas",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Províncias"
                ],
                "summary": "Listar Províncias",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dtos.ProvinceResponseDTO"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "post": {
                "description": "Cria uma nova província",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Províncias"
                ],
                "summary": "Criar Província",
                "parameters": [
                    {
                        "description": "Dados da província",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.CreateProvinceDoc"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/dtos.ProvinceResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Validation error with fields detail",
                        "schema": {
                            "$ref": "#/definitions/utils.Payload"
                        }
                    },
                    "409": {
                        "description": "Conflito (chave única)",
                        "schema": {
                            "$ref": "#/definitions/utils.Payload"
                        }
                    },
                    "500": {
                        "description": "Erro interno",
                        "schema": {
                            "$ref": "#/definitions/utils.Payload"
                        }
                    }
                }
            }
        },
        "/provinces/{id}": {
            "put": {
                "description": "Atualiza os dados de uma província existente",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Províncias"
                ],
                "summary": "Atualizar Província",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID da província",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Dados atualizados",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.UpdateProvinceDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.ProvinceResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "delete": {
                "description": "Remove uma província existente pelo ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Províncias"
                ],
                "summary": "Remover Província",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID da província",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/provinces/{id}/aggregate": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Agregados"
                ],
                "summary": "Buscar província com municípios e distritos",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID da Província",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/agregados.LocationAggregate"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/gin.H"
                        }
                    }
                }
            }
        },
        "/search/provinces": {
            "get": {
                "description": "Busca províncias com filtros e paginação",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Busca"
                ],
                "summary": "Buscar províncias",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Texto de busca (nome da província)",
                        "name": "search",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Filtro genérico",
                        "name": "filter",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Número máximo de registros a retornar",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Número de registros a ignorar (para paginação)",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dtos.ProvinceResponseDTO"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/work_history": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Histórico Profissional"
                ],
                "summary": "Criar novo histórico profissional",
                "parameters": [
                    {
                        "description": "Dados do histórico profissional",
                        "name": "data",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.CreateWorkDTO"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/dtos.WorkResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/work_history/{id}": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Histórico Profissional"
                ],
                "summary": "Buscar histórico profissional por ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do Histórico",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.WorkResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Histórico Profissional"
                ],
                "summary": "Atualizar histórico profissional",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do Histórico",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Campos a atualizar",
                        "name": "data",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.UpdateWorkDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.WorkResponseDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "delete": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Histórico Profissional"
                ],
                "summary": "Remover histórico profissional",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID do Histórico",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "agregados.DocumentAggregate": {
            "type": "object",
            "properties": {
                "documents": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/entities.Document"
                    }
                },
                "ownerID": {
                    "type": "string"
                },
                "ownerType": {
                    "$ref": "#/definitions/vos.DocumentOwnerType"
                }
            }
        },
        "agregados.EmployeeAggregate": {
            "type": "object",
            "properties": {
                "dependents": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/entities.Dependent"
                    }
                },
                "documents": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/entities.Document"
                    }
                },
                "educationHistories": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/entities.EducationHistory"
                    }
                },
                "employee": {
                    "$ref": "#/definitions/entities.Employee"
                },
                "statuses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/entities.EmployeeStatus"
                    }
                },
                "supervisorHistory": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/entities.SupervisorHistory"
                    }
                },
                "workHistories": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/entities.WorkHistory"
                    }
                }
            }
        },
        "agregados.LocationAggregate": {
            "type": "object",
            "properties": {
                "districts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/entities.District"
                    }
                },
                "municipalities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/entities.Municipality"
                    }
                },
                "province": {
                    "$ref": "#/definitions/entities.Province"
                }
            }
        },
        "agregados.OrgStructureAggregate": {
            "type": "object",
            "properties": {
                "department": {
                    "$ref": "#/definitions/entities.Department"
                },
                "employees": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/entities.Employee"
                    }
                },
                "positions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/entities.Position"
                    }
                }
            }
        },
        "dtos.AreaEstudoResponseDTO": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "dtos.CreateAreaEstudoDTO": {
            "type": "object",
            "required": [
                "description",
                "name"
            ],
            "properties": {
                "description": {
                    "type": "string",
                    "maxLength": 255,
                    "minLength": 5
                },
                "name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 3
                }
            }
        },
        "dtos.CreateDepartmentDTO": {
            "type": "object",
            "required": [
                "name"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 2
                }
            }
        },
        "dtos.CreateDistritoDTO": {
            "type": "object",
            "required": [
                "municipio_id",
                "name"
            ],
            "properties": {
                "municipio_id": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 2
                }
            }
        },
        "dtos.CreateEmployeeDTO": {
            "type": "object",
            "required": [
                "address",
                "bi",
                "contract_type",
                "date_of_birth",
                "department_id",
                "district_id",
                "email",
                "employee_number",
                "full_name",
                "gender",
                "hiring_date",
                "iban",
                "marital_status",
                "nationality",
                "phone_number",
                "position_id",
                "salary",
                "social_security"
            ],
            "properties": {
                "address": {
                    "type": "string",
                    "maxLength": 200,
                    "minLength": 5
                },
                "bi": {
                    "type": "string"
                },
                "contract_type": {
                    "type": "string",
                    "enum": [
                        "permanent",
                        "temporary",
                        "intern",
                        "consultant"
                    ]
                },
                "date_of_birth": {
                    "type": "string"
                },
                "department_id": {
                    "type": "string"
                },
                "district_id": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "employee_number": {
                    "type": "integer"
                },
                "full_name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 3
                },
                "gender": {
                    "type": "string",
                    "enum": [
                        "masculino",
                        "feminino"
                    ]
                },
                "hiring_date": {
                    "type": "string"
                },
                "iban": {
                    "type": "string",
                    "maxLength": 34,
                    "minLength": 10
                },
                "marital_status": {
                    "type": "string",
                    "enum": [
                        "single",
                        "married",
                        "divorced",
                        "widowed"
                    ]
                },
                "nationality": {
                    "type": "string",
                    "maxLength": 50,
                    "minLength": 2
                },
                "phone_number": {
                    "type": "string"
                },
                "position_id": {
                    "type": "string"
                },
                "salary": {
                    "type": "number"
                },
                "social_security": {
                    "type": "string",
                    "maxLength": 12,
                    "minLength": 6
                },
                "supervisor_id": {
                    "type": "string"
                }
            }
        },
        "dtos.CreateMunicipioDTO": {
            "type": "object",
            "required": [
                "name",
                "provincia_id"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 2
                },
                "provincia_id": {
                    "type": "string"
                }
            }
        },
        "dtos.CreatePositionDTO": {
            "type": "object",
            "required": [
                "department_id",
                "name"
            ],
            "properties": {
                "department_id": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 2
                }
            }
        },
        "dtos.CreateProvinceDoc": {
            "type": "object",
            "properties": {
                "nome": {
                    "description": "Nome da Província\nexample: Luanda",
                    "type": "string",
                    "example": "Luanda"
                }
            }
        },
        "dtos.CreateWorkDTO": {
            "type": "object",
            "required": [
                "company",
                "employee_id",
                "position",
                "start_date"
            ],
            "properties": {
                "company": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 2
                },
                "employee_id": {
                    "type": "string"
                },
                "end_date": {
                    "type": "string"
                },
                "position": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 2
                },
                "responsibilities": {
                    "type": "string",
                    "maxLength": 500
                },
                "start_date": {
                    "type": "string"
                }
            }
        },
        "dtos.DepartmentResponseDTO": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "dtos.DependentResponseDTO": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "date_of_birth": {
                    "type": "string"
                },
                "employee_id": {
                    "type": "string"
                },
                "full_name": {
                    "type": "string"
                },
                "gender": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "is_active": {
                    "type": "boolean"
                },
                "relationship": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "dtos.DistritoResponseDTO": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "municipio_id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "dtos.DocumentResponseDTO": {
            "type": "object",
            "properties": {
                "file_url": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "is_active": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "owner_id": {
                    "type": "string"
                },
                "owner_type": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                },
                "uploaded_at": {
                    "type": "string"
                }
            }
        },
        "dtos.EmployeeResponseDTO": {
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "bi": {
                    "type": "string"
                },
                "contract_type": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "date_of_birth": {
                    "type": "string"
                },
                "department_id": {
                    "type": "string"
                },
                "district_id": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "employee_number": {
                    "type": "integer"
                },
                "full_name": {
                    "type": "string"
                },
                "gender": {
                    "type": "string"
                },
                "hiring_date": {
                    "type": "string"
                },
                "iban": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "is_active": {
                    "type": "boolean"
                },
                "marital_status": {
                    "type": "string"
                },
                "nationality": {
                    "type": "string"
                },
                "phone_number": {
                    "type": "string"
                },
                "position_id": {
                    "type": "string"
                },
                "salary": {
                    "type": "number"
                },
                "social_security": {
                    "type": "string"
                },
                "supervisor_id": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "dtos.MunicipioResponseDTO": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "provincia_id": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "dtos.PositionResponseDTO": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "department_id": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "dtos.ProvinceResponseDTO": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "nome": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "dtos.UpdateAreaEstudoDTO": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string",
                    "maxLength": 255,
                    "minLength": 5
                },
                "name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 3
                }
            }
        },
        "dtos.UpdateDepartmentDTO": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 2
                }
            }
        },
        "dtos.UpdateDependentDTO": {
            "type": "object",
            "properties": {
                "date_of_birth": {
                    "type": "string"
                },
                "full_name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 3
                },
                "gender": {
                    "type": "string",
                    "enum": [
                        "male",
                        "female",
                        "other"
                    ]
                },
                "is_active": {
                    "type": "boolean"
                },
                "relationship": {
                    "type": "string",
                    "enum": [
                        "child",
                        "spouse",
                        "parent",
                        "other"
                    ]
                }
            }
        },
        "dtos.UpdateDistritoDTO": {
            "type": "object",
            "properties": {
                "municipio_id": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 2
                }
            }
        },
        "dtos.UpdateDocumentDTO": {
            "type": "object",
            "properties": {
                "is_active": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 3
                },
                "type": {
                    "type": "string",
                    "enum": [
                        "bi",
                        "diploma",
                        "contrato",
                        "outro"
                    ]
                }
            }
        },
        "dtos.UpdateMunicipioDTO": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 2
                },
                "provincia_id": {
                    "type": "string"
                }
            }
        },
        "dtos.UpdatePositionDTO": {
            "type": "object",
            "properties": {
                "department_id": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 2
                }
            }
        },
        "dtos.UpdateProvinceDTO": {
            "type": "object",
            "required": [
                "nome"
            ],
            "properties": {
                "nome": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 3
                }
            }
        },
        "dtos.UpdateWorkDTO": {
            "type": "object",
            "properties": {
                "company": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 2
                },
                "end_date": {
                    "type": "string"
                },
                "position": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 2
                },
                "responsibilities": {
                    "type": "string",
                    "maxLength": 500
                },
                "start_date": {
                    "type": "string"
                }
            }
        },
        "dtos.WorkResponseDTO": {
            "type": "object",
            "properties": {
                "company": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "employee_id": {
                    "type": "string"
                },
                "end_date": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "position": {
                    "type": "string"
                },
                "responsibilities": {
                    "type": "string"
                },
                "start_date": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "employee_status.CreateEmployeeStatusInput": {
            "type": "object",
            "properties": {
                "employeeID": {
                    "type": "string"
                },
                "endDate": {
                    "type": "string"
                },
                "isCurrent": {
                    "type": "boolean"
                },
                "reason": {
                    "type": "string"
                },
                "startDate": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "employee_status.UpdateEmployeeStatusInput": {
            "type": "object",
            "properties": {
                "endDate": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "isCurrent": {
                    "type": "boolean"
                },
                "reason": {
                    "type": "string"
                },
                "startDate": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "entities.Department": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "entities.Dependent": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "dateOfBirth": {
                    "$ref": "#/definitions/vos.BirthDate"
                },
                "employeeID": {
                    "type": "string"
                },
                "fullName": {
                    "$ref": "#/definitions/vos.PersonalName"
                },
                "gender": {
                    "$ref": "#/definitions/vos.Gender"
                },
                "id": {
                    "type": "string"
                },
                "isActive": {
                    "type": "boolean"
                },
                "relationship": {
                    "$ref": "#/definitions/vos.RelationshipType"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "entities.District": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "municipalityID": {
                    "type": "string"
                },
                "name": {
                    "$ref": "#/definitions/vos.District"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "entities.Document": {
            "type": "object",
            "properties": {
                "extension": {
                    "description": "jpg, pdf, png, etc.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/vos.FileExtension"
                        }
                    ]
                },
                "fileName": {
                    "$ref": "#/definitions/vos.Filename"
                },
                "fileURL": {
                    "$ref": "#/definitions/vos.DocumentURL"
                },
                "id": {
                    "type": "string"
                },
                "isActive": {
                    "type": "boolean"
                },
                "ownerID": {
                    "description": "ID do proprietário (Employee ou Dependent)",
                    "type": "string"
                },
                "ownerType": {
                    "description": "\"employee\", \"dependent\", etc.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/vos.DocumentOwnerType"
                        }
                    ]
                },
                "type": {
                    "description": "BI, Contrato, Diploma, etc.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/vos.DocumentType"
                        }
                    ]
                },
                "uploadedAt": {
                    "type": "string"
                }
            }
        },
        "entities.EducationHistory": {
            "type": "object",
            "properties": {
                "areaEstudoID": {
                    "type": "string"
                },
                "createdAt": {
                    "type": "string"
                },
                "degree": {
                    "$ref": "#/definitions/vos.SchoolDegree"
                },
                "description": {
                    "type": "string"
                },
                "employeeID": {
                    "type": "string"
                },
                "endDate": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "institution": {
                    "type": "string"
                },
                "isCurrent": {
                    "type": "boolean"
                },
                "startDate": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "entities.Employee": {
            "type": "object",
            "properties": {
                "address": {
                    "$ref": "#/definitions/vos.Address"
                },
                "bi": {
                    "$ref": "#/definitions/vos.BI"
                },
                "contractType": {
                    "type": "string"
                },
                "createdAt": {
                    "type": "string"
                },
                "dateOfBirth": {
                    "type": "string"
                },
                "departmentID": {
                    "type": "string"
                },
                "districtID": {
                    "type": "string"
                },
                "email": {
                    "$ref": "#/definitions/vos.Email"
                },
                "employeeNumber": {
                    "type": "integer"
                },
                "fullName": {
                    "$ref": "#/definitions/vos.PersonalName"
                },
                "gender": {
                    "$ref": "#/definitions/vos.Gender"
                },
                "hiringDate": {
                    "type": "string"
                },
                "iban": {
                    "$ref": "#/definitions/vos.IBAN"
                },
                "id": {
                    "type": "string"
                },
                "isActive": {
                    "type": "boolean"
                },
                "maritalStatus": {
                    "$ref": "#/definitions/vos.MaritalStatus"
                },
                "nationality": {
                    "$ref": "#/definitions/vos.Nationality"
                },
                "phoneNumber": {
                    "$ref": "#/definitions/vos.PhoneNumber"
                },
                "positionID": {
                    "type": "string"
                },
                "salary": {
                    "$ref": "#/definitions/vos.Salary"
                },
                "socialSecurity": {
                    "$ref": "#/definitions/vos.SocialSecurity"
                },
                "supervisor_id": {
                    "description": "SupervisorID agora é computado via SupervisorHistory (não persistido diretamente)",
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "entities.EmployeeStatus": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "employeeID": {
                    "type": "string"
                },
                "endDate": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "isCurrent": {
                    "type": "boolean"
                },
                "reason": {
                    "$ref": "#/definitions/vos.StatusReason"
                },
                "startDate": {
                    "type": "string"
                },
                "status": {
                    "$ref": "#/definitions/vos.EmployeeStatus"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "entities.Municipality": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "$ref": "#/definitions/vos.Municipality"
                },
                "provinceID": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "entities.Position": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "departmentID": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "entities.Province": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "nome": {
                    "$ref": "#/definitions/vos.Province"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "entities.SupervisorHistory": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "employeeID": {
                    "type": "string"
                },
                "endDate": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "startDate": {
                    "type": "string"
                },
                "supervisorID": {
                    "description": "permite null (ex: sem chefe)",
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "entities.WorkHistory": {
            "type": "object",
            "properties": {
                "company": {
                    "type": "string"
                },
                "createdAt": {
                    "type": "string"
                },
                "employeeID": {
                    "type": "string"
                },
                "endDate": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "isCurrent": {
                    "type": "boolean"
                },
                "position": {
                    "type": "string"
                },
                "responsibilities": {
                    "type": "string"
                },
                "startDate": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "gin.H": {
            "type": "object",
            "additionalProperties": {}
        },
        "utils.FieldError": {
            "type": "object",
            "properties": {
                "field": {
                    "type": "string"
                },
                "label": {
                    "type": "string"
                },
                "message": {
                    "type": "string"
                },
                "tag": {
                    "type": "string"
                },
                "value": {}
            }
        },
        "utils.Payload": {
            "type": "object",
            "properties": {
                "error": {
                    "description": "ex: validation_failed, conflict, internal",
                    "type": "string"
                },
                "fields": {
                    "description": "detalhes por campo",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/utils.FieldError"
                    }
                },
                "message": {
                    "description": "resumo humanizado",
                    "type": "string"
                }
            }
        },
        "vos.Address": {
            "type": "object"
        },
        "vos.BI": {
            "type": "object"
        },
        "vos.BirthDate": {
            "type": "object"
        },
        "vos.District": {
            "type": "object"
        },
        "vos.DocumentOwnerType": {
            "type": "string",
            "enum": [
                "employee",
                "dependent"
            ],
            "x-enum-varnames": [
                "DocumentOwnerEmployee",
                "DocumentOwnerDependent"
            ]
        },
        "vos.DocumentType": {
            "type": "object"
        },
        "vos.DocumentURL": {
            "type": "object"
        },
        "vos.Email": {
            "type": "object"
        },
        "vos.EmployeeStatus": {
            "type": "object"
        },
        "vos.FileExtension": {
            "type": "object"
        },
        "vos.Filename": {
            "type": "object"
        },
        "vos.Gender": {
            "type": "object"
        },
        "vos.IBAN": {
            "type": "object"
        },
        "vos.MaritalStatus": {
            "type": "object"
        },
        "vos.Municipality": {
            "type": "object"
        },
        "vos.Nationality": {
            "type": "object"
        },
        "vos.PersonalName": {
            "type": "object"
        },
        "vos.PhoneNumber": {
            "type": "object"
        },
        "vos.Province": {
            "type": "object"
        },
        "vos.RelationshipType": {
            "type": "object"
        },
        "vos.Salary": {
            "type": "object"
        },
        "vos.SchoolDegree": {
            "type": "object"
        },
        "vos.SocialSecurity": {
            "type": "object"
        },
        "vos.StatusReason": {
            "type": "object"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/api",
        Schemes:          []string{"http"},
        Title:            "HRMS API",
        Description:      "API de Gestão de Recursos Humanos (Províncias, Municípios, Departamentos, etc.)",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package agregados

import (
        "context"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/vos"
        "time"

        "github.com/google/uuid"
)

type DocumentAggregate struct {
        OwnerType vos.DocumentOwnerType
        OwnerID   uuid.UUID
        Documents []entities.Document
}

func (agg *DocumentAggregate) AddDocument(doc entities.Document) <span class="cov0" title="0">{
        doc.UploadedAt = time.Now()
        agg.Documents = append(agg.Documents, doc)
}</span>

func (agg *DocumentAggregate) ListActiveDocuments() []entities.Document <span class="cov0" title="0">{
        var result []entities.Document
        for _, doc := range agg.Documents </span><span class="cov0" title="0">{
                if doc.IsActive </span><span class="cov0" title="0">{
                        result = append(result, doc)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

type DocumentAggregateRepository interface {
        GetByOwner(ctx context.Context, ownerType vos.DocumentOwnerType, ownerID uuid.UUID) (*DocumentAggregate, error)
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package agregados

import (
        "context"
        "rhapp/internal/domain/entities"
        "time"

        "github.com/google/uuid"
)

type EmployeeAggregate struct {
        Employee           entities.Employee
        Statuses           []entities.EmployeeStatus
        Dependents         []entities.Dependent
        EducationHistories []entities.EducationHistory
        WorkHistories      []entities.WorkHistory
        Documents          []entities.Document
        SupervisorHistory  []entities.SupervisorHistory
}

func (agg *EmployeeAggregate) AddDependent(dep entities.Dependent) <span class="cov0" title="0">{
        agg.Dependents = append(agg.Dependents, dep)
}</span>

func (agg *EmployeeAggregate) AddWorkHistory(work entities.WorkHistory) <span class="cov0" title="0">{
        agg.WorkHistories = append(agg.WorkHistories, work)
}</span>

func (agg *EmployeeAggregate) AddEducationHistory(edu entities.EducationHistory) <span class="cov0" title="0">{
        agg.EducationHistories = append(agg.EducationHistories, edu)
}</span>

func (agg *EmployeeAggregate) AddStatus(status entities.EmployeeStatus) <span class="cov0" title="0">{
        for i := range agg.Statuses </span><span class="cov0" title="0">{
                agg.Statuses[i].IsCurrent = false
        }</span>
        <span class="cov0" title="0">status.IsCurrent = true
        agg.Statuses = append(agg.Statuses, status)</span>
}

func (agg *EmployeeAggregate) AddDocument(doc entities.Document) <span class="cov0" title="0">{
        agg.Documents = append(agg.Documents, doc)
}</span>

func (agg *EmployeeAggregate) AddSupervisor(super entities.SupervisorHistory) <span class="cov0" title="0">{
        for i := range agg.SupervisorHistory </span><span class="cov0" title="0">{
                if agg.SupervisorHistory[i].EndDate == nil </span><span class="cov0" title="0">{
                        now := time.Now()
                        agg.SupervisorHistory[i].EndDate = &amp;now
                }</span>
        }
        <span class="cov0" title="0">agg.SupervisorHistory = append(agg.SupervisorHistory, super)</span>
}

type EmployeeAggregateRepository interface {
        GetFullByID(ctx context.Context, id uuid.UUID) (*EmployeeAggregate, error)
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package agregados

import (
        "context"
        "rhapp/internal/domain/entities"

        "github.com/google/uuid"
)

type LocationAggregate struct {
        Province       entities.Province
        Municipalities []entities.Municipality
        Districts      []entities.District
}

func (agg *LocationAggregate) AddMunicipality(m entities.Municipality) <span class="cov0" title="0">{
        agg.Municipalities = append(agg.Municipalities, m)
}</span>

func (agg *LocationAggregate) AddDistrict(d entities.District) <span class="cov0" title="0">{
        agg.Districts = append(agg.Districts, d)
}</span>

func (agg *LocationAggregate) ListDistrictsByMunicipalityID(municipalityID uuid.UUID) []entities.District <span class="cov0" title="0">{
        var result []entities.District
        for _, d := range agg.Districts </span><span class="cov0" title="0">{
                if d.MunicipalityID == municipalityID </span><span class="cov0" title="0">{
                        result = append(result, d)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

type LocationAggregateRepository interface {
        GetByProvinceID(ctx context.Context, id uuid.UUID) (*LocationAggregate, error)
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package agregados

import (
        "context"
        "rhapp/internal/domain/entities"
        "time"

        "github.com/google/uuid"
)

type OrgStructureAggregate struct {
        Department entities.Department
        Positions  []entities.Position
        Employees  []entities.Employee
}

func (agg *OrgStructureAggregate) AddPosition(position entities.Position) <span class="cov0" title="0">{
        agg.Positions = append(agg.Positions, position)
}</span>

func (agg *OrgStructureAggregate) AssignEmployeeToPosition(emp entities.Employee, positionID uuid.UUID) <span class="cov0" title="0">{
        for i := range agg.Employees </span><span class="cov0" title="0">{
                if agg.Employees[i].ID == emp.ID </span><span class="cov0" title="0">{
                        agg.Employees[i].PositionID = positionID
                        agg.Employees[i].UpdatedAt = time.Now()
                        return
                }</span>
        }
        <span class="cov0" title="0">emp.PositionID = positionID
        emp.UpdatedAt = time.Now()
        agg.Employees = append(agg.Employees, emp)</span>
}

func (agg *OrgStructureAggregate) ChangeDepartmentForPosition(positionID uuid.UUID, departmentID uuid.UUID) <span class="cov0" title="0">{
        for i := range agg.Positions </span><span class="cov0" title="0">{
                if agg.Positions[i].ID == positionID </span><span class="cov0" title="0">{
                        agg.Positions[i].DepartmentID = departmentID
                        agg.Positions[i].UpdatedAt = time.Now()
                        return
                }</span>
        }
}

type OrgStructureAggregateRepository interface {
        GetByDepartmentID(ctx context.Context, id uuid.UUID) (*OrgStructureAggregate, error)
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package dtos

import (
        "rhapp/internal/domain/entities"
        "time"

        "github.com/google/uuid"
)

type CreateAreaEstudoDTO struct {
        Name        string `json:"name" binding:"required,min=3,max=100"`
        Description string `json:"description" binding:"required,min=5,max=255"`
}

type UpdateAreaEstudoDTO struct {
        Name        string `json:"name" binding:"omitempty,min=3,max=100"`
        Description string `json:"description" binding:"omitempty,min=5,max=255"`
}

type AreaEstudoResponseDTO struct {
        ID          string    `json:"id"`
        Name        string    `json:"name"`
        Description string    `json:"description"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
}

func ToAreaEstudoResponseDTO(a entities.AreaEstudo) AreaEstudoResponseDTO <span class="cov0" title="0">{
        return AreaEstudoResponseDTO{
                ID:          a.ID.String(),
                Name:        a.Name,
                Description: a.Description,
                CreatedAt:   a.CreatedAt,
                UpdatedAt:   a.UpdatedAt,
        }
}</span>

func ToAreaEstudoFromCreateDTO(input CreateAreaEstudoDTO) entities.AreaEstudo <span class="cov0" title="0">{
        now := time.Now()
        return entities.AreaEstudo{
                ID:          uuid.New(),
                Name:        input.Name,
                Description: input.Description,
                CreatedAt:   now,
                UpdatedAt:   now,
        }
}</span>

func ToAreaEstudoResponseDTOList(areas []entities.AreaEstudo) []AreaEstudoResponseDTO <span class="cov0" title="0">{
        result := make([]AreaEstudoResponseDTO, len(areas))
        for i, a := range areas </span><span class="cov0" title="0">{
                result[i] = ToAreaEstudoResponseDTO(a)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func ApplyUpdateToAreaEstudo(area *entities.AreaEstudo, input UpdateAreaEstudoDTO) <span class="cov0" title="0">{

        if input.Name != "" </span><span class="cov0" title="0">{
                area.Name = input.Name
        }</span>
        <span class="cov0" title="0">if input.Description != "" </span><span class="cov0" title="0">{
                area.Description = input.Description
        }</span>
        <span class="cov0" title="0">area.UpdatedAt = time.Now()</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package dtos

import (
        "rhapp/internal/domain/entities"
        "time"

        "github.com/google/uuid"
)

type CreateDepartmentDTO struct {
        Name string `json:"name" binding:"required,min=2,max=100"`
}

type UpdateDepartmentDTO struct {
        Name string `json:"name" binding:"omitempty,min=2,max=100"`
}

type DepartmentResponseDTO struct {
        ID        string    `json:"id"`
        Name      string    `json:"name"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

func ToDepartmentResponseDTO(d entities.Department) DepartmentResponseDTO <span class="cov0" title="0">{
        return DepartmentResponseDTO{
                ID:        d.ID.String(),
                Name:      d.Name,
                CreatedAt: d.CreatedAt,
                UpdatedAt: d.UpdatedAt,
        }
}</span>

func ToDepartmentFromCreateDTO(input CreateDepartmentDTO) entities.Department <span class="cov0" title="0">{
        now := time.Now()
        return entities.Department{
                ID:        uuid.New(),
                Name:      input.Name,
                CreatedAt: now,
                UpdatedAt: now,
        }
}</span>

func ApplyUpdateToDepartment(d *entities.Department, input UpdateDepartmentDTO) <span class="cov0" title="0">{
        if input.Name != "" </span><span class="cov0" title="0">{
                d.Name = input.Name
        }</span>
        <span class="cov0" title="0">d.UpdatedAt = time.Now()</span>
}

func ToDepartmentResponseDTOList(list []entities.Department) []DepartmentResponseDTO <span class="cov0" title="0">{
        result := make([]DepartmentResponseDTO, len(list))
        for i, d := range list </span><span class="cov0" title="0">{
                result[i] = ToDepartmentResponseDTO(d)
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package dtos

import (
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/vos"
        "time"

        "github.com/google/uuid"
)

type CreateDependentDTO struct {
        EmployeeID   string `json:"employee_id" binding:"required,uuid4"`
        FullName     string `json:"full_name" binding:"required,min=3,max=100"`
        Relationship string `json:"relationship" binding:"required,oneof=child spouse parent other"`
        Gender       string `json:"gender" binding:"required,oneof=male female other"`
        DateOfBirth  string `json:"date_of_birth" binding:"required,datetime=2006-01-02"`
}

type UpdateDependentDTO struct {
        FullName     string `json:"full_name" binding:"omitempty,min=3,max=100"`
        Relationship string `json:"relationship" binding:"omitempty,oneof=child spouse parent other"`
        Gender       string `json:"gender" binding:"omitempty,oneof=male female other"`
        DateOfBirth  string `json:"date_of_birth" binding:"omitempty,datetime=2006-01-02"`
        IsActive     bool   `json:"is_active,omitempty"`
}

type DependentResponseDTO struct {
        ID           string    `json:"id"`
        EmployeeID   string    `json:"employee_id"`
        FullName     string    `json:"full_name"`
        Relationship string    `json:"relationship"`
        Gender       string    `json:"gender"`
        DateOfBirth  string    `json:"date_of_birth"`
        IsActive     bool      `json:"is_active"`
        CreatedAt    time.Time `json:"created_at"`
        UpdatedAt    time.Time `json:"updated_at"`
}

func ToDependentResponseDTO(d entities.Dependent) DependentResponseDTO <span class="cov0" title="0">{
        return DependentResponseDTO{
                ID:           d.ID.String(),
                EmployeeID:   d.EmployeeID.String(),
                FullName:     d.FullName.String(),
                Relationship: d.Relationship.String(),
                Gender:       d.Gender.String(),
                DateOfBirth:  d.DateOfBirth.String(),
                IsActive:     d.IsActive,
                CreatedAt:    d.CreatedAt,
                UpdatedAt:    d.UpdatedAt,
        }
}</span>

func ToDependentFromCreateDTO(input CreateDependentDTO) (entities.Dependent, error) <span class="cov0" title="0">{
        employeeID, err := uuid.Parse(input.EmployeeID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Dependent{}, err
        }</span>

        <span class="cov0" title="0">now := time.Now()

        return entities.Dependent{
                ID:           uuid.New(),
                EmployeeID:   employeeID,
                FullName:     vos.MustNewPersonalName(input.FullName),
                Relationship: vos.MustNewRelationshipType(input.Relationship),
                Gender:       vos.MustNewGender(input.Gender),
                DateOfBirth:  vos.MustNewBirthDate(input.DateOfBirth),
                IsActive:     true,
                CreatedAt:    now,
                UpdatedAt:    now,
        }, nil</span>
}

func ApplyUpdateToDependent(d *entities.Dependent, input UpdateDependentDTO) error <span class="cov0" title="0">{
        if input.FullName != "" </span><span class="cov0" title="0">{
                d.FullName = vos.MustNewPersonalName(input.FullName)
        }</span>

        <span class="cov0" title="0">if input.Relationship != "" </span><span class="cov0" title="0">{
                d.Relationship = vos.MustNewRelationshipType(input.Relationship)
        }</span>

        <span class="cov0" title="0">if input.Gender != "" </span><span class="cov0" title="0">{
                d.Gender = vos.MustNewGender(input.Gender)
        }</span>

        <span class="cov0" title="0">if input.DateOfBirth != "" </span><span class="cov0" title="0">{
                d.DateOfBirth = vos.MustNewBirthDate(input.DateOfBirth)
        }</span>

        <span class="cov0" title="0">d.IsActive = input.IsActive

        d.UpdatedAt = time.Now()
        return nil</span>
}

func ToDependentResponseDTOList(list []entities.Dependent) []DependentResponseDTO <span class="cov0" title="0">{
        result := make([]DependentResponseDTO, len(list))
        for i, d := range list </span><span class="cov0" title="0">{
                result[i] = ToDependentResponseDTO(d)
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package dtos

import (
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/vos"
        "time"

        "github.com/google/uuid"
)

type CreateDistritoDTO struct {
        Name        string `json:"name" binding:"required,min=2,max=100"`
        MunicipioID string `json:"municipio_id" binding:"required,uuid4"`
}

type UpdateDistritoDTO struct {
        Name        string `json:"name" binding:"omitempty,min=2,max=100"`
        MunicipioID string `json:"municipio_id" binding:"omitempty,uuid4"`
}

type DistritoResponseDTO struct {
        ID          string    `json:"id"`
        Name        string    `json:"name"`
        MunicipioID string    `json:"municipio_id"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
}

type DistritoResultDTO struct {
        ID            uuid.UUID `json:"id"`
        Name          string    `json:"name"`
        MunicipioID   uuid.UUID `json:"municipio_id"`
        MunicipioName string    `json:"municipio_name"`
        CreatedAt     time.Time `json:"created_at"`
        UpdatedAt     time.Time `json:"updated_at"`
}

func ToDistritoResponseDTO(d entities.District) DistritoResponseDTO <span class="cov0" title="0">{
        return DistritoResponseDTO{
                ID:          d.ID.String(),
                Name:        d.Name.String(),
                MunicipioID: d.MunicipalityID.String(),
                CreatedAt:   d.CreatedAt,
                UpdatedAt:   d.UpdatedAt,
        }
}</span>

func ToDistritoFromCreateDTO(input CreateDistritoDTO) (entities.District, error) <span class="cov0" title="0">{
        municipioID, err := uuid.Parse(input.MunicipioID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.District{}, err
        }</span>

        <span class="cov0" title="0">name, err := vos.NewDistrict(input.Name)
        if err != nil </span><span class="cov0" title="0">{
                return entities.District{}, err
        }</span>

        <span class="cov0" title="0">now := time.Now()

        return entities.District{
                ID:             uuid.New(),
                Name:           name,
                MunicipalityID: municipioID,
                CreatedAt:      now,
                UpdatedAt:      now,
        }, nil</span>
}

func ApplyUpdateToDistrito(d *entities.District, input UpdateDistritoDTO) error <span class="cov0" title="0">{
        if input.Name != "" </span><span class="cov0" title="0">{
                name, err := vos.NewDistrict(input.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">d.Name = name</span>
        }

        <span class="cov0" title="0">if input.MunicipioID != "" </span><span class="cov0" title="0">{
                municipioID, err := uuid.Parse(input.MunicipioID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">d.MunicipalityID = municipioID</span>
        }

        <span class="cov0" title="0">d.UpdatedAt = time.Now()
        return nil</span>
}

func ToDistritoResponseDTOList(list []entities.District) []DistritoResponseDTO <span class="cov0" title="0">{
        result := make([]DistritoResponseDTO, len(list))
        for i, d := range list </span><span class="cov0" title="0">{
                result[i] = ToDistritoResponseDTO(d)
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package dtos

import (
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/vos"
        "time"

        "github.com/google/uuid"
)

type CreateDocumentDTO struct {
        OwnerType string `json:"owner_type" binding:"required,oneof=employee dependent"`
        OwnerID   string `json:"owner_id" binding:"required,uuid4"`
        Type      string `json:"type" binding:"required,oneof=bi diploma contrato outro"`
        Name      string `json:"name" binding:"required,min=3,max=100"`
        FileURL   string `json:"file_url" binding:"required,url"`
}

type UpdateDocumentDTO struct {
        Type     string `json:"type" binding:"omitempty,oneof=bi diploma contrato outro"`
        Name     string `json:"name" binding:"omitempty,min=3,max=100"`
        IsActive *bool  `json:"is_active,omitempty"`
}

type DocumentResponseDTO struct {
        ID         string    `json:"id"`
        OwnerType  string    `json:"owner_type"`
        OwnerID    string    `json:"owner_id"`
        Type       string    `json:"type"`
        FileName   string    `json:"name"`
        FileURL    string    `json:"file_url"`
        IsActive   bool      `json:"is_active"`
        UploadedAt time.Time `json:"uploaded_at"`
}

func ToDocumentResponseDTO(d entities.Document) DocumentResponseDTO <span class="cov0" title="0">{
        return DocumentResponseDTO{
                ID:         d.ID.String(),
                OwnerType:  d.OwnerType.String(),
                OwnerID:    d.OwnerID.String(),
                Type:       d.Type.String(),
                FileName:   d.FileName.String(),
                FileURL:    d.FileURL.String(),
                IsActive:   d.IsActive,
                UploadedAt: d.UploadedAt,
        }
}</span>

func ToDocumentFromCreateDTO(input CreateDocumentDTO) (entities.Document, error) <span class="cov0" title="0">{
        ownerID, err := uuid.Parse(input.OwnerID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Document{}, err
        }</span>

        <span class="cov0" title="0">docType, err := vos.NewDocumentType(input.Type)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Document{}, err
        }</span>

        <span class="cov0" title="0">ownerType := vos.DocumentOwnerType(input.OwnerType)
        if !ownerType.IsValid() </span><span class="cov0" title="0">{
                return entities.Document{}, vos.ErrInvalidOwnerType
        }</span>

        <span class="cov0" title="0">docName, err := vos.NewFilename(input.Name)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Document{}, err
        }</span>

        <span class="cov0" title="0">docUrl, err := vos.NewDocumentURL(input.FileURL)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Document{}, err
        }</span>

        <span class="cov0" title="0">return entities.Document{
                ID:         uuid.New(),
                OwnerType:  ownerType,
                OwnerID:    ownerID,
                Type:       docType,
                FileName:   docName,
                FileURL:    docUrl,
                IsActive:   true,
                UploadedAt: time.Now(),
        }, nil</span>
}

func ApplyUpdateToDocument(doc *entities.Document, input UpdateDocumentDTO) error <span class="cov0" title="0">{
        if input.Type != "" </span><span class="cov0" title="0">{
                docType, err := vos.NewDocumentType(input.Type)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">doc.Type = docType</span>
        }
        <span class="cov0" title="0">if input.Name != "" </span><span class="cov0" title="0">{
                docName, err := vos.NewFilename(input.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">doc.FileName = docName</span>
        }

        <span class="cov0" title="0">if input.IsActive != nil </span><span class="cov0" title="0">{
                doc.IsActive = *input.IsActive
        }</span>

        <span class="cov0" title="0">doc.UploadedAt = time.Now()
        return nil</span>
}

func ToDocumentResponseDTOList(list []entities.Document) []DocumentResponseDTO <span class="cov0" title="0">{
        result := make([]DocumentResponseDTO, len(list))
        for i, d := range list </span><span class="cov0" title="0">{
                result[i] = ToDocumentResponseDTO(d)
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package dtos

import (
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/vos"
        "time"

        "github.com/google/uuid"
)

type CreateEducationDTO struct {
        EmployeeID   string `json:"employee_id" binding:"required,uuid4"`
        Institution  string `json:"institution" binding:"required,min=3,max=100"`
        Degree       string `json:"degree" binding:"required,min=2,max=50"`
        FieldOfStudy string `json:"field_of_study" binding:"required,uuid4"`
        StartDate    string `json:"start_date" binding:"required,datetime=2006-01-02"`
        EndDate      string `json:"end_date" binding:"required,datetime=2006-01-02"`
        Description  string `json:"description" binding:"omitempty,max=255"`
}

type UpdateEducationDTO struct {
        Institution  string `json:"institution" binding:"omitempty,min=3,max=100"`
        Degree       string `json:"degree" binding:"omitempty,min=2,max=50"`
        FieldOfStudy string `json:"field_of_study" binding:"omitempty,uuid4"`
        StartDate    string `json:"start_date" binding:"omitempty,datetime=2006-01-02"`
        EndDate      string `json:"end_date" binding:"omitempty,datetime=2006-01-02"`
        Description  string `json:"description" binding:"omitempty,max=255"`
}

type EducationResponseDTO struct {
        ID           string    `json:"id"`
        EmployeeID   string    `json:"employee_id"`
        Institution  string    `json:"institution"`
        Degree       string    `json:"degree"`
        FieldOfStudy string    `json:"field_of_study"`
        StartDate    string    `json:"start_date"`
        EndDate      string    `json:"end_date"`
        Description  string    `json:"description"`
        CreatedAt    time.Time `json:"created_at"`
        UpdatedAt    time.Time `json:"updated_at"`
}

func ToEducationResponseDTO(e entities.EducationHistory) EducationResponseDTO <span class="cov0" title="0">{
        return EducationResponseDTO{
                ID:           e.ID.String(),
                EmployeeID:   e.EmployeeID.String(),
                Institution:  e.Institution,
                Degree:       e.Degree.String(),
                FieldOfStudy: e.AreaEstudoID.String(),
                StartDate:    e.StartDate.Format("2006-01-02"),
                EndDate:      e.EndDate.Format("2006-01-02"),
                Description:  e.Description,
                CreatedAt:    e.CreatedAt,
                UpdatedAt:    e.UpdatedAt,
        }
}</span>

func ToEducationResponseDTOList(list []entities.EducationHistory) []EducationResponseDTO <span class="cov0" title="0">{
        result := make([]EducationResponseDTO, len(list))
        for i, e := range list </span><span class="cov0" title="0">{
                result[i] = ToEducationResponseDTO(e)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func ToEducationFromCreateDTO(input CreateEducationDTO) (entities.EducationHistory, error) <span class="cov0" title="0">{
        employeeID, err := uuid.Parse(input.EmployeeID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.EducationHistory{}, err
        }</span>

        <span class="cov0" title="0">fieldID, err := uuid.Parse(input.FieldOfStudy)
        if err != nil </span><span class="cov0" title="0">{
                return entities.EducationHistory{}, err
        }</span>

        <span class="cov0" title="0">degree, err := vos.NewSchoolDegree(input.Degree)
        if err != nil </span><span class="cov0" title="0">{
                return entities.EducationHistory{}, err
        }</span>

        <span class="cov0" title="0">start, err := time.Parse("2006-01-02", input.StartDate)
        if err != nil </span><span class="cov0" title="0">{
                return entities.EducationHistory{}, err
        }</span>

        <span class="cov0" title="0">end, err := time.Parse("2006-01-02", input.EndDate)
        if err != nil </span><span class="cov0" title="0">{
                return entities.EducationHistory{}, err
        }</span>

        <span class="cov0" title="0">return entities.EducationHistory{
                ID:           uuid.New(),
                EmployeeID:   employeeID,
                Institution:  input.Institution,
                Degree:       degree,
                AreaEstudoID: fieldID,
                StartDate:    start,
                EndDate:      end,
                Description:  input.Description,
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }, nil</span>
}

func ApplyUpdateToEducation(e *entities.EducationHistory, input UpdateEducationDTO) error <span class="cov0" title="0">{
        if input.Institution != "" </span><span class="cov0" title="0">{
                e.Institution = input.Institution
        }</span>
        <span class="cov0" title="0">if input.Degree != "" </span><span class="cov0" title="0">{
                deg, err := vos.NewSchoolDegree(input.Degree)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">e.Degree = deg</span>
        }
        <span class="cov0" title="0">if input.FieldOfStudy != "" </span><span class="cov0" title="0">{
                fieldId, err := uuid.Parse(input.FieldOfStudy)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">e.AreaEstudoID = fieldId</span>
        }
        <span class="cov0" title="0">if input.StartDate != "" </span><span class="cov0" title="0">{
                start, err := time.Parse("2006-01-02", input.StartDate)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">e.StartDate = start</span>
        }
        <span class="cov0" title="0">if input.EndDate != "" </span><span class="cov0" title="0">{
                end, err := time.Parse("2006-01-02", input.EndDate)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">e.EndDate = end</span>
        }
        <span class="cov0" title="0">if input.Description != "" </span><span class="cov0" title="0">{
                e.Description = input.Description
        }</span>

        <span class="cov0" title="0">e.UpdatedAt = time.Now()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package dtos

import (
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/vos"
        "time"

        "github.com/google/uuid"
)

type CreateEmployeeStatusDTO struct {
        EmployeeID string `json:"employee_id" binding:"required,uuid4"`
        Status     string `json:"status" binding:"required,oneof=active suspended terminated retired"`
        Reason     string `json:"reason" binding:"omitempty,max=255"`
        StartDate  string `json:"start_date" binding:"required,datetime=2006-01-02"`
        EndDate    string `json:"end_date" binding:"omitempty,datetime=2006-01-02"`
}

type UpdateEmployeeStatusDTO struct {
        Status    string `json:"status" binding:"omitempty,oneof=active suspended terminated retired"`
        Reason    string `json:"reason" binding:"omitempty,max=255"`
        StartDate string `json:"start_date" binding:"omitempty,datetime=2006-01-02"`
        EndDate   string `json:"end_date" binding:"omitempty,datetime=2006-01-02"`
}

type EmployeeStatusResponseDTO struct {
        ID         string    `json:"id"`
        EmployeeID string    `json:"employee_id"`
        Status     string    `json:"status"`
        Reason     string    `json:"reason"`
        StartDate  string    `json:"start_date"`
        EndDate    *string   `json:"end_date,omitempty"`
        CreatedAt  time.Time `json:"created_at"`
        UpdatedAt  time.Time `json:"updated_at"`
}

func ToEmployeeStatusResponseDTO(e entities.EmployeeStatus) EmployeeStatusResponseDTO <span class="cov0" title="0">{
        var endDate *string
        if e.EndDate != nil </span><span class="cov0" title="0">{
                formatted := e.EndDate.Format("2006-01-02")
                endDate = &amp;formatted
        }</span>

        <span class="cov0" title="0">return EmployeeStatusResponseDTO{
                ID:         e.ID.String(),
                EmployeeID: e.EmployeeID.String(),
                Status:     e.Status.String(),
                Reason:     e.Reason.String(),
                StartDate:  e.StartDate.Format("2006-01-02"),
                EndDate:    endDate,
                CreatedAt:  e.CreatedAt,
                UpdatedAt:  e.UpdatedAt,
        }</span>
}

func ToEmployeeStatusResponseDTOList(list []entities.EmployeeStatus) []EmployeeStatusResponseDTO <span class="cov0" title="0">{
        result := make([]EmployeeStatusResponseDTO, len(list))
        for i, e := range list </span><span class="cov0" title="0">{
                result[i] = ToEmployeeStatusResponseDTO(e)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func ToEmployeeStatusFromCreateDTO(input CreateEmployeeStatusDTO) (entities.EmployeeStatus, error) <span class="cov0" title="0">{
        employeeID, err := uuid.Parse(input.EmployeeID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.EmployeeStatus{}, err
        }</span>

        <span class="cov0" title="0">start, err := time.Parse("2006-01-02", input.StartDate)
        if err != nil </span><span class="cov0" title="0">{
                return entities.EmployeeStatus{}, err
        }</span>

        <span class="cov0" title="0">status, err := vos.NewEmployeeStatusValue(input.Status)
        if err != nil </span><span class="cov0" title="0">{
                return entities.EmployeeStatus{}, err
        }</span>

        <span class="cov0" title="0">reason, err := vos.NewStatusReason(input.Reason)
        if err != nil </span><span class="cov0" title="0">{
                return entities.EmployeeStatus{}, err
        }</span>

        <span class="cov0" title="0">var end *time.Time
        if input.EndDate != "" </span><span class="cov0" title="0">{
                e, err := time.Parse("2006-01-02", input.EndDate)
                if err != nil </span><span class="cov0" title="0">{
                        return entities.EmployeeStatus{}, err
                }</span>
                <span class="cov0" title="0">end = &amp;e</span>
        }

        <span class="cov0" title="0">now := time.Now()

        return entities.EmployeeStatus{
                ID:         uuid.New(),
                EmployeeID: employeeID,
                Status:     status,
                Reason:     reason,
                StartDate:  start,
                EndDate:    end,
                CreatedAt:  now,
                UpdatedAt:  now,
        }, nil</span>
}

func ApplyUpdateToEmployeeStatus(es *entities.EmployeeStatus, input UpdateEmployeeStatusDTO) error <span class="cov0" title="0">{
        if input.Status != "" </span><span class="cov0" title="0">{
                status, err := vos.NewEmployeeStatusValue(input.Status)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">es.Status = status</span>
        }

        <span class="cov0" title="0">if input.Reason != "" </span><span class="cov0" title="0">{
                reason, err := vos.NewStatusReason(input.Reason)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">es.Reason = reason</span>
        }

        <span class="cov0" title="0">if input.StartDate != "" </span><span class="cov0" title="0">{
                start, err := time.Parse("2006-01-02", input.StartDate)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">es.StartDate = start</span>
        }

        <span class="cov0" title="0">if input.EndDate != "" </span><span class="cov0" title="0">{
                end, err := time.Parse("2006-01-02", input.EndDate)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">es.EndDate = &amp;end</span>
        }

        <span class="cov0" title="0">es.UpdatedAt = time.Now()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package dtos

import (
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/vos"
        "time"

        "github.com/google/uuid"
)

type CreateEmployeeDTO struct {
        EmployeeNumber int     `json:"employee_number" binding:"required,gt=0"`
        FullName       string  `json:"full_name" binding:"required,min=3,max=100"`
        Gender         string  `json:"gender" binding:"required,oneof=masculino feminino"`
        DateOfBirth    string  `json:"date_of_birth" binding:"required,datetime=2006-01-02"`
        Nationality    string  `json:"nationality" binding:"required,min=2,max=50"`
        MaritalStatus  string  `json:"marital_status" binding:"required,oneof=single married divorced widowed"`
        PhoneNumber    string  `json:"phone_number" binding:"required,e164"`
        Email          string  `json:"email" binding:"required,email"`
        BI             string  `json:"bi" binding:"required,len=14"`
        IBAN           string  `json:"iban" binding:"required,min=10,max=34"`
        DepartmentID   string  `json:"department_id" binding:"required,uuid4"`
        PositionID     string  `json:"position_id" binding:"required,uuid4"`
        Address        string  `json:"address" binding:"required,min=5,max=200"`
        DistrictID     string  `json:"district_id" binding:"required,uuid4"`
        HiringDate     string  `json:"hiring_date" binding:"required,datetime=2006-01-02"`
        ContractType   string  `json:"contract_type" binding:"required,oneof=permanent temporary intern consultant"`
        Salary         float64 `json:"salary" binding:"required,gt=0"`
        SocialSecurity string  `json:"social_security" binding:"required,min=6,max=12"`
        SupervisorID   string  `json:"supervisor_id" binding:"omitempty,uuid4"`
}

type UpdateEmployeeDTO struct {
        MaritalStatus string  `json:"marital_status" binding:"omitempty,oneof=single married divorced widowed"`
        PhoneNumber   string  `json:"phone_number" binding:"omitempty,e164"`
        Email         string  `json:"email" binding:"omitempty,email"`
        IBAN          string  `json:"iban" binding:"omitempty,min=10,max=34"`
        DepartmentID  string  `json:"department_id" binding:"omitempty,uuid4"`
        PositionID    string  `json:"position_id" binding:"omitempty,uuid4"`
        Address       string  `json:"address" binding:"omitempty,min=5,max=200"`
        DistrictID    string  `json:"district_id" binding:"required,uuid4"`
        ContractType  string  `json:"contract_type" binding:"omitempty,oneof=permanent temporary intern consultant"`
        Salary        float64 `json:"salary" binding:"omitempty,gt=0"`
        SupervisorID  string  `json:"supervisor_id" binding:"omitempty,uuid4"`
        IsActive      *bool   `json:"is_active,omitempty"`
}

type EmployeeResponseDTO struct {
        ID             string    `json:"id"`
        EmployeeNumber int       `json:"employee_number"`
        FullName       string    `json:"full_name"`
        Gender         string    `json:"gender"`
        DateOfBirth    string    `json:"date_of_birth"`
        Nationality    string    `json:"nationality"`
        MaritalStatus  string    `json:"marital_status"`
        PhoneNumber    string    `json:"phone_number"`
        Email          string    `json:"email"`
        BI             string    `json:"bi"`
        IBAN           string    `json:"iban"`
        DepartmentID   string    `json:"department_id"`
        PositionID     string    `json:"position_id"`
        Address        string    `json:"address"`
        DistrictID     string    `json:"district_id"`
        HiringDate     string    `json:"hiring_date"`
        ContractType   string    `json:"contract_type"`
        Salary         float64   `json:"salary"`
        SocialSecurity string    `json:"social_security"`
        SupervisorID   *string   `json:"supervisor_id,omitempty"`
        IsActive       bool      `json:"is_active"`
        CreatedAt      time.Time `json:"created_at"`
        UpdatedAt      time.Time `json:"updated_at"`
}

func ToEmployeeResponseDTO(e entities.Employee) EmployeeResponseDTO <span class="cov0" title="0">{
        var supervisorID *string
        if e.SupervisorID != nil </span><span class="cov0" title="0">{
                s := e.SupervisorID.String()
                supervisorID = &amp;s
        }</span>

        <span class="cov0" title="0">return EmployeeResponseDTO{
                ID:             e.ID.String(),
                EmployeeNumber: e.EmployeeNumber,
                FullName:       e.FullName.String(),
                Gender:         e.Gender.String(),
                DateOfBirth:    e.DateOfBirth.Format("2006-01-02"),
                Nationality:    e.Nationality.String(),
                MaritalStatus:  e.MaritalStatus.String(),
                PhoneNumber:    e.PhoneNumber.String(),
                Email:          e.Email.String(),
                BI:             e.BI.String(),
                IBAN:           e.IBAN.String(),
                DepartmentID:   e.DepartmentID.String(),
                PositionID:     e.PositionID.String(),
                Address:        e.Address.String(),
                DistrictID:     e.DistrictID.String(),
                HiringDate:     e.HiringDate.Format("2006-01-02"),
                ContractType:   string(e.ContractType),
                Salary:         e.Salary.Float64(),
                SocialSecurity: e.SocialSecurity.String(),
                SupervisorID:   supervisorID,
                IsActive:       e.IsActive,
                CreatedAt:      e.CreatedAt,
                UpdatedAt:      e.UpdatedAt,
        }</span>
}

func ToEmployeeResponseDTOList(list []entities.Employee) []EmployeeResponseDTO <span class="cov0" title="0">{
        result := make([]EmployeeResponseDTO, len(list))
        for i, e := range list </span><span class="cov0" title="0">{
                result[i] = ToEmployeeResponseDTO(e)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func ToEmployeeFromCreateDTO(input CreateEmployeeDTO) (entities.Employee, error) <span class="cov0" title="0">{
        dateOfBirth, err := time.Parse("2006-01-02", input.DateOfBirth)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, err
        }</span>

        <span class="cov0" title="0">hiringDate, err := time.Parse("2006-01-02", input.HiringDate)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, err
        }</span>

        <span class="cov0" title="0">departmentID, err := uuid.Parse(input.DepartmentID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, err
        }</span>

        <span class="cov0" title="0">positionID, err := uuid.Parse(input.PositionID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, err
        }</span>

        <span class="cov0" title="0">var supervisorID *uuid.UUID
        if input.SupervisorID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(input.SupervisorID)
                if err != nil </span><span class="cov0" title="0">{
                        return entities.Employee{}, err
                }</span>
                <span class="cov0" title="0">supervisorID = &amp;id</span>
        }

        <span class="cov0" title="0">fullName, err := vos.NewPersonalName(input.FullName)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, err
        }</span>

        <span class="cov0" title="0">gender, err := vos.NewGender(input.Gender)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, err
        }</span>

        <span class="cov0" title="0">nationality, err := vos.NewNationality(input.Nationality)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, err
        }</span>

        <span class="cov0" title="0">maritalStatus, err := vos.NewMaritalStatus(input.MaritalStatus)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, err
        }</span>

        <span class="cov0" title="0">phone, err := vos.NewPhoneNumber(input.PhoneNumber)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, err
        }</span>

        <span class="cov0" title="0">email, err := vos.NewEmail(input.Email)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, err
        }</span>

        <span class="cov0" title="0">bi, err := vos.NewBI(input.BI)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, err
        }</span>

        <span class="cov0" title="0">iban, err := vos.NewIBAN(input.IBAN)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, err
        }</span>

        <span class="cov0" title="0">address, err := vos.NewAddress(input.Address)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, err
        }</span>

        <span class="cov0" title="0">district, err := uuid.Parse(input.DistrictID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, err
        }</span>

        <span class="cov0" title="0">contractType, err := vos.NewContractType(input.ContractType)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, err
        }</span>

        <span class="cov0" title="0">salary, err := vos.NewSalary(input.Salary)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, err
        }</span>

        <span class="cov0" title="0">ssn, err := vos.NewSocialSecurity(input.SocialSecurity)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, err
        }</span>

        <span class="cov0" title="0">now := time.Now()

        return entities.Employee{
                ID:             uuid.New(),
                EmployeeNumber: input.EmployeeNumber,
                FullName:       fullName,
                Gender:         gender,
                DateOfBirth:    dateOfBirth,
                Nationality:    nationality,
                MaritalStatus:  maritalStatus,
                PhoneNumber:    phone,
                Email:          email,
                BI:             bi,
                IBAN:           iban,
                DepartmentID:   departmentID,
                PositionID:     positionID,
                Address:        address,
                DistrictID:     district,
                HiringDate:     hiringDate,
                ContractType:   contractType,
                Salary:         salary,
                SocialSecurity: ssn,
                SupervisorID:   supervisorID,
                IsActive:       true,
                CreatedAt:      now,
                UpdatedAt:      now,
        }, nil</span>
}

func ApplyUpdateToEmployee(e *entities.Employee, input UpdateEmployeeDTO) error <span class="cov0" title="0">{
        if input.MaritalStatus != "" </span><span class="cov0" title="0">{
                status, err := vos.NewMaritalStatus(input.MaritalStatus)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">e.MaritalStatus = status</span>
        }

        <span class="cov0" title="0">if input.PhoneNumber != "" </span><span class="cov0" title="0">{
                phone, err := vos.NewPhoneNumber(input.PhoneNumber)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">e.PhoneNumber = phone</span>
        }

        <span class="cov0" title="0">if input.Email != "" </span><span class="cov0" title="0">{
                email, err := vos.NewEmail(input.Email)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">e.Email = email</span>
        }

        <span class="cov0" title="0">if input.IBAN != "" </span><span class="cov0" title="0">{
                iban, err := vos.NewIBAN(input.IBAN)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">e.IBAN = iban</span>
        }

        <span class="cov0" title="0">if input.DepartmentID != "" </span><span class="cov0" title="0">{
                deptID, err := uuid.Parse(input.DepartmentID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">e.DepartmentID = deptID</span>
        }

        <span class="cov0" title="0">if input.PositionID != "" </span><span class="cov0" title="0">{
                posID, err := uuid.Parse(input.PositionID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">e.PositionID = posID</span>
        }

        <span class="cov0" title="0">if input.Address != "" </span><span class="cov0" title="0">{
                address, err := vos.NewAddress(input.Address)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">e.Address = address</span>
        }

        <span class="cov0" title="0">if input.DistrictID != "" </span><span class="cov0" title="0">{
                district, err := uuid.Parse(input.DistrictID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">e.DistrictID = district</span>
        }

        <span class="cov0" title="0">if input.ContractType != "" </span><span class="cov0" title="0">{
                contract, err := vos.NewContractType(input.ContractType)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">e.ContractType = contract</span>
        }

        <span class="cov0" title="0">if input.Salary &gt; 0 </span><span class="cov0" title="0">{
                salary, err := vos.NewSalary(input.Salary)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">e.Salary = salary</span>
        }

        <span class="cov0" title="0">if input.SupervisorID != "" </span><span class="cov0" title="0">{
                supervisorID, err := uuid.Parse(input.SupervisorID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">e.SupervisorID = &amp;supervisorID</span>
        }

        <span class="cov0" title="0">if input.IsActive != nil </span><span class="cov0" title="0">{
                e.IsActive = *input.IsActive
        }</span>

        <span class="cov0" title="0">e.UpdatedAt = time.Now()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package dtos

import (
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/vos"
        "time"

        "github.com/google/uuid"
)

type CreateMunicipioDTO struct {
        Name        string `json:"name" binding:"required,min=2,max=100"`
        ProvinciaID string `json:"provincia_id" binding:"required,uuid4"`
}

type UpdateMunicipioDTO struct {
        Name        string `json:"name" binding:"omitempty,min=2,max=100"`
        ProvinciaID string `json:"provincia_id" binding:"omitempty,uuid4"`
}

type MunicipioResponseDTO struct {
        ID          string    `json:"id"`
        Name        string    `json:"name"`
        ProvinciaID string    `json:"provincia_id"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
}

type MunicipioResultDTO struct {
        ID            string    `json:"id"`
        Name          string    `json:"name"`
        ProvinciaID   string    `json:"provincia_id"`
        ProvinciaName string    `json:"provincia_name"`
        CreatedAt     time.Time `json:"created_at"`
        UpdatedAt     time.Time `json:"updated_at"`
}

func ToMunicipioResponseDTO(m entities.Municipality) MunicipioResponseDTO <span class="cov0" title="0">{
        return MunicipioResponseDTO{
                ID:          m.ID.String(),
                Name:        m.Name.String(),
                ProvinciaID: m.ProvinceID.String(),
                CreatedAt:   m.CreatedAt,
                UpdatedAt:   m.UpdatedAt,
        }
}</span>

func ToMunicipioResponseDTOList(list []entities.Municipality) []MunicipioResponseDTO <span class="cov0" title="0">{
        result := make([]MunicipioResponseDTO, len(list))
        for i, m := range list </span><span class="cov0" title="0">{
                result[i] = ToMunicipioResponseDTO(m)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func ToMunicipioFromCreateDTO(input CreateMunicipioDTO) (entities.Municipality, error) <span class="cov0" title="0">{
        provinciaID, err := uuid.Parse(input.ProvinciaID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Municipality{}, err
        }</span>

        <span class="cov0" title="0">name, err := vos.NewMunicipality(input.Name)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Municipality{}, err
        }</span>

        <span class="cov0" title="0">now := time.Now()

        return entities.Municipality{
                ID:         uuid.New(),
                Name:       name,
                ProvinceID: provinciaID,
                CreatedAt:  now,
                UpdatedAt:  now,
        }, nil</span>
}

func ApplyUpdateToMunicipio(m *entities.Municipality, input UpdateMunicipioDTO) error <span class="cov0" title="0">{
        if input.Name != "" </span><span class="cov0" title="0">{
                name, err := vos.NewMunicipality(input.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">m.Name = name</span>
        }

        <span class="cov0" title="0">if input.ProvinciaID != "" </span><span class="cov0" title="0">{
                provinciaID, err := uuid.Parse(input.ProvinciaID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">m.ProvinceID = provinciaID</span>
        }

        <span class="cov0" title="0">m.UpdatedAt = time.Now()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package dtos

import (
        "rhapp/internal/domain/entities"
        "time"

        "github.com/google/uuid"
)

type CreatePositionDTO struct {
        Name         string `json:"name" binding:"required,min=2,max=100"`
        DepartmentID string `json:"department_id" binding:"required,uuid4"`
}

type UpdatePositionDTO struct {
        Name         string `json:"name" binding:"omitempty,min=2,max=100"`
        DepartmentID string `json:"department_id" binding:"omitempty,uuid4"`
}

type PositionResponseDTO struct {
        ID           string    `json:"id"`
        Name         string    `json:"name"`
        DepartmentID string    `json:"department_id"`
        CreatedAt    time.Time `json:"created_at"`
        UpdatedAt    time.Time `json:"updated_at"`
}

type PositionResultDTO struct {
        ID             uuid.UUID `json:"id"`
        Name           string    `json:"name"`
        DepartmentID   uuid.UUID `json:"department_id"`
        DepartmentName string    `json:"department_name"`
        CreatedAt      time.Time `json:"created_at"`
        UpdatedAt      time.Time `json:"updated_at"`
}

func ToPositionResponseDTO(p entities.Position) PositionResponseDTO <span class="cov0" title="0">{
        return PositionResponseDTO{
                ID:           p.ID.String(),
                Name:         p.Name,
                DepartmentID: p.DepartmentID.String(),
                CreatedAt:    p.CreatedAt,
                UpdatedAt:    p.UpdatedAt,
        }
}</span>

func ToPositionResponseDTOList(list []entities.Position) []PositionResponseDTO <span class="cov0" title="0">{
        result := make([]PositionResponseDTO, len(list))
        for i, p := range list </span><span class="cov0" title="0">{
                result[i] = ToPositionResponseDTO(p)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func ToPositionFromCreateDTO(input CreatePositionDTO) (entities.Position, error) <span class="cov0" title="0">{
        deptID, err := uuid.Parse(input.DepartmentID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Position{}, err
        }</span>

        <span class="cov0" title="0">now := time.Now()

        return entities.Position{
                ID:           uuid.New(),
                Name:         input.Name,
                DepartmentID: deptID,
                CreatedAt:    now,
                UpdatedAt:    now,
        }, nil</span>
}

func ApplyUpdateToPosition(p *entities.Position, input UpdatePositionDTO) error <span class="cov0" title="0">{
        if input.Name != "" </span><span class="cov0" title="0">{
                p.Name = input.Name
        }</span>

        <span class="cov0" title="0">if input.DepartmentID != "" </span><span class="cov0" title="0">{
                deptID, err := uuid.Parse(input.DepartmentID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">p.DepartmentID = deptID</span>
        }

        <span class="cov0" title="0">p.UpdatedAt = time.Now()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package dtos

import (
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/vos"
        "time"

        "github.com/google/uuid"
)

type CreateProvinceDTO struct {
        Nome string `json:"nome" binding:"required,min=3,max=100"`
}

// CreateProvinceDoc is used ONLY for Swagger schema generation.
// It intentionally has NO validator tags, so Swagger won't enforce minLength.
type CreateProvinceDoc struct {
        // Nome da Província
        // example: Luanda
        Nome string `json:"nome" example:"Luanda"`
}

type UpdateProvinceDTO struct {
        Nome string `json:"nome" binding:"required,min=3,max=100"`
}

type ProvinceResponseDTO struct {
        ID        string    `json:"id"`
        Nome      string    `json:"nome"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

func ToProvinceFromCreateDTO(input CreateProvinceDTO) (entities.Province, error) <span class="cov8" title="1">{
        nome := vos.NewProvince(input.Nome)

        now := time.Now()

        return entities.Province{
                ID:        uuid.New(),
                Nome:      nome,
                CreatedAt: now,
                UpdatedAt: now,
        }, nil
}</span>

func ApplyUpdateToProvince(p *entities.Province, input UpdateProvinceDTO) error <span class="cov8" title="1">{
        if input.Nome != "" </span><span class="cov8" title="1">{
                nome := vos.NewProvince(input.Nome)
                p.Nome = nome
        }</span>

        <span class="cov8" title="1">p.UpdatedAt = time.Now()
        return nil</span>
}

func ToProvinceResponseDTO(p entities.Province) ProvinceResponseDTO <span class="cov8" title="1">{
        return ProvinceResponseDTO{
                ID:        p.ID.String(),
                Nome:      p.Nome.String(),
                CreatedAt: p.CreatedAt,
                UpdatedAt: p.UpdatedAt,
        }
}</span>

func ToProvinceResponseDTOList(list []entities.Province) []ProvinceResponseDTO <span class="cov8" title="1">{
        result := make([]ProvinceResponseDTO, len(list))
        for i, p := range list </span><span class="cov8" title="1">{
                result[i] = ToProvinceResponseDTO(p)
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package dtos

import (
        "rhapp/internal/domain/entities"
        "time"

        "github.com/google/uuid"
)

type CreateSupervisorDTO struct {
        EmployeeID   string  `json:"employee_id" binding:"required,uuid4"`
        SupervisorID *string `json:"supervisor_id,omitempty" binding:"omitempty,uuid4"` // agora opcional
        StartDate    string  `json:"start_date" binding:"required,datetime=2006-01-02"`
        EndDate      string  `json:"end_date" binding:"omitempty,datetime=2006-01-02"`
}

type UpdateSupervisorDTO struct {
        SupervisorID *string `json:"supervisor_id,omitempty" binding:"omitempty,uuid4"`
        StartDate    string  `json:"start_date" binding:"omitempty,datetime=2006-01-02"`
        EndDate      string  `json:"end_date" binding:"omitempty,datetime=2006-01-02"`
}

type SupervisorResponseDTO struct {
        ID           string    `json:"id"`
        EmployeeID   string    `json:"employee_id"`
        SupervisorID *string   `json:"supervisor_id,omitempty"` // opcional
        StartDate    string    `json:"start_date"`
        EndDate      *string   `json:"end_date,omitempty"`
        CreatedAt    time.Time `json:"created_at"`
        UpdatedAt    time.Time `json:"updated_at"`
}

func ToSupervisorResponseDTO(s entities.SupervisorHistory) SupervisorResponseDTO <span class="cov0" title="0">{
        var supervisorID *string
        if s.SupervisorID != nil </span><span class="cov0" title="0">{
                id := s.SupervisorID.String()
                supervisorID = &amp;id
        }</span>

        <span class="cov0" title="0">var endDate *string
        if s.EndDate != nil </span><span class="cov0" title="0">{
                formatted := s.EndDate.Format("2006-01-02")
                endDate = &amp;formatted
        }</span>

        <span class="cov0" title="0">return SupervisorResponseDTO{
                ID:           s.ID.String(),
                EmployeeID:   s.EmployeeID.String(),
                SupervisorID: supervisorID,
                StartDate:    s.StartDate.Format("2006-01-02"),
                EndDate:      endDate,
                CreatedAt:    s.CreatedAt,
                UpdatedAt:    s.UpdatedAt,
        }</span>
}

func ToSupervisorFromCreateDTO(input CreateSupervisorDTO) (entities.SupervisorHistory, error) <span class="cov0" title="0">{
        employeeID, err := uuid.Parse(input.EmployeeID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.SupervisorHistory{}, err
        }</span>

        <span class="cov0" title="0">var supervisorID *uuid.UUID
        if input.SupervisorID != nil </span><span class="cov0" title="0">{
                sID, err := uuid.Parse(*input.SupervisorID)
                if err != nil </span><span class="cov0" title="0">{
                        return entities.SupervisorHistory{}, err
                }</span>
                <span class="cov0" title="0">supervisorID = &amp;sID</span>
        }

        <span class="cov0" title="0">startDate, err := time.Parse("2006-01-02", input.StartDate)
        if err != nil </span><span class="cov0" title="0">{
                return entities.SupervisorHistory{}, err
        }</span>

        <span class="cov0" title="0">var endDate *time.Time
        if input.EndDate != "" </span><span class="cov0" title="0">{
                ed, err := time.Parse("2006-01-02", input.EndDate)
                if err != nil </span><span class="cov0" title="0">{
                        return entities.SupervisorHistory{}, err
                }</span>
                <span class="cov0" title="0">endDate = &amp;ed</span>
        }

        <span class="cov0" title="0">now := time.Now()

        return entities.SupervisorHistory{
                ID:           uuid.New(),
                EmployeeID:   employeeID,
                SupervisorID: supervisorID,
                StartDate:    startDate,
                EndDate:      endDate,
                CreatedAt:    now,
                UpdatedAt:    now,
        }, nil</span>
}

func ApplyUpdateToSupervisor(s *entities.SupervisorHistory, input UpdateSupervisorDTO) error <span class="cov0" title="0">{
        if input.SupervisorID != nil </span><span class="cov0" title="0">{
                sID, err := uuid.Parse(*input.SupervisorID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">s.SupervisorID = &amp;sID</span>
        }
        <span class="cov0" title="0">if input.StartDate != "" </span><span class="cov0" title="0">{
                startDate, err := time.Parse("2006-01-02", input.StartDate)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">s.StartDate = startDate</span>
        }
        <span class="cov0" title="0">if input.EndDate != "" </span><span class="cov0" title="0">{
                endDate, err := time.Parse("2006-01-02", input.EndDate)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">s.EndDate = &amp;endDate</span>
        }

        <span class="cov0" title="0">s.UpdatedAt = time.Now()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package dtos

import (
        "rhapp/internal/domain/entities"
        "time"

        "github.com/google/uuid"
)

type CreateWorkDTO struct {
        EmployeeID       string `json:"employee_id" binding:"required,uuid4"`
        Company          string `json:"company" binding:"required,min=2,max=100"`
        Position         string `json:"position" binding:"required,min=2,max=100"`
        StartDate        string `json:"start_date" binding:"required,datetime=2006-01-02"`
        EndDate          string `json:"end_date" binding:"omitempty,datetime=2006-01-02"`
        Responsibilities string `json:"responsibilities" binding:"omitempty,max=500"`
}

type UpdateWorkDTO struct {
        Company          string `json:"company" binding:"omitempty,min=2,max=100"`
        Position         string `json:"position" binding:"omitempty,min=2,max=100"`
        StartDate        string `json:"start_date" binding:"omitempty,datetime=2006-01-02"`
        EndDate          string `json:"end_date" binding:"omitempty,datetime=2006-01-02"`
        Responsibilities string `json:"responsibilities" binding:"omitempty,max=500"`
}

type WorkResponseDTO struct {
        ID               string    `json:"id"`
        EmployeeID       string    `json:"employee_id"`
        Company          string    `json:"company"`
        Position         string    `json:"position"`
        StartDate        string    `json:"start_date"`
        EndDate          *string   `json:"end_date,omitempty"`
        Responsibilities string    `json:"responsibilities"`
        CreatedAt        time.Time `json:"created_at"`
        UpdatedAt        time.Time `json:"updated_at"`
}

func ToWorkResponseDTO(w entities.WorkHistory) WorkResponseDTO <span class="cov0" title="0">{
        var endDate *string
        if !w.EndDate.IsZero() </span><span class="cov0" title="0">{
                formatted := w.EndDate.Format("2006-01-02")
                endDate = &amp;formatted
        }</span>

        <span class="cov0" title="0">return WorkResponseDTO{
                ID:               w.ID.String(),
                EmployeeID:       w.EmployeeID.String(),
                Company:          w.Company,
                Position:         w.Position,
                StartDate:        w.StartDate.Format("2006-01-02"),
                EndDate:          endDate,
                Responsibilities: w.Responsibilities,
                CreatedAt:        w.CreatedAt,
                UpdatedAt:        w.UpdatedAt,
        }</span>
}

func ToWorkResponseDTOList(list []entities.WorkHistory) []WorkResponseDTO <span class="cov0" title="0">{
        result := make([]WorkResponseDTO, len(list))
        for i, w := range list </span><span class="cov0" title="0">{
                result[i] = ToWorkResponseDTO(w)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func ToWorkFromCreateDTO(input CreateWorkDTO) (entities.WorkHistory, error) <span class="cov0" title="0">{
        employeeID, err := uuid.Parse(input.EmployeeID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.WorkHistory{}, err
        }</span>

        <span class="cov0" title="0">company := input.Company

        position := input.Position

        startDate, err := time.Parse("2006-01-02", input.StartDate)
        if err != nil </span><span class="cov0" title="0">{
                return entities.WorkHistory{}, err
        }</span>

        <span class="cov0" title="0">var endDate *time.Time
        if input.EndDate != "" </span><span class="cov0" title="0">{
                ed, err := time.Parse("2006-01-02", input.EndDate)
                if err != nil </span><span class="cov0" title="0">{
                        return entities.WorkHistory{}, err
                }</span>
                <span class="cov0" title="0">endDate = &amp;ed</span>
        }

        <span class="cov0" title="0">now := time.Now()

        return entities.WorkHistory{
                ID:               uuid.New(),
                EmployeeID:       employeeID,
                Company:          company,
                Position:         position,
                StartDate:        startDate,
                EndDate:          *endDate,
                Responsibilities: input.Responsibilities,
                CreatedAt:        now,
                UpdatedAt:        now,
        }, nil</span>
}

func ApplyUpdateToWork(w *entities.WorkHistory, input UpdateWorkDTO) error <span class="cov0" title="0">{
        if input.Company != "" </span><span class="cov0" title="0">{
                w.Company = input.Company
        }</span>

        <span class="cov0" title="0">if input.Position != "" </span><span class="cov0" title="0">{
                w.Position = input.Position
        }</span>

        <span class="cov0" title="0">if input.StartDate != "" </span><span class="cov0" title="0">{
                start, err := time.Parse("2006-01-02", input.StartDate)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">w.StartDate = start</span>
        }

        <span class="cov0" title="0">if input.EndDate != "" </span><span class="cov0" title="0">{
                end, err := time.Parse("2006-01-02", input.EndDate)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">w.EndDate = end</span>
        }

        <span class="cov0" title="0">if input.Responsibilities != "" </span><span class="cov0" title="0">{
                w.Responsibilities = input.Responsibilities
        }</span>

        <span class="cov0" title="0">w.UpdatedAt = time.Now()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package entities

import (
        "errors"
        "rhapp/internal/domain/vos"
        "time"

        "github.com/google/uuid"
)

type EducationHistory struct {
        ID           uuid.UUID
        EmployeeID   uuid.UUID
        Institution  string
        Degree       vos.SchoolDegree
        AreaEstudoID uuid.UUID
        StartDate    time.Time
        EndDate      time.Time
        Description  string
        IsCurrent    bool
        CreatedAt    time.Time
        UpdatedAt    time.Time
}

// Validação de consistência de datas
func (s *EducationHistory) Validate() error <span class="cov0" title="0">{
        if s.EndDate.Before(s.StartDate) </span><span class="cov0" title="0">{
                return errors.New("data de término não pode ser anterior à data de início")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package entities

import (
        "errors"
        "rhapp/internal/domain/vos"
        "time"

        "github.com/google/uuid"
)

type Employee struct {
        ID             uuid.UUID
        EmployeeNumber int
        FullName       vos.PersonalName
        Gender         vos.Gender
        DateOfBirth    time.Time
        Nationality    vos.Nationality
        MaritalStatus  vos.MaritalStatus
        PhoneNumber    vos.PhoneNumber
        Email          vos.Email
        BI             vos.BI
        IBAN           vos.IBAN
        DepartmentID   uuid.UUID
        PositionID     uuid.UUID
        Address        vos.Address
        DistrictID     uuid.UUID
        HiringDate     time.Time
        ContractType   vos.ContractType
        Salary         vos.Salary
        SocialSecurity vos.SocialSecurity

        // SupervisorID agora é computado via SupervisorHistory (não persistido diretamente)
        SupervisorID *uuid.UUID `json:"supervisor_id,omitempty"`

        IsActive  bool
        CreatedAt time.Time
        UpdatedAt time.Time
}

// Validação de consistência de datas
func (s *EmployeeStatus) Validate() error <span class="cov0" title="0">{
        if s.EndDate != nil &amp;&amp; s.EndDate.Before(s.StartDate) </span><span class="cov0" title="0">{
                return errors.New("data de término não pode ser anterior à data de início")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package entities

import (
        "errors"
        "time"

        "github.com/google/uuid"
)

type SupervisorHistory struct {
        ID           uuid.UUID
        EmployeeID   uuid.UUID
        SupervisorID *uuid.UUID // permite null (ex: sem chefe)
        StartDate    time.Time
        EndDate      *time.Time
        CreatedAt    time.Time
        UpdatedAt    time.Time
}

// Validação de consistência de datas
func (s *SupervisorHistory) Validate() error <span class="cov0" title="0">{
        if s.EndDate != nil &amp;&amp; s.EndDate.Before(s.StartDate) </span><span class="cov0" title="0">{
                return errors.New("data de término não pode ser anterior à data de início")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package entities

import (
        "errors"
        "time"

        "github.com/google/uuid"
)

type WorkHistory struct {
        ID               uuid.UUID
        EmployeeID       uuid.UUID
        Company          string
        Position         string
        StartDate        time.Time
        EndDate          time.Time
        Responsibilities string
        IsCurrent        bool
        CreatedAt        time.Time
        UpdatedAt        time.Time
}

// Validação de consistência de datas
func (s *WorkHistory) Validate() error <span class="cov0" title="0">{
        if s.EndDate.Before(s.StartDate) </span><span class="cov0" title="0">{
                return errors.New("data de término não pode ser anterior à data de início")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package vos

import (
        "errors"
        "strings"
)

type Address struct {
        value string
}

func NewAddress(input string) (Address, error) <span class="cov0" title="0">{
        val := strings.TrimSpace(input)
        if len(val) &lt; 5 </span><span class="cov0" title="0">{
                return Address{}, errors.New("endereço muito curto")
        }</span>
        <span class="cov0" title="0">if len(val) &gt; 150 </span><span class="cov0" title="0">{
                return Address{}, errors.New("endereço muito longo (máx. 150 caracteres)")
        }</span>
        <span class="cov0" title="0">return Address{val}, nil</span>
}

func (a Address) String() string <span class="cov0" title="0">{
        return a.value
}</span>

func MustNewAddress(value string) Address <span class="cov0" title="0">{
        addr, err := NewAddress(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return addr</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package vos

import (
        "errors"
        "regexp"
)

type BI struct {
        value string
}

var biRegex = regexp.MustCompile(`^\d{9}[A-Z]{2}\d{3}$`)

func NewBI(bi string) (BI, error) <span class="cov0" title="0">{
        if !biRegex.MatchString(bi) </span><span class="cov0" title="0">{
                return BI{}, errors.New("BI inválido: deve conter 9 dígitos + 2 letras + 3 dígitos (ex: 123456789LA045)")
        }</span>
        <span class="cov0" title="0">return BI{bi}, nil</span>
}

func (b BI) String() string <span class="cov0" title="0">{
        return b.value
}</span>

func MustNewBI(value string) BI <span class="cov0" title="0">{
        bi, err := NewBI(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return bi</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package vos

import (
        "errors"
        "time"
)

// BirthDate - VO para datas de nascimento

type BirthDate struct {
        value time.Time
}

func NewBirthDate(dateStr string) (BirthDate, error) <span class="cov0" title="0">{
        t, err := time.Parse("2006-01-02", dateStr)
        if err != nil </span><span class="cov0" title="0">{
                return BirthDate{}, errors.New("data de nascimento inválida. Use o formato YYYY-MM-DD")
        }</span>
        <span class="cov0" title="0">if t.After(time.Now()) </span><span class="cov0" title="0">{
                return BirthDate{}, errors.New("data de nascimento não pode ser futura")
        }</span>
        <span class="cov0" title="0">return BirthDate{value: t}, nil</span>
}

func (b BirthDate) String() string <span class="cov0" title="0">{
        return b.value.Format("2006-01-02")
}</span>

func (b BirthDate) Time() time.Time <span class="cov0" title="0">{
        return b.value
}</span>

func (b BirthDate) IsAdult() bool <span class="cov0" title="0">{
        return time.Now().After(b.value.AddDate(18, 0, 0))
}</span>

func MustNewBirthDate(value string) BirthDate <span class="cov0" title="0">{
        ret, err := NewBirthDate(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package vos

import (
        "errors"
        "strings"
)

type ContractType string

var validContracts = map[string]bool{
        "permanent":  true,
        "temporary":  true,
        "intern":     true,
        "consultant": true,
}

func NewContractType(ct string) (ContractType, error) <span class="cov0" title="0">{
        ct = strings.TrimSpace(ct)
        if !validContracts[ct] </span><span class="cov0" title="0">{
                return "", errors.New("tipo de contrato inválido")
        }</span>
        <span class="cov0" title="0">return ContractType(ct), nil</span>
}

func (c ContractType) String() string <span class="cov0" title="0">{
        return string(c)
}</span>

func MustNewContractType(value string) ContractType <span class="cov0" title="0">{
        ret, err := NewContractType(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package vos

import (
        "errors"
        "strings"
)

type District struct {
        value string
}

func NewDistrict(input string) (District, error) <span class="cov0" title="0">{
        val := strings.TrimSpace((strings.ToLower(input)))
        if len(val) &lt; 3 </span><span class="cov0" title="0">{
                return District{}, errors.New("nome de distrito (ou comuna) muito curto")
        }</span>
        <span class="cov0" title="0">if len(val) &gt; 60 </span><span class="cov0" title="0">{
                return District{}, errors.New("nome de distrito (ou comuna) muito longo")
        }</span>
        <span class="cov0" title="0">return District{val}, nil</span>
}

func (d District) String() string <span class="cov0" title="0">{
        return d.value
}</span>

func MustNewDistrict(value string) District <span class="cov0" title="0">{
        ret, err := NewDistrict(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package vos

import (
        "errors"
)

type DocumentOwnerType string

var ErrInvalidOwnerType = errors.New("invalid document owner type")

const (
        DocumentOwnerEmployee  DocumentOwnerType = "employee"
        DocumentOwnerDependent DocumentOwnerType = "dependent"
)

func (t DocumentOwnerType) IsValid() bool <span class="cov0" title="0">{
        switch t </span>{
        case DocumentOwnerEmployee, DocumentOwnerDependent:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (d DocumentOwnerType) String() string <span class="cov0" title="0">{
        return string(d)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package vos

import (
        "errors"
        "strings"
)

type DocumentType struct {
        value string
}

var allowedTypes = map[string]bool{
        "BI":       true,
        "Contrato": true,
        "Diploma":  true,
        "Foto":     true,
        "Outro":    true,
}

func NewDocumentType(value string) (DocumentType, error) <span class="cov0" title="0">{
        v := strings.TrimSpace(value)
        if !allowedTypes[v] </span><span class="cov0" title="0">{
                return DocumentType{}, errors.New("tipo de documento inválido")
        }</span>
        <span class="cov0" title="0">return DocumentType{v}, nil</span>
}

func (d DocumentType) String() string <span class="cov0" title="0">{
        return string(d.value)
}</span>

func MustNewDocumentType(value string) DocumentType <span class="cov0" title="0">{
        ret, err := NewDocumentType(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package vos

import (
        "errors"
        "net/url"
        "strings"
)

type DocumentURL struct {
        value string
}

func NewDocumentURL(value string) (DocumentURL, error) <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(value)
        u, err := url.ParseRequestURI(trimmed)
        if err != nil </span><span class="cov0" title="0">{
                return DocumentURL{}, errors.New("URL de documento inválida")
        }</span>
        <span class="cov0" title="0">return DocumentURL{u.String()}, nil</span>
}

func (d DocumentURL) String() string <span class="cov0" title="0">{
        return string(d.value)
}</span>

func MustNewDocumentURL(value string) DocumentURL <span class="cov0" title="0">{
        ret, err := NewDocumentURL(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package vos

import (
        "errors"
        "regexp"
)

type Email struct {
        value string
}

func NewEmail(email string) (Email, error) <span class="cov0" title="0">{
        if !regexp.MustCompile(`^[\w\.-]+@[\w\.-]+\.\w+$`).MatchString(email) </span><span class="cov0" title="0">{
                return Email{}, errors.New("email inválido")
        }</span>
        <span class="cov0" title="0">return Email{email}, nil</span>
}

func (e Email) String() string <span class="cov0" title="0">{
        return e.value
}</span>

func MustNewEmail(value string) Email <span class="cov0" title="0">{
        ret, err := NewEmail(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package vos

import (
        "errors"
        "strings"
)

type EmployeeStatus struct {
        value string
}

var allowedEmployeeStatus = map[string]bool{
        "ativo":         true,
        "suspenso":      true,
        "reformado":     true,
        "convalescente": true,
}

func NewEmployeeStatusValue(input string) (EmployeeStatus, error) <span class="cov0" title="0">{
        normalized := strings.ToLower(strings.TrimSpace(input))
        if !allowedEmployeeStatus[normalized] </span><span class="cov0" title="0">{
                return EmployeeStatus{}, errors.New("status inválido (valores permitidos: Ativo, Suspenso, Reformado, Convalescente)")
        }</span>
        <span class="cov0" title="0">return EmployeeStatus{normalized}, nil</span>
}

func (s EmployeeStatus) String() string <span class="cov0" title="0">{
        return s.value
}</span>

func MustNewEmployeeStatusValue(value string) EmployeeStatus <span class="cov0" title="0">{
        ret, err := NewEmployeeStatusValue(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package vos

import (
        "errors"
        "strings"
)

type StatusReason struct {
        value string
}

// Lista de motivos permitidos (opcional, ou apenas validação por tamanho e conteúdo)
var allowedReasons = map[string]bool{
        "processo disciplinar": true,
        "licença médica":       true,
        "aposentadoria":        true,
        "licença maternidade":  true,
        "licença paternidade":  true,
        "falecimento familiar": true,
        "outros":               true,
}

func NewStatusReason(input string) (StatusReason, error) <span class="cov0" title="0">{

        normalized := strings.ToLower(strings.TrimSpace(input))
        if !allowedReasons[normalized] </span><span class="cov0" title="0">{
                return StatusReason{}, errors.New("motivo inválido")
        }</span>

        <span class="cov0" title="0">if len(normalized) &lt; 3 </span><span class="cov0" title="0">{
                return StatusReason{}, errors.New("o motivo deve ter ao menos 3 caracteres")
        }</span>

        <span class="cov0" title="0">if len(normalized) &gt; 100 </span><span class="cov0" title="0">{
                return StatusReason{}, errors.New("o motivo não pode exceder 100 caracteres")
        }</span>

        <span class="cov0" title="0">return StatusReason{normalized}, nil</span>

}

func (r StatusReason) String() string <span class="cov0" title="0">{
        return r.value
}</span>

func MustNewStatusReason(value string) StatusReason <span class="cov0" title="0">{
        ret, err := NewStatusReason(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package vos

import (
        "errors"
        "strings"
)

type FileExtension struct {
        value string
}

var allowedExtensions = map[string]bool{
        "pdf":  true,
        "jpg":  true,
        "jpeg": true,
        "png":  true,
        "docx": true,
        "doc":  true,
}

func NewFileExtension(ext string) (FileExtension, error) <span class="cov0" title="0">{
        e := strings.ToLower(strings.TrimSpace(ext))
        if !allowedExtensions[e] </span><span class="cov0" title="0">{
                return FileExtension{}, errors.New("extensão de ficheiro não suportada")
        }</span>
        <span class="cov0" title="0">return FileExtension{e}, nil</span>
}

func (e FileExtension) String() string <span class="cov0" title="0">{
        return string(e.value)
}</span>

func MustNewFileExtension(value string) FileExtension <span class="cov0" title="0">{
        ret, err := NewFileExtension(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package vos

import (
        "errors"
        "regexp"
        "strings"
)

type Filename struct {
        value string
}

func NewFilename(value string) (Filename, error) <span class="cov0" title="0">{
        value = strings.TrimSpace(value)
        if value == "" </span><span class="cov0" title="0">{
                return Filename{}, errors.New("nome do ficheiro é obrigatório")
        }</span>
        <span class="cov0" title="0">if len(value) &gt; 255 </span><span class="cov0" title="0">{
                return Filename{}, errors.New("nome do ficheiro é muito longo")
        }</span>
        <span class="cov0" title="0">if !regexp.MustCompile(`^[\w\-. ]+$`).MatchString(value) </span><span class="cov0" title="0">{
                return Filename{}, errors.New("nome do ficheiro inválido (caracteres não permitidos)")
        }</span>
        <span class="cov0" title="0">return Filename{value}, nil</span>
}

func (f Filename) String() string <span class="cov0" title="0">{
        return string(f.value)
}</span>

func MustNewFilename(value string) Filename <span class="cov0" title="0">{
        ret, err := NewFilename(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package vos

import (
        "errors"
        "strings"
)

// Gender - VO para gênero

type Gender struct {
        value string
}

var allowedGenders = map[string]bool{
        "masculino": true,
        "feminino":  true,
}

func NewGender(genderStr string) (Gender, error) <span class="cov0" title="0">{
        genderTrimmed := strings.ToLower(strings.TrimSpace(genderStr))

        if !allowedGenders[genderTrimmed] </span><span class="cov0" title="0">{
                return Gender{}, errors.New("gênero deve ser masculino ou feminino")
        }</span>

        <span class="cov0" title="0">return Gender{genderTrimmed}, nil</span>
}

func (f Gender) String() string <span class="cov0" title="0">{
        return string(f.value)
}</span>

func MustNewGender(value string) Gender <span class="cov0" title="0">{
        ret, err := NewGender(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package vos

import (
        "errors"
        "regexp"
        "strings"
)

type IBAN struct {
        value string
}

var ibanRegex = regexp.MustCompile(`^AO06\d{21}$`)

func NewIBAN(iban string) (IBAN, error) <span class="cov0" title="0">{
        iban = strings.ToUpper(strings.TrimSpace(iban))
        if !ibanRegex.MatchString(iban) </span><span class="cov0" title="0">{
                return IBAN{}, errors.New("IBAN inválido: deve começar com AO06 e ter 25 caracteres no total")
        }</span>
        <span class="cov0" title="0">return IBAN{iban}, nil</span>
}

func (i IBAN) String() string <span class="cov0" title="0">{
        return i.value
}</span>

func MustNewIBAN(value string) IBAN <span class="cov0" title="0">{
        ret, err := NewIBAN(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package vos

import (
        "errors"
        "strings"
)

// Gender - VO para gênero

type MaritalStatus struct {
        value string
}

var allowedMaritalStatus = map[string]bool{
        "single":  true,
        "married": true,
}

func NewMaritalStatus(maritalStr string) (MaritalStatus, error) <span class="cov0" title="0">{
        v := strings.ToLower(strings.TrimSpace(maritalStr))

        if !allowedMaritalStatus[v] </span><span class="cov0" title="0">{
                return MaritalStatus{}, errors.New("gênero deve ser Masculino ou Feminino")
        }</span>

        <span class="cov0" title="0">return MaritalStatus{v}, nil</span>

}

func (f MaritalStatus) String() string <span class="cov0" title="0">{
        return string(f.value)
}</span>

func MustNewMaritalStatus(value string) MaritalStatus <span class="cov0" title="0">{
        ret, err := NewMaritalStatus(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package vos

import (
        "errors"
        "strings"
)

type Municipality struct {
        value string
}

func NewMunicipality(input string) (Municipality, error) <span class="cov0" title="0">{
        val := strings.TrimSpace((strings.ToLower(input)))
        if len(val) &lt; 3 </span><span class="cov0" title="0">{
                return Municipality{}, errors.New("nome de município muito curto")
        }</span>
        <span class="cov0" title="0">if len(val) &gt; 60 </span><span class="cov0" title="0">{
                return Municipality{}, errors.New("nome de município muito longo")
        }</span>
        <span class="cov0" title="0">return Municipality{val}, nil</span>
}

func (m Municipality) String() string <span class="cov0" title="0">{
        return m.value
}</span>

func MustNewMunicipality(value string) Municipality <span class="cov0" title="0">{
        ret, err := NewMunicipality(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package vos

import (
        "errors"
        "regexp"
        "strings"
)

type Nationality struct {
        value string
}

var nationalityRegex = regexp.MustCompile(`^[A-Za-zÀ-ÿ\s\-]{3,}$`)

func NewNationality(input string) (Nationality, error) <span class="cov0" title="0">{
        input = strings.TrimSpace(input)
        if !nationalityRegex.MatchString(input) </span><span class="cov0" title="0">{
                return Nationality{}, errors.New("nacionalidade inválida: use apenas letras e mínimo de 3 caracteres")
        }</span>
        <span class="cov0" title="0">return Nationality{input}, nil</span>
}

func (n Nationality) String() string <span class="cov0" title="0">{
        return n.value
}</span>

func MustNewNationality(value string) Nationality <span class="cov0" title="0">{
        nat, err := NewNationality(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return nat</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package vos

import (
        "errors"
        "regexp"
        "strings"
)

type PersonalName struct {
        value string
}

func NewPersonalName(input string) (PersonalName, error) <span class="cov0" title="0">{
        nameTrimmed := strings.TrimSpace(input)
        if nameTrimmed == "" </span><span class="cov0" title="0">{
                return PersonalName{}, errors.New("nome completo obrigatório")
        }</span>
        <span class="cov0" title="0">if !regexp.MustCompile(`^[A-Za-z\sÀ-ü]+$`).MatchString(nameTrimmed) </span><span class="cov0" title="0">{
                return PersonalName{}, errors.New("nome completo deve conter apenas letras")
        }</span>
        <span class="cov0" title="0">return PersonalName{nameTrimmed}, nil</span>
}

func (f PersonalName) String() string <span class="cov0" title="0">{
        return string(f.value)
}</span>

func MustNewPersonalName(value string) PersonalName <span class="cov0" title="0">{
        ret, err := NewPersonalName(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package vos

import (
        "errors"
        "regexp"
)

type PhoneNumber struct {
        value string
}

func NewPhoneNumber(number string) (PhoneNumber, error) <span class="cov0" title="0">{
        if !regexp.MustCompile(`^\+?244\d{9}$`).MatchString(number) </span><span class="cov0" title="0">{
                return PhoneNumber{}, errors.New("telefone inválido: deve conter indicativo 244 e 9 dígitos")
        }</span>
        <span class="cov0" title="0">return PhoneNumber{number}, nil</span>
}

func (p PhoneNumber) String() string <span class="cov0" title="0">{
        return p.value
}</span>

func MustNewPhoneNumber(value string) PhoneNumber <span class="cov0" title="0">{
        ret, err := NewPhoneNumber(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package vos

import (
        "strings"
)

type Province struct {
        value string
}

func NewProvince(input string) Province <span class="cov0" title="0">{
        val := strings.TrimSpace(strings.Title(strings.ToLower(input)))
        return Province{val}
}</span>

func (p Province) String() string <span class="cov0" title="0">{
        return p.value
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package vos

import (
        "errors"
        "strings"
)

// RelationshipType - VO para tipo de relação com o dependente

type RelationshipType struct {
        value string
}

func NewRelationshipType(input string) (RelationshipType, error) <span class="cov0" title="0">{
        allowed := []string{"filho", "filha", "cônjuge", "pai", "mãe", "sobrinho"}
        relTrimmed := strings.ToLower(strings.TrimSpace(input))
        for _, a := range allowed </span><span class="cov0" title="0">{
                if relTrimmed == a </span><span class="cov0" title="0">{
                        return RelationshipType{relTrimmed}, nil
                }</span>
        }
        <span class="cov0" title="0">return RelationshipType{}, errors.New("relacionamento inválido: deve ser Filho, Cônjuge, Pai, etc")</span>
}

func (f RelationshipType) String() string <span class="cov0" title="0">{
        return string(f.value)
}</span>

func MustNewRelationshipType(value string) RelationshipType <span class="cov0" title="0">{
        ret, err := NewRelationshipType(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package vos

import (
        "errors"
)

type Salary struct {
        value float64
}

const MinimumLegalSalaryAOA = 32000.0

func NewSalary(input float64) (Salary, error) <span class="cov0" title="0">{
        if input &lt; 0 </span><span class="cov0" title="0">{
                return Salary{}, errors.New("salário não pode ser negativo")
        }</span>
        <span class="cov0" title="0">if input &lt; MinimumLegalSalaryAOA </span><span class="cov0" title="0">{
                return Salary{}, errors.New("salário abaixo do mínimo legal em Angola")
        }</span>
        <span class="cov0" title="0">return Salary{input}, nil</span>
}

func (s Salary) Float64() float64 <span class="cov0" title="0">{
        return s.value
}</span>

func MustNewSalary(value float64) Salary <span class="cov0" title="0">{
        sal, err := NewSalary(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return sal</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package vos

import (
        "errors"
        "strings"
)

type SchoolDegree struct {
        value string
}

var allowedSchoolDegrees = map[string]bool{
        "ensino de base": true,
        "2º ciclo":       true,
        "3º ciclo":       true,
        "ensino médio":   true,
        "bacharelato":    true,
        "licenciatura":   true,
        "mestrado":       true,
        "doutoramento":   true,
}

func NewSchoolDegree(ext string) (SchoolDegree, error) <span class="cov0" title="0">{
        e := strings.ToLower(strings.TrimSpace(ext))
        if !allowedSchoolDegrees[e] </span><span class="cov0" title="0">{
                return SchoolDegree{}, errors.New("grau acadêmico não suportado")
        }</span>
        <span class="cov0" title="0">return SchoolDegree{e}, nil</span>
}

func (e SchoolDegree) String() string <span class="cov0" title="0">{
        return e.value
}</span>

func MustNewSchoolDegree(value string) SchoolDegree <span class="cov0" title="0">{
        sd, err := NewSchoolDegree(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return sd</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package vos

import (
        "errors"
        "regexp"
        "strings"
)

type SocialSecurity struct {
        value string
}

var ssRegex = regexp.MustCompile(`^\d{6,12}$`)

func NewSocialSecurity(input string) (SocialSecurity, error) <span class="cov0" title="0">{
        val := strings.TrimSpace(input)
        if !ssRegex.MatchString(val) </span><span class="cov0" title="0">{
                return SocialSecurity{}, errors.New("número da segurança social inválido")
        }</span>
        <span class="cov0" title="0">return SocialSecurity{val}, nil</span>
}

func (s SocialSecurity) String() string <span class="cov0" title="0">{
        return s.value
}</span>

func MustNewSocialSecurity(value string) SocialSecurity <span class="cov0" title="0">{
        ss, err := NewSocialSecurity(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // ou retorne erro padronizado
        }
        <span class="cov0" title="0">return ss</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package persistence

import (
        "context"
        "database/sql"
        "fmt"

        "rhapp/internal/domain/agregados"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type documentAggregatePgRepository struct {
        db *sql.DB
}

func NewDocumentAggregatePgRepository(db *sql.DB) *documentAggregatePgRepository <span class="cov0" title="0">{
        return &amp;documentAggregatePgRepository{db: db}
}</span>

func (r *documentAggregatePgRepository) GetByOwner(ctx context.Context, ownerType vos.DocumentOwnerType, ownerID uuid.UUID) (*agregados.DocumentAggregate, error) <span class="cov0" title="0">{
        query := `
                SELECT id, type, file_name, file_url, extension, is_active, uploaded_at
                FROM documents
                WHERE owner_type = $1 AND owner_id = $2
        `

        rows, err := r.db.QueryContext(ctx, query, ownerType.String(), ownerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao consultar documentos: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var docs []entities.Document
        for rows.Next() </span><span class="cov0" title="0">{
                var doc entities.Document
                if err := rows.Scan(
                        &amp;doc.ID,
                        &amp;doc.Type,
                        &amp;doc.FileName,
                        &amp;doc.FileURL,
                        &amp;doc.Extension,
                        &amp;doc.IsActive,
                        &amp;doc.UploadedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erro ao escanear documento: %w", err)
                }</span>
                <span class="cov0" title="0">doc.OwnerType = ownerType
                doc.OwnerID = ownerID
                docs = append(docs, doc)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao iterar resultados: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;agregados.DocumentAggregate{
                OwnerType: ownerType,
                OwnerID:   ownerID,
                Documents: docs,
        }, nil</span>
}

var _ agregados.DocumentAggregateRepository = (*documentAggregatePgRepository)(nil)
</pre>
		
		<pre class="file" id="file48" style="display: none">package persistence

import (
        "context"
        "database/sql"
        "fmt"

        "rhapp/internal/domain/agregados"
        "rhapp/internal/domain/entities"

        "github.com/google/uuid"
)

type employeeAggregatePgRepository struct {
        db *sql.DB
}

func NewEmployeeAggregatePgRepository(db *sql.DB) *employeeAggregatePgRepository <span class="cov0" title="0">{
        return &amp;employeeAggregatePgRepository{db: db}
}</span>

func (r *employeeAggregatePgRepository) GetFullByID(ctx context.Context, id uuid.UUID) (*agregados.EmployeeAggregate, error) <span class="cov0" title="0">{
        var agg agregados.EmployeeAggregate

        employeeRepo := NewEmployeePgRepository(r.db)
        emp, err := employeeRepo.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao buscar employee: %w", err)
        }</span>
        <span class="cov0" title="0">agg.Employee = emp

        // Dependents
        dependentsRows, err := r.db.QueryContext(ctx, `
                SELECT id, employee_id, full_name, relationship, gender, date_of_birth, document_id, is_active, created_at, updated_at 
                FROM dependents 
                WHERE employee_id = $1`, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao buscar dependentes: %w", err)
        }</span>
        <span class="cov0" title="0">defer dependentsRows.Close()

        for dependentsRows.Next() </span><span class="cov0" title="0">{
                var d entities.Dependent
                if scanErr := dependentsRows.Scan(&amp;d.ID, &amp;d.EmployeeID, &amp;d.FullName, &amp;d.Relationship, &amp;d.Gender, &amp;d.DateOfBirth, &amp;d.IsActive, &amp;d.CreatedAt, &amp;d.UpdatedAt); scanErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erro ao escanear dependente: %w", scanErr)
                }</span>
                <span class="cov0" title="0">agg.Dependents = append(agg.Dependents, d)</span>
        }
        <span class="cov0" title="0">if err := dependentsRows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao iterar dependentes: %w", err)
        }</span>

        // Education Histories
        <span class="cov0" title="0">eduRows, err := r.db.QueryContext(ctx, `
                SELECT id, employee_id, institution, degree, field_of_study, start_date, end_date, description 
                FROM education_histories 
                WHERE employee_id = $1`, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao buscar históricos educacionais: %w", err)
        }</span>
        <span class="cov0" title="0">defer eduRows.Close()

        for eduRows.Next() </span><span class="cov0" title="0">{
                var e entities.EducationHistory
                if scanErr := eduRows.Scan(&amp;e.ID, &amp;e.EmployeeID, &amp;e.Institution, &amp;e.Degree, &amp;e.AreaEstudoID, &amp;e.StartDate, &amp;e.EndDate, &amp;e.Description); scanErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erro ao escanear histórico educacional: %w", scanErr)
                }</span>
                <span class="cov0" title="0">agg.EducationHistories = append(agg.EducationHistories, e)</span>
        }
        <span class="cov0" title="0">if err := eduRows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao iterar históricos educacionais: %w", err)
        }</span>

        // Work Histories
        <span class="cov0" title="0">workRows, err := r.db.QueryContext(ctx, `
                SELECT id, employee_id, company, position, start_date, end_date, responsibilities 
                FROM work_histories 
                WHERE employee_id = $1`, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao buscar históricos profissionais: %w", err)
        }</span>
        <span class="cov0" title="0">defer workRows.Close()

        for workRows.Next() </span><span class="cov0" title="0">{
                var w entities.WorkHistory
                if scanErr := workRows.Scan(&amp;w.ID, &amp;w.EmployeeID, &amp;w.Company, &amp;w.Position, &amp;w.StartDate, &amp;w.EndDate, &amp;w.Responsibilities); scanErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erro ao escanear histórico profissional: %w", scanErr)
                }</span>
                <span class="cov0" title="0">agg.WorkHistories = append(agg.WorkHistories, w)</span>
        }
        <span class="cov0" title="0">if err := workRows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao iterar históricos profissionais: %w", err)
        }</span>

        // Employee Statuses
        <span class="cov0" title="0">statusRows, err := r.db.QueryContext(ctx, `
                SELECT id, employee_id, status, start_date, end_date, is_current, created_at, updated_at 
                FROM employee_statuses 
                WHERE employee_id = $1`, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao buscar status: %w", err)
        }</span>
        <span class="cov0" title="0">defer statusRows.Close()

        for statusRows.Next() </span><span class="cov0" title="0">{
                var s entities.EmployeeStatus
                if scanErr := statusRows.Scan(&amp;s.ID, &amp;s.EmployeeID, &amp;s.Status, &amp;s.StartDate, &amp;s.EndDate, &amp;s.IsCurrent, &amp;s.CreatedAt, &amp;s.UpdatedAt); scanErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erro ao escanear status: %w", scanErr)
                }</span>
                <span class="cov0" title="0">agg.Statuses = append(agg.Statuses, s)</span>
        }
        <span class="cov0" title="0">if err := statusRows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao iterar status: %w", err)
        }</span>

        // Supervisor History
        <span class="cov0" title="0">supRows, err := r.db.QueryContext(ctx, `
                SELECT id, employee_id, supervisor_id, start_date, end_date, created_at, updated_at 
                FROM supervisor_histories 
                WHERE employee_id = $1`, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao buscar histórico de supervisores: %w", err)
        }</span>
        <span class="cov0" title="0">defer supRows.Close()

        for supRows.Next() </span><span class="cov0" title="0">{
                var sh entities.SupervisorHistory
                if scanErr := supRows.Scan(&amp;sh.ID, &amp;sh.EmployeeID, &amp;sh.SupervisorID, &amp;sh.StartDate, &amp;sh.EndDate, &amp;sh.CreatedAt, &amp;sh.UpdatedAt); scanErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erro ao escanear histórico de supervisores: %w", scanErr)
                }</span>
                <span class="cov0" title="0">agg.SupervisorHistory = append(agg.SupervisorHistory, sh)</span>
        }
        <span class="cov0" title="0">if err := supRows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao iterar histórico de supervisores: %w", err)
        }</span>

        // Documents
        <span class="cov0" title="0">docRows, err := r.db.QueryContext(ctx, `
                SELECT id, owner_type, owner_id, type, file_name, file_url, extension, is_active, uploaded_at 
                FROM documents 
                WHERE owner_type = 'employee' AND owner_id = $1`, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao buscar documentos: %w", err)
        }</span>
        <span class="cov0" title="0">defer docRows.Close()

        for docRows.Next() </span><span class="cov0" title="0">{
                var d entities.Document
                if scanErr := docRows.Scan(&amp;d.ID, &amp;d.OwnerType, &amp;d.OwnerID, &amp;d.Type, &amp;d.FileName, &amp;d.FileURL, &amp;d.Extension, &amp;d.IsActive, &amp;d.UploadedAt); scanErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erro ao escanear documento: %w", scanErr)
                }</span>
                <span class="cov0" title="0">agg.Documents = append(agg.Documents, d)</span>
        }
        <span class="cov0" title="0">if err := docRows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao iterar documentos: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;agg, nil</span>
}

var _ agregados.EmployeeAggregateRepository = (*employeeAggregatePgRepository)(nil)
</pre>
		
		<pre class="file" id="file49" style="display: none">package persistence

import (
        "context"
        "database/sql"
        "fmt"

        "rhapp/internal/domain/agregados"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type locationAggregatePgRepository struct {
        db *sql.DB
}

func NewLocationAggregatePgRepository(db *sql.DB) *locationAggregatePgRepository <span class="cov0" title="0">{
        return &amp;locationAggregatePgRepository{db: db}
}</span>

func (r *locationAggregatePgRepository) GetByProvinceID(ctx context.Context, id uuid.UUID) (*agregados.LocationAggregate, error) <span class="cov0" title="0">{
        var prov entities.Province
        var name string

        query := `SELECT id, name, created_at, updated_at FROM provinces WHERE id = $1`
        if err := r.db.QueryRowContext(ctx, query, id).Scan(&amp;prov.ID, &amp;name, &amp;prov.CreatedAt, &amp;prov.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao buscar província: %w", err)
        }</span>
        <span class="cov0" title="0">nomeVO := vos.NewProvince(name)

        prov.Nome = nomeVO

        agg := &amp;agregados.LocationAggregate{Province: prov}

        // Municípios
        munRows, err := r.db.QueryContext(ctx, `
                SELECT id, name, province_id, created_at, updated_at 
                FROM municipalities 
                WHERE province_id = $1`, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao buscar municípios: %w", err)
        }</span>
        <span class="cov0" title="0">defer munRows.Close()

        for munRows.Next() </span><span class="cov0" title="0">{
                var m entities.Municipality
                var mName string
                if err := munRows.Scan(&amp;m.ID, &amp;mName, &amp;m.ProvinceID, &amp;m.CreatedAt, &amp;m.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erro ao escanear município: %w", err)
                }</span>
                <span class="cov0" title="0">if m.Name, err = vos.NewMunicipality(mName); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erro ao validar município: %w", err)
                }</span>
                <span class="cov0" title="0">agg.Municipalities = append(agg.Municipalities, m)</span>
        }
        <span class="cov0" title="0">if err := munRows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao iterar municípios: %w", err)
        }</span>

        // Distritos
        <span class="cov0" title="0">distRows, err := r.db.QueryContext(ctx, `
                SELECT d.id, d.nome, d.municipio_id, d.created_at, d.updated_at
                FROM districts d
                INNER JOIN municipalities m ON m.id = d.municipio_id
                WHERE m.province_id = $1`, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao buscar distritos: %w", err)
        }</span>
        <span class="cov0" title="0">defer distRows.Close()

        for distRows.Next() </span><span class="cov0" title="0">{
                var d entities.District
                var dName string
                if err := distRows.Scan(&amp;d.ID, &amp;dName, &amp;d.MunicipalityID, &amp;d.CreatedAt, &amp;d.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erro ao escanear distrito: %w", err)
                }</span>
                <span class="cov0" title="0">if d.Name, err = vos.NewDistrict(dName); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erro ao validar distrito: %w", err)
                }</span>
                <span class="cov0" title="0">agg.Districts = append(agg.Districts, d)</span>
        }
        <span class="cov0" title="0">if err := distRows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao iterar distritos: %w", err)
        }</span>

        <span class="cov0" title="0">return agg, nil</span>
}

var _ agregados.LocationAggregateRepository = (*locationAggregatePgRepository)(nil)
</pre>
		
		<pre class="file" id="file50" style="display: none">package persistence

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "rhapp/internal/domain/agregados"
        "rhapp/internal/domain/entities"

        "github.com/google/uuid"
)

type orgStructureAggregatePgRepository struct {
        db *sql.DB
}

func NewOrgStructureAggregatePgRepository(db *sql.DB) *orgStructureAggregatePgRepository <span class="cov0" title="0">{
        return &amp;orgStructureAggregatePgRepository{db: db}
}</span>

func (r *orgStructureAggregatePgRepository) GetByDepartmentID(ctx context.Context, deptID uuid.UUID) (*agregados.OrgStructureAggregate, error) <span class="cov0" title="0">{
        var dept entities.Department
        query := `SELECT id, name, created_at, updated_at FROM departments WHERE id = $1`
        err := r.db.QueryRowContext(ctx, query, deptID).Scan(&amp;dept.ID, &amp;dept.Name, &amp;dept.CreatedAt, &amp;dept.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("departamento com ID %s não encontrado", deptID)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("erro ao buscar departamento: %w", err)</span>
        }

        <span class="cov0" title="0">agg := &amp;agregados.OrgStructureAggregate{
                Department: dept,
        }

        // Posições
        posQuery := `SELECT id, name, department_id, created_at, updated_at FROM positions WHERE department_id = $1`
        posRows, err := r.db.QueryContext(ctx, posQuery, deptID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao buscar posições: %w", err)
        }</span>
        <span class="cov0" title="0">defer posRows.Close()

        for posRows.Next() </span><span class="cov0" title="0">{
                var pos entities.Position
                if scanErr := posRows.Scan(&amp;pos.ID, &amp;pos.Name, &amp;pos.DepartmentID, &amp;pos.CreatedAt, &amp;pos.UpdatedAt); scanErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erro ao escanear posição: %w", scanErr)
                }</span>
                <span class="cov0" title="0">agg.Positions = append(agg.Positions, pos)</span>
        }
        <span class="cov0" title="0">if err = posRows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao iterar posições: %w", err)
        }</span>

        // Funcionários
        <span class="cov0" title="0">empQuery := `
                SELECT id, employee_number, full_name, gender, date_of_birth, nationality, marital_status,
                       phone_number, email, bi, iban, department_id, position_id, address, district_id,
                       hiring_date, contract_type, salary, social_security, supervisor_id,
                       is_active, created_at, updated_at
                FROM employees
                WHERE department_id = $1
        `
        empRows, err := r.db.QueryContext(ctx, empQuery, deptID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao buscar funcionários: %w", err)
        }</span>
        <span class="cov0" title="0">defer empRows.Close()

        for empRows.Next() </span><span class="cov0" title="0">{
                var emp entities.Employee
                var supervisorID sql.NullString

                if scanErr := empRows.Scan(
                        &amp;emp.ID,
                        &amp;emp.EmployeeNumber,
                        &amp;emp.FullName,
                        &amp;emp.Gender,
                        &amp;emp.DateOfBirth,
                        &amp;emp.Nationality,
                        &amp;emp.MaritalStatus,
                        &amp;emp.PhoneNumber,
                        &amp;emp.Email,
                        &amp;emp.BI,
                        &amp;emp.IBAN,
                        &amp;emp.DepartmentID,
                        &amp;emp.PositionID,
                        &amp;emp.Address,
                        &amp;emp.DistrictID,
                        &amp;emp.HiringDate,
                        &amp;emp.ContractType,
                        &amp;emp.Salary,
                        &amp;emp.SocialSecurity,
                        &amp;supervisorID,
                        &amp;emp.IsActive,
                        &amp;emp.CreatedAt,
                        &amp;emp.UpdatedAt,
                ); scanErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erro ao escanear funcionário: %w", scanErr)
                }</span>

                <span class="cov0" title="0">if supervisorID.Valid </span><span class="cov0" title="0">{
                        supID, parseErr := uuid.Parse(supervisorID.String)
                        if parseErr == nil </span><span class="cov0" title="0">{
                                emp.SupervisorID = &amp;supID
                        }</span>
                }

                <span class="cov0" title="0">agg.Employees = append(agg.Employees, emp)</span>
        }
        <span class="cov0" title="0">if err = empRows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao iterar funcionários: %w", err)
        }</span>

        <span class="cov0" title="0">return agg, nil</span>
}

var _ agregados.OrgStructureAggregateRepository = (*orgStructureAggregatePgRepository)(nil)
</pre>
		
		<pre class="file" id="file51" style="display: none">package persistence

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type areaEstudoPgRepository struct {
        db *sql.DB
}

func NewAreaEstudoPgRepository(db *sql.DB) *areaEstudoPgRepository <span class="cov0" title="0">{
        return &amp;areaEstudoPgRepository{db: db}
}</span>

func (r *areaEstudoPgRepository) Create(ctx context.Context, a entities.AreaEstudo) error <span class="cov0" title="0">{
        query := `
                INSERT INTO areas_estudo (id, name, description, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5)
        `
        _, err := r.db.ExecContext(ctx, query, a.ID, a.Name, a.Description, a.CreatedAt, a.UpdatedAt)
        return err
}</span>

func (r *areaEstudoPgRepository) Update(ctx context.Context, a entities.AreaEstudo) error <span class="cov0" title="0">{
        query := `
                UPDATE areas_estudo
                SET name = $1, description = $2, updated_at = $3
                WHERE id = $4
        `
        res, err := r.db.ExecContext(ctx, query, a.Name, a.Description, a.UpdatedAt, a.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows, _ := res.RowsAffected(); rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *areaEstudoPgRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        query := `DELETE FROM areas_estudo WHERE id = $1`
        res, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows, _ := res.RowsAffected(); rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *areaEstudoPgRepository) FindByID(ctx context.Context, id uuid.UUID) (entities.AreaEstudo, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, created_at, updated_at
                FROM areas_estudo
                WHERE id = $1
        `
        var a entities.AreaEstudo
        err := r.db.QueryRowContext(ctx, query, id).Scan(&amp;a.ID, &amp;a.Name, &amp;a.Description, &amp;a.CreatedAt, &amp;a.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return a, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return a, err</span>
        }
        <span class="cov0" title="0">return a, nil</span>
}

func (r *areaEstudoPgRepository) FindAll(ctx context.Context, limit, offset int) ([]entities.AreaEstudo, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, created_at, updated_at
                FROM areas_estudo
                ORDER BY created_at DESC
                LIMIT $1 OFFSET $2
        `
        rows, err := r.db.QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var list []entities.AreaEstudo
        for rows.Next() </span><span class="cov0" title="0">{
                var a entities.AreaEstudo
                if err := rows.Scan(&amp;a.ID, &amp;a.Name, &amp;a.Description, &amp;a.CreatedAt, &amp;a.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">list = append(list, a)</span>
        }
        <span class="cov0" title="0">return list, rows.Err()</span>
}

func (r *areaEstudoPgRepository) Search(ctx context.Context, searchText, _ string, limit, offset int) ([]entities.AreaEstudo, error) <span class="cov0" title="0">{
        query := `SELECT * FROM search_areas_estudo($1, $2, $3)`
        rows, err := r.db.QueryContext(ctx, query, searchText, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []entities.AreaEstudo
        for rows.Next() </span><span class="cov0" title="0">{
                var a entities.AreaEstudo
                if err := rows.Scan(&amp;a.ID, &amp;a.Name, &amp;a.Description, &amp;a.CreatedAt, &amp;a.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erro ao escanear linha: %w", err)
                }</span>
                <span class="cov0" title="0">results = append(results, a)</span>
        }
        <span class="cov0" title="0">return results, rows.Err()</span>
}

func (r *areaEstudoPgRepository) ExistsByID(ctx context.Context, id uuid.UUID) (bool, error) <span class="cov0" title="0">{
        query := `SELECT EXISTS (SELECT 1 FROM areas_estudo WHERE id = $1)`
        var exists bool
        err := r.db.QueryRowContext(ctx, query, id).Scan(&amp;exists)
        return exists, err
}</span>

func (r *areaEstudoPgRepository) ExistsByName(ctx context.Context, name string) (bool, error) <span class="cov0" title="0">{
        query := `SELECT EXISTS (SELECT 1 FROM areas_estudo WHERE LOWER(name) = LOWER($1))`
        var exists bool
        err := r.db.QueryRowContext(ctx, query, name).Scan(&amp;exists)
        return exists, err
}</span>

var _ repos.AreaEstudoRepository = (*areaEstudoPgRepository)(nil)
</pre>
		
		<pre class="file" id="file52" style="display: none">package persistence

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type departmentPgRepository struct {
        db *sql.DB
}

func NewDepartmentPgRepository(db *sql.DB) *departmentPgRepository <span class="cov0" title="0">{
        return &amp;departmentPgRepository{db: db}
}</span>

func (r *departmentPgRepository) Create(ctx context.Context, d entities.Department) error <span class="cov0" title="0">{
        query := `
                INSERT INTO departments (id, name, created_at, updated_at)
                VALUES ($1, $2, $3, $4)
        `
        _, err := r.db.ExecContext(ctx, query, d.ID, d.Name, d.CreatedAt, d.UpdatedAt)
        return err
}</span>

func (r *departmentPgRepository) Update(ctx context.Context, d entities.Department) error <span class="cov0" title="0">{
        query := `
                UPDATE departments
                SET name = $1, updated_at = $2
                WHERE id = $3
        `
        res, err := r.db.ExecContext(ctx, query, d.Name, d.UpdatedAt, d.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows, _ := res.RowsAffected(); rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *departmentPgRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        query := `DELETE FROM departments WHERE id = $1`
        res, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows, _ := res.RowsAffected(); rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *departmentPgRepository) FindByID(ctx context.Context, id uuid.UUID) (entities.Department, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, created_at, updated_at
                FROM departments
                WHERE id = $1
        `
        var d entities.Department
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;d.ID, &amp;d.Name, &amp;d.CreatedAt, &amp;d.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return d, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return d, err</span>
        }
        <span class="cov0" title="0">return d, nil</span>
}

func (r *departmentPgRepository) FindAll(ctx context.Context, limit, offset int) ([]entities.Department, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, created_at, updated_at
                FROM departments
                ORDER BY created_at DESC
                LIMIT $1 OFFSET $2
        `
        rows, err := r.db.QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var list []entities.Department
        for rows.Next() </span><span class="cov0" title="0">{
                var d entities.Department
                if err := rows.Scan(&amp;d.ID, &amp;d.Name, &amp;d.CreatedAt, &amp;d.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">list = append(list, d)</span>
        }
        <span class="cov0" title="0">return list, rows.Err()</span>
}

func (r *departmentPgRepository) Search(ctx context.Context, searchText, _ string, limit, offset int) ([]entities.Department, error) <span class="cov0" title="0">{
        query := `SELECT * FROM search_departments($1, $2, $3)`
        rows, err := r.db.QueryContext(ctx, query, searchText, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []entities.Department
        for rows.Next() </span><span class="cov0" title="0">{
                var d entities.Department
                if err := rows.Scan(&amp;d.ID, &amp;d.Name, &amp;d.CreatedAt, &amp;d.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erro ao escanear linha: %w", err)
                }</span>
                <span class="cov0" title="0">results = append(results, d)</span>
        }
        <span class="cov0" title="0">return results, rows.Err()</span>
}

func (r *departmentPgRepository) ExistsByID(ctx context.Context, id uuid.UUID) (bool, error) <span class="cov0" title="0">{
        query := `SELECT EXISTS (SELECT 1 FROM departments WHERE id = $1)`
        var exists bool
        err := r.db.QueryRowContext(ctx, query, id).Scan(&amp;exists)
        return exists, err
}</span>

func (r *departmentPgRepository) ExistsByName(ctx context.Context, name string) (bool, error) <span class="cov0" title="0">{
        query := `SELECT EXISTS (SELECT 1 FROM departments WHERE LOWER(name) = LOWER($1))`
        var exists bool
        err := r.db.QueryRowContext(ctx, query, name).Scan(&amp;exists)
        return exists, err
}</span>

var _ repos.DepartmentRepository = (*departmentPgRepository)(nil)
</pre>
		
		<pre class="file" id="file53" style="display: none">// internal/infra/persistence/dependent_pg_repository.go
package persistence

import (
        "context"
        "database/sql"
        "errors"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type dependentPgRepository struct {
        db *sql.DB
}

func NewDependentPgRepository(db *sql.DB) *dependentPgRepository <span class="cov0" title="0">{
        return &amp;dependentPgRepository{db: db}
}</span>

func (r *dependentPgRepository) Create(ctx context.Context, d entities.Dependent) error <span class="cov0" title="0">{
        query := `
                INSERT INTO dependents (
                        id, employee_id, full_name, relationship, gender, date_of_birth, is_active, created_at, updated_at
                ) VALUES (
                        $1,$2,$3,$4,$5,$6,$7,$8,$9
                )
        `
        _, err := r.db.ExecContext(ctx, query,
                d.ID, d.EmployeeID, d.FullName, d.Relationship, d.Gender, d.DateOfBirth,
                d.IsActive, d.CreatedAt, d.UpdatedAt,
        )
        return err
}</span>

func (r *dependentPgRepository) Update(ctx context.Context, d entities.Dependent) error <span class="cov0" title="0">{
        query := `
                UPDATE dependents SET
                        full_name = $1, relationship = $2, gender = $3,
                        date_of_birth = $4, is_active = $5, updated_at = $6
                WHERE id = $7
        `
        res, err := r.db.ExecContext(ctx, query,
                d.FullName, d.Relationship, d.Gender,
                d.DateOfBirth, d.IsActive,
                d.UpdatedAt, d.ID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows, _ := res.RowsAffected(); rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *dependentPgRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        res, err := r.db.ExecContext(ctx, `DELETE FROM dependents WHERE id = $1`, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows, _ := res.RowsAffected(); rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *dependentPgRepository) FindByID(ctx context.Context, id uuid.UUID) (entities.Dependent, error) <span class="cov0" title="0">{
        query := `
                SELECT id, employee_id, full_name, relationship, gender, date_of_birth, is_active, created_at, updated_at
                FROM dependents WHERE id = $1
        `
        var d entities.Dependent
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;d.ID, &amp;d.EmployeeID, &amp;d.FullName, &amp;d.Relationship, &amp;d.Gender,
                &amp;d.DateOfBirth, &amp;d.IsActive, &amp;d.CreatedAt, &amp;d.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return entities.Dependent{}, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return entities.Dependent{}, err</span>
        }
        <span class="cov0" title="0">return d, nil</span>
}

func (r *dependentPgRepository) FindAll(ctx context.Context, limit, offset int) ([]entities.Dependent, error) <span class="cov0" title="0">{
        query := `
                SELECT id, employee_id, full_name, relationship, gender, date_of_birth, is_active, created_at, updated_at
                FROM dependents ORDER BY created_at DESC
                LIMIT $1 OFFSET $2
        `
        rows, err := r.db.QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var list []entities.Dependent
        for rows.Next() </span><span class="cov0" title="0">{
                var d entities.Dependent
                if err := rows.Scan(
                        &amp;d.ID, &amp;d.EmployeeID, &amp;d.FullName, &amp;d.Relationship, &amp;d.Gender,
                        &amp;d.DateOfBirth, &amp;d.IsActive, &amp;d.CreatedAt, &amp;d.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">list = append(list, d)</span>
        }
        <span class="cov0" title="0">return list, nil</span>
}

func (r *dependentPgRepository) Search(ctx context.Context, searchText, filter string, limit, offset int, empID *uuid.UUID) ([]entities.Dependent, error) <span class="cov0" title="0">{
        rows, err := r.db.QueryContext(ctx,
                `SELECT id, employee_id, full_name, relationship, gender, date_of_birth, is_active, created_at, updated_at
                 FROM search_dependents($1, $2, $3, $4)`,
                searchText, empID, limit, offset,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var list []entities.Dependent
        for rows.Next() </span><span class="cov0" title="0">{
                var d entities.Dependent
                if err := rows.Scan(
                        &amp;d.ID, &amp;d.EmployeeID, &amp;d.FullName, &amp;d.Relationship, &amp;d.Gender,
                        &amp;d.DateOfBirth, &amp;d.IsActive, &amp;d.CreatedAt, &amp;d.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">list = append(list, d)</span>
        }
        <span class="cov0" title="0">return list, nil</span>
}

func (r *dependentPgRepository) ExistsByID(ctx context.Context, id uuid.UUID) (bool, error) <span class="cov0" title="0">{
        query := `SELECT EXISTS (SELECT 1 FROM dependents WHERE id = $1)`
        var exists bool
        err := r.db.QueryRowContext(ctx, query, id).Scan(&amp;exists)
        return exists, err
}</span>

var _ repos.DependentRepository = (*dependentPgRepository)(nil)
</pre>
		
		<pre class="file" id="file54" style="display: none">package persistence

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "rhapp/internal/domain/dtos"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type districtPgRepository struct {
        db *sql.DB
}

func NewDistrictPgRepository(db *sql.DB) *districtPgRepository <span class="cov0" title="0">{
        return &amp;districtPgRepository{db: db}
}</span>

func (r *districtPgRepository) Create(ctx context.Context, d entities.District) error <span class="cov0" title="0">{
        query := `
                INSERT INTO districts (id, name, municipio_id, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5)
        `
        _, err := r.db.ExecContext(ctx, query,
                d.ID, d.Name.String(), d.MunicipalityID, d.CreatedAt, d.UpdatedAt,
        )
        return err
}</span>

func (r *districtPgRepository) Update(ctx context.Context, d entities.District) error <span class="cov0" title="0">{
        query := `
                UPDATE districts
                SET name = $1, municipio_id = $2, updated_at = $3
                WHERE id = $4
        `
        res, err := r.db.ExecContext(ctx, query,
                d.Name.String(), d.MunicipalityID, d.UpdatedAt, d.ID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows, _ := res.RowsAffected(); rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *districtPgRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        query := `DELETE FROM districts WHERE id = $1`
        res, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows, _ := res.RowsAffected(); rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *districtPgRepository) FindByID(ctx context.Context, id uuid.UUID) (entities.District, error) <span class="cov0" title="0">{
        query := `SELECT id, name, municipio_id, created_at, updated_at FROM districts WHERE id = $1`
        var d entities.District
        var name string

        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;d.ID, &amp;name, &amp;d.MunicipalityID, &amp;d.CreatedAt, &amp;d.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return d, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return d, err</span>
        }

        <span class="cov0" title="0">if d.Name, err = vos.NewDistrict(name); err != nil </span><span class="cov0" title="0">{
                return d, fmt.Errorf("erro ao validar nome do distrito: %w", err)
        }</span>

        <span class="cov0" title="0">return d, nil</span>
}

func (r *districtPgRepository) FindAll(ctx context.Context, limit, offset int) ([]entities.District, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, municipio_id, created_at, updated_at
                FROM districts
                ORDER BY created_at DESC LIMIT $1 OFFSET $2;
        `

        rows, err := r.db.QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var list []entities.District
        for rows.Next() </span><span class="cov0" title="0">{
                var d entities.District
                var name string

                if err := rows.Scan(&amp;d.ID, &amp;name, &amp;d.MunicipalityID, &amp;d.CreatedAt, &amp;d.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if d.Name, err = vos.NewDistrict(name); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erro ao validar nome do distrito: %w", err)
                }</span>
                <span class="cov0" title="0">list = append(list, d)</span>
        }
        <span class="cov0" title="0">return list, rows.Err()</span>
}

func (r *districtPgRepository) Search(ctx context.Context, searchText, municipioFilter string, limit, offset int) ([]dtos.DistritoResultDTO, error) <span class="cov0" title="0">{
        query := `SELECT * FROM search_districts($1, $2, $3, $4)`
        rows, err := r.db.QueryContext(ctx, query, searchText, municipioFilter, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []dtos.DistritoResultDTO
        for rows.Next() </span><span class="cov0" title="0">{
                var d dtos.DistritoResultDTO
                if err := rows.Scan(&amp;d.ID, &amp;d.Name, &amp;d.MunicipioID, &amp;d.MunicipioName, &amp;d.CreatedAt, &amp;d.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">results = append(results, d)</span>
        }
        <span class="cov0" title="0">return results, rows.Err()</span>
}

func (r *districtPgRepository) ExistsByID(ctx context.Context, id uuid.UUID) (bool, error) <span class="cov0" title="0">{
        query := `SELECT EXISTS (SELECT 1 FROM districts WHERE id = $1)`
        var exists bool
        err := r.db.QueryRowContext(ctx, query, id).Scan(&amp;exists)
        return exists, err
}</span>

func (r *districtPgRepository) ExistsByNameAndMunicipio(ctx context.Context, name string, municipioID uuid.UUID) (bool, error) <span class="cov0" title="0">{
        query := `
                SELECT EXISTS (
                        SELECT 1 FROM districts
                        WHERE LOWER(name) = LOWER($1) AND municipio_id = $2
                )
        `
        var exists bool
        err := r.db.QueryRowContext(ctx, query, name, municipioID).Scan(&amp;exists)
        return exists, err
}</span>

var _ repos.DistrictRepository = (*districtPgRepository)(nil)
</pre>
		
		<pre class="file" id="file55" style="display: none">package persistence

import (
        "context"
        "database/sql"
        "errors"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type documentPgRepository struct {
        db *sql.DB
}

func NewDocumentPgRepository(db *sql.DB) repos.DocumentRepository <span class="cov0" title="0">{
        return &amp;documentPgRepository{db: db}
}</span>

func (r *documentPgRepository) Create(ctx context.Context, doc entities.Document) error <span class="cov0" title="0">{
        query := `
                INSERT INTO documents (
                        id, owner_type, owner_id, type, file_name, file_url, extension,
                        is_active, uploaded_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`
        _, err := r.db.ExecContext(ctx, query,
                doc.ID, doc.OwnerType, doc.OwnerID, doc.Type, doc.FileName,
                doc.FileURL, doc.Extension, doc.IsActive, doc.UploadedAt,
        )
        return err
}</span>

func (r *documentPgRepository) Update(ctx context.Context, doc entities.Document) error <span class="cov0" title="0">{
        query := `
                UPDATE documents SET
                        owner_type = $1, owner_id = $2, type = $3,
                        file_name = $4, file_url = $5, extension = $6,
                        is_active = $7, uploaded_at = $8
                WHERE id = $9`
        res, err := r.db.ExecContext(ctx, query,
                doc.OwnerType, doc.OwnerID, doc.Type, doc.FileName, doc.FileURL,
                doc.Extension, doc.IsActive, doc.UploadedAt, doc.ID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows, _ := res.RowsAffected()
        if rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *documentPgRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        query := `DELETE FROM documents WHERE id = $1`
        res, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows, _ := res.RowsAffected()
        if rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *documentPgRepository) FindByID(ctx context.Context, id uuid.UUID) (entities.Document, error) <span class="cov0" title="0">{
        query := `SELECT id, owner_type, owner_id, type, file_name, file_url, extension, is_active, uploaded_at FROM documents WHERE id = $1`
        var d entities.Document
        err := r.db.QueryRowContext(ctx, query).Scan(
                &amp;d.ID, &amp;d.OwnerType, &amp;d.OwnerID, &amp;d.Type,
                &amp;d.FileName, &amp;d.FileURL, &amp;d.Extension,
                &amp;d.IsActive, &amp;d.UploadedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return entities.Document{}, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return entities.Document{}, err</span>
        }
        <span class="cov0" title="0">return d, nil</span>
}

func (r *documentPgRepository) FindAll(ctx context.Context, limit, offset int) ([]entities.Document, error) <span class="cov0" title="0">{
        query := `SELECT id, owner_type, owner_id, type, file_name, file_url, extension, is_active, uploaded_at FROM documents ORDER BY uploaded_at DESC LIMIT $1 OFFSET $2`
        rows, err := r.db.QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var list []entities.Document
        for rows.Next() </span><span class="cov0" title="0">{
                var d entities.Document
                if err := rows.Scan(
                        &amp;d.ID, &amp;d.OwnerType, &amp;d.OwnerID, &amp;d.Type,
                        &amp;d.FileName, &amp;d.FileURL, &amp;d.Extension,
                        &amp;d.IsActive, &amp;d.UploadedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">list = append(list, d)</span>
        }
        <span class="cov0" title="0">return list, nil</span>
}

func (r *documentPgRepository) ExistsByID(ctx context.Context, id uuid.UUID) (bool, error) <span class="cov0" title="0">{
        var exists bool
        err := r.db.QueryRowContext(ctx, `SELECT EXISTS(SELECT 1 FROM documents WHERE id = $1)`, id).Scan(&amp;exists)
        return exists, err
}</span>

var _ repos.DocumentRepository = (*documentPgRepository)(nil)
</pre>
		
		<pre class="file" id="file56" style="display: none">package persistence

import (
        "context"
        "database/sql"
        "errors"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type educationPgRepository struct {
        db *sql.DB
}

func NewEducationPgRepository(db *sql.DB) repos.EducationHistoryRepository <span class="cov0" title="0">{
        return &amp;educationPgRepository{db: db}
}</span>

func (r *educationPgRepository) Create(ctx context.Context, h entities.EducationHistory) error <span class="cov0" title="0">{
        query := `
                INSERT INTO education_histories (
                        id, employee_id, institution, degree, field_of_study,
                        start_date, end_date, description, created_at, updated_at
                ) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10)`
        _, err := r.db.ExecContext(ctx, query,
                h.ID, h.EmployeeID, h.Institution, h.Degree, h.AreaEstudoID,
                h.StartDate, h.EndDate, h.Description, h.CreatedAt, h.UpdatedAt,
        )
        return err
}</span>

func (r *educationPgRepository) Update(ctx context.Context, h entities.EducationHistory) error <span class="cov0" title="0">{
        query := `
                UPDATE education_histories SET
                        institution = $1, degree = $2, field_of_study = $3,
                        start_date = $4, end_date = $5, description = $6,
                        updated_at = $7
                WHERE id = $8`
        res, err := r.db.ExecContext(ctx, query,
                h.Institution, h.Degree, h.AreaEstudoID,
                h.StartDate, h.EndDate, h.Description,
                h.UpdatedAt, h.ID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows, _ := res.RowsAffected()
        if rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *educationPgRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        query := `DELETE FROM education_histories WHERE id = $1`
        res, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows, _ := res.RowsAffected()
        if rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *educationPgRepository) FindByID(ctx context.Context, id uuid.UUID) (entities.EducationHistory, error) <span class="cov0" title="0">{
        query := `
                SELECT id, employee_id, institution, degree, field_of_study,
                       start_date, end_date, description, created_at, updated_at
                FROM education_histories WHERE id = $1`
        var h entities.EducationHistory
        err := r.db.QueryRowContext(ctx, query).Scan(
                &amp;h.ID, &amp;h.EmployeeID, &amp;h.Institution, &amp;h.Degree, &amp;h.AreaEstudoID,
                &amp;h.StartDate, &amp;h.EndDate, &amp;h.Description, &amp;h.CreatedAt, &amp;h.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return entities.EducationHistory{}, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return entities.EducationHistory{}, err</span>
        }
        <span class="cov0" title="0">return h, nil</span>
}

func (r *educationPgRepository) FindAllByEmployee(ctx context.Context, employeeID uuid.UUID, limit, offset int) ([]entities.EducationHistory, error) <span class="cov0" title="0">{
        query := `
                SELECT id, employee_id, institution, degree, field_of_study,
                       start_date, end_date, description, created_at, updated_at
                FROM education_histories
                WHERE employee_id = $1
                ORDER BY start_date DESC LIMIT $2 OFFSET $3`
        rows, err := r.db.QueryContext(ctx, query, employeeID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var list []entities.EducationHistory
        for rows.Next() </span><span class="cov0" title="0">{
                var h entities.EducationHistory
                if err := rows.Scan(
                        &amp;h.ID, &amp;h.EmployeeID, &amp;h.Institution, &amp;h.Degree, &amp;h.AreaEstudoID,
                        &amp;h.StartDate, &amp;h.EndDate, &amp;h.Description, &amp;h.CreatedAt, &amp;h.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">list = append(list, h)</span>
        }
        <span class="cov0" title="0">return list, nil</span>
}

func (r *educationPgRepository) Search(ctx context.Context, employeeID *uuid.UUID, searchText string, startDate, endDate *string, limit, offset int) ([]entities.EducationHistory, error) <span class="cov0" title="0">{
        query := `SELECT * FROM search_education_histories($1, $2, $3, $4, $5, $6)`
        var empID any
        if employeeID != nil </span><span class="cov0" title="0">{
                empID = *employeeID
        }</span>
        <span class="cov0" title="0">rows, err := r.db.QueryContext(ctx, query, empID, searchText, startDate, endDate, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []entities.EducationHistory
        for rows.Next() </span><span class="cov0" title="0">{
                var h entities.EducationHistory
                if err := rows.Scan(
                        &amp;h.ID, &amp;h.EmployeeID, &amp;h.Institution, &amp;h.Degree, &amp;h.AreaEstudoID,
                        &amp;h.StartDate, &amp;h.EndDate, &amp;h.Description, &amp;h.CreatedAt, &amp;h.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">results = append(results, h)</span>
        }
        <span class="cov0" title="0">return results, nil</span>
}

func (r *educationPgRepository) ExistsByID(ctx context.Context, id uuid.UUID) (bool, error) <span class="cov0" title="0">{
        query := `SELECT EXISTS(SELECT 1 FROM education_histories WHERE id = $1)`
        var exists bool
        err := r.db.QueryRowContext(ctx, query, id).Scan(&amp;exists)
        return exists, err
}</span>

var _ repos.EducationHistoryRepository = (*educationPgRepository)(nil)
</pre>
		
		<pre class="file" id="file57" style="display: none">package persistence

import (
        "context"
        "database/sql"
        "fmt"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type employeePgRepository struct {
        db *sql.DB
}

func NewEmployeePgRepository(db *sql.DB) *employeePgRepository <span class="cov0" title="0">{
        return &amp;employeePgRepository{db: db}
}</span>

func (r *employeePgRepository) Create(ctx context.Context, e entities.Employee) error <span class="cov0" title="0">{
        query := `
                INSERT INTO employees (
                        id, employee_number, full_name, gender, date_of_birth, nationality, marital_status,
                        phone_number, email, bi, iban, department_id, position_id, address, district_id,
                        hiring_date, contract_type, salary, social_security, supervisor_id,
                        is_active, created_at, updated_at
                ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7,
                        $8, $9, $10, $11, $12, $13, $14, $15,
                        $16, $17, $18, $19, $20, $21,
                        $22, $23
                )
        `
        _, err := r.db.ExecContext(ctx, query,
                e.ID,
                e.EmployeeNumber,
                e.FullName.String(),
                e.Gender.String(),
                e.DateOfBirth,
                e.Nationality.String(),
                e.MaritalStatus.String(),
                e.PhoneNumber.String(),
                e.Email.String(),
                e.BI.String(),
                e.IBAN.String(),
                e.DepartmentID,
                e.PositionID,
                e.Address.String(),
                e.DistrictID,
                e.HiringDate,
                e.ContractType.String(),
                e.Salary.Float64(),
                e.SocialSecurity.String(),
                e.SupervisorID,
                e.IsActive,
                e.CreatedAt,
                e.UpdatedAt,
        )
        return err
}</span>

func (r *employeePgRepository) FindByID(ctx context.Context, id uuid.UUID) (entities.Employee, error) <span class="cov0" title="0">{
        query := `SELECT 
                id, employee_number, full_name, gender, date_of_birth, nationality, marital_status,
                phone_number, email, bi, iban, department_id, position_id, address, district_id,
                hiring_date, contract_type, salary, social_security, supervisor_id,
                is_active, created_at, updated_at
                FROM employees WHERE id = $1`

        row := r.db.QueryRowContext(ctx, query, id)
        return scanEmployeeFromRow(row)
}</span>

func (r *employeePgRepository) Update(ctx context.Context, e entities.Employee) error <span class="cov0" title="0">{
        query := `
                UPDATE employees SET
                        marital_status = $2,
                        phone_number = $3,
                        email = $4,
                        iban = $5,
                        department_id = $6,
                        position_id = $7,
                        address = $8,
                        district_id = $9,
                        contract_type = $10,
                        salary = $11,
                        supervisor_id = $12,
                        is_active = $13,
                        updated_at = $14
                WHERE id = $1
        `

        _, err := r.db.ExecContext(ctx, query,
                e.ID,
                e.MaritalStatus.String(),
                e.PhoneNumber.String(),
                e.Email.String(),
                e.IBAN.String(),
                e.DepartmentID,
                e.PositionID,
                e.Address.String(),
                e.DistrictID,
                e.ContractType.String(),
                e.Salary.Float64(),
                e.SupervisorID,
                e.IsActive,
                e.UpdatedAt,
        )
        return err
}</span>

func (r *employeePgRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := r.db.ExecContext(ctx, `DELETE FROM employees WHERE id = $1`, id)
        return err
}</span>

func (r *employeePgRepository) ExistsByID(ctx context.Context, id uuid.UUID) (bool, error) <span class="cov0" title="0">{
        var count int
        err := r.db.QueryRowContext(ctx, `SELECT COUNT(1) FROM employees WHERE id = $1`, id).Scan(&amp;count)
        return count &gt; 0, err
}</span>

func (r *employeePgRepository) List(ctx context.Context, limit, offset int) ([]entities.Employee, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, employee_number, full_name, gender, date_of_birth, nationality, marital_status,
                        phone_number, email, bi, iban, department_id, position_id, address, district_id,
                        hiring_date, contract_type, salary, social_security, supervisor_id,
                        is_active, created_at, updated_at
                FROM employees
                ORDER BY created_at DESC
                LIMIT $1 OFFSET $2;
        `

        rows, err := r.db.QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var list []entities.Employee
        for rows.Next() </span><span class="cov0" title="0">{
                e, err := scanEmployeeFromRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">list = append(list, e)</span>
        }
        <span class="cov0" title="0">return list, rows.Err()</span>
}

func (r *employeePgRepository) Search(ctx context.Context, searchText, departmentFilter string, limit, offset int) ([]entities.Employee, error) <span class="cov0" title="0">{
        rows, err := r.db.QueryContext(ctx, `SELECT * FROM search_employees($1, $2, $3, $4)`, searchText, departmentFilter, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var list []entities.Employee
        for rows.Next() </span><span class="cov0" title="0">{
                e, err := scanEmployeeFromRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">list = append(list, e)</span>
        }
        <span class="cov0" title="0">return list, rows.Err()</span>
}

func scanEmployeeFromRow(scanner interface {
        Scan(dest ...any) error
}) (entities.Employee, error) <span class="cov0" title="0">{
        var e entities.Employee
        var supervisorID sql.NullString

        var (
                fullNameStr, genderStr, nationalityStr, maritalStr,
                phoneStr, emailStr, biStr, ibanStr, addressStr,
                contractStr, securityStr string
                salaryFloat float64
        )

        err := scanner.Scan(
                &amp;e.ID, &amp;e.EmployeeNumber, &amp;fullNameStr, &amp;genderStr, &amp;e.DateOfBirth,
                &amp;nationalityStr, &amp;maritalStr, &amp;phoneStr, &amp;emailStr, &amp;biStr, &amp;ibanStr,
                &amp;e.DepartmentID, &amp;e.PositionID, &amp;addressStr, &amp;e.DistrictID, &amp;e.HiringDate,
                &amp;contractStr, &amp;salaryFloat, &amp;securityStr, &amp;supervisorID,
                &amp;e.IsActive, &amp;e.CreatedAt, &amp;e.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return e, err
        }</span>

        <span class="cov0" title="0">if e.FullName, err = vos.NewPersonalName(fullNameStr); err != nil </span><span class="cov0" title="0">{
                return e, err
        }</span>
        <span class="cov0" title="0">if e.Gender, err = vos.NewGender(genderStr); err != nil </span><span class="cov0" title="0">{
                return e, err
        }</span>
        <span class="cov0" title="0">if e.Nationality, err = vos.NewNationality(nationalityStr); err != nil </span><span class="cov0" title="0">{
                return e, err
        }</span>
        <span class="cov0" title="0">if e.MaritalStatus, err = vos.NewMaritalStatus(maritalStr); err != nil </span><span class="cov0" title="0">{
                return e, err
        }</span>
        <span class="cov0" title="0">if e.PhoneNumber, err = vos.NewPhoneNumber(phoneStr); err != nil </span><span class="cov0" title="0">{
                return e, err
        }</span>
        <span class="cov0" title="0">if e.Email, err = vos.NewEmail(emailStr); err != nil </span><span class="cov0" title="0">{
                return e, err
        }</span>
        <span class="cov0" title="0">if e.BI, err = vos.NewBI(biStr); err != nil </span><span class="cov0" title="0">{
                return e, err
        }</span>
        <span class="cov0" title="0">if e.IBAN, err = vos.NewIBAN(ibanStr); err != nil </span><span class="cov0" title="0">{
                return e, err
        }</span>
        <span class="cov0" title="0">if e.Address, err = vos.NewAddress(addressStr); err != nil </span><span class="cov0" title="0">{
                return e, err
        }</span>
        <span class="cov0" title="0">if e.ContractType, err = vos.NewContractType(contractStr); err != nil </span><span class="cov0" title="0">{
                return e, err
        }</span>
        <span class="cov0" title="0">if e.Salary, err = vos.NewSalary(salaryFloat); err != nil </span><span class="cov0" title="0">{
                return e, err
        }</span>
        <span class="cov0" title="0">if e.SocialSecurity, err = vos.NewSocialSecurity(securityStr); err != nil </span><span class="cov0" title="0">{
                return e, err
        }</span>

        <span class="cov0" title="0">if supervisorID.Valid </span><span class="cov0" title="0">{
                sid, err := uuid.Parse(supervisorID.String)
                if err != nil </span><span class="cov0" title="0">{
                        return e, fmt.Errorf("erro ao converter supervisor_id: %w", err)
                }</span>
                <span class="cov0" title="0">e.SupervisorID = &amp;sid</span>
        }
        <span class="cov0" title="0">return e, nil</span>
}

var _ repos.EmployeeRepository = (*employeePgRepository)(nil)
</pre>
		
		<pre class="file" id="file58" style="display: none">package persistence

import (
        "context"
        "database/sql"
        "errors"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type employeeStatusPgRepository struct {
        db *sql.DB
}

func NewEmployeeStatusPgRepository(db *sql.DB) repos.EmployeeStatusRepository <span class="cov0" title="0">{
        return &amp;employeeStatusPgRepository{db: db}
}</span>

func (r *employeeStatusPgRepository) Create(ctx context.Context, s entities.EmployeeStatus) error <span class="cov0" title="0">{
        query := `
                INSERT INTO employee_statuses (
                        id, employee_id, status, reason,
                        start_date, end_date, is_current,
                        created_at, updated_at
                ) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)`
        _, err := r.db.ExecContext(ctx, query,
                s.ID, s.EmployeeID, s.Status, s.Reason,
                s.StartDate, s.EndDate, s.IsCurrent,
                s.CreatedAt, s.UpdatedAt,
        )
        return err
}</span>

func (r *employeeStatusPgRepository) Update(ctx context.Context, s entities.EmployeeStatus) error <span class="cov0" title="0">{
        query := `
                UPDATE employee_statuses SET
                        status = $1, reason = $2, start_date = $3,
                        end_date = $4, is_current = $5, updated_at = $6
                WHERE id = $7`
        res, err := r.db.ExecContext(ctx, query,
                s.Status, s.Reason, s.StartDate,
                s.EndDate, s.IsCurrent, s.UpdatedAt,
                s.ID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows, _ := res.RowsAffected(); rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *employeeStatusPgRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        query := `DELETE FROM employee_statuses WHERE id = $1`
        res, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows, _ := res.RowsAffected(); rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *employeeStatusPgRepository) FindByID(ctx context.Context, id uuid.UUID) (entities.EmployeeStatus, error) <span class="cov0" title="0">{
        query := `
                SELECT id, employee_id, status, reason,
                       start_date, end_date, is_current,
                       created_at, updated_at
                FROM employee_statuses
                WHERE id = $1`
        var s entities.EmployeeStatus
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;s.ID, &amp;s.EmployeeID, &amp;s.Status, &amp;s.Reason,
                &amp;s.StartDate, &amp;s.EndDate, &amp;s.IsCurrent,
                &amp;s.CreatedAt, &amp;s.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return entities.EmployeeStatus{}, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return entities.EmployeeStatus{}, err</span>
        }
        <span class="cov0" title="0">return s, nil</span>
}

func (r *employeeStatusPgRepository) FindAllByEmployee(ctx context.Context, employeeID uuid.UUID, limit, offset int) ([]entities.EmployeeStatus, error) <span class="cov0" title="0">{
        query := `
                SELECT id, employee_id, status, reason,
                       start_date, end_date, is_current,
                       created_at, updated_at
                FROM employee_statuses
                WHERE employee_id = $1
                ORDER BY start_date DESC
                LIMIT $2 OFFSET $3`
        rows, err := r.db.QueryContext(ctx, query, employeeID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var list []entities.EmployeeStatus
        for rows.Next() </span><span class="cov0" title="0">{
                var s entities.EmployeeStatus
                if err := rows.Scan(
                        &amp;s.ID, &amp;s.EmployeeID, &amp;s.Status, &amp;s.Reason,
                        &amp;s.StartDate, &amp;s.EndDate, &amp;s.IsCurrent,
                        &amp;s.CreatedAt, &amp;s.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">list = append(list, s)</span>
        }
        <span class="cov0" title="0">return list, nil</span>
}

func (r *employeeStatusPgRepository) Search(ctx context.Context, employeeID *uuid.UUID, statusFilter string, limit, offset int) ([]entities.EmployeeStatus, error) <span class="cov0" title="0">{
        query := `SELECT * FROM search_employee_statuses($1, $2, $3, $4)`
        var empID any
        if employeeID != nil </span><span class="cov0" title="0">{
                empID = *employeeID
        }</span>
        <span class="cov0" title="0">rows, err := r.db.QueryContext(ctx, query, empID, statusFilter, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var list []entities.EmployeeStatus
        for rows.Next() </span><span class="cov0" title="0">{
                var s entities.EmployeeStatus
                if err := rows.Scan(
                        &amp;s.ID, &amp;s.EmployeeID, &amp;s.Status, &amp;s.Reason,
                        &amp;s.StartDate, &amp;s.EndDate, &amp;s.IsCurrent,
                        &amp;s.CreatedAt, &amp;s.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">list = append(list, s)</span>
        }
        <span class="cov0" title="0">return list, nil</span>
}

func (r *employeeStatusPgRepository) ExistsByID(ctx context.Context, id uuid.UUID) (bool, error) <span class="cov0" title="0">{
        query := `SELECT EXISTS(SELECT 1 FROM employee_statuses WHERE id = $1)`
        var exists bool
        err := r.db.QueryRowContext(ctx, query, id).Scan(&amp;exists)
        return exists, err
}</span>

var _ repos.EmployeeStatusRepository = (*employeeStatusPgRepository)(nil)
</pre>
		
		<pre class="file" id="file59" style="display: none">package persistence

import (
        "context"
        "database/sql"
        "errors"

        "rhapp/internal/domain/dtos"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type municipalityPgRepository struct {
        db *sql.DB
}

func NewMunicipalityPgRepository(db *sql.DB) *municipalityPgRepository <span class="cov0" title="0">{
        return &amp;municipalityPgRepository{db: db}
}</span>

func (r *municipalityPgRepository) Create(ctx context.Context, m entities.Municipality) error <span class="cov0" title="0">{
        const query = `
                INSERT INTO municipalities (id, name, province_id, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5)`
        _, err := r.db.ExecContext(ctx, query, m.ID, m.Name.String(), m.ProvinceID, m.CreatedAt, m.UpdatedAt)
        return err
}</span>

func (r *municipalityPgRepository) Update(ctx context.Context, m entities.Municipality) error <span class="cov0" title="0">{
        const query = `
                UPDATE municipalities
                SET name = $1, province_id = $2, updated_at = $3
                WHERE id = $4`
        res, err := r.db.ExecContext(ctx, query, m.Name.String(), m.ProvinceID, m.UpdatedAt, m.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows, _ := res.RowsAffected(); rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *municipalityPgRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        const query = `DELETE FROM municipalities WHERE id = $1`
        res, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows, _ := res.RowsAffected(); rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *municipalityPgRepository) FindByID(ctx context.Context, id uuid.UUID) (entities.Municipality, error) <span class="cov0" title="0">{
        const query = `
                SELECT id, name, province_id, created_at, updated_at
                FROM municipalities
                WHERE id = $1`
        var m entities.Municipality
        var name string
        err := r.db.QueryRowContext(ctx, query, id).Scan(&amp;m.ID, &amp;name, &amp;m.ProvinceID, &amp;m.CreatedAt, &amp;m.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return entities.Municipality{}, err
                }</span>
                <span class="cov0" title="0">return entities.Municipality{}, err</span>
        }
        <span class="cov0" title="0">v, err := vos.NewMunicipality(name)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Municipality{}, err
        }</span>
        <span class="cov0" title="0">m.Name = v
        return m, nil</span>
}

func (r *municipalityPgRepository) FindAll(ctx context.Context, limit, offset int) ([]entities.Municipality, error) <span class="cov0" title="0">{
        const query = `
                SELECT id, name, province_id, created_at, updated_at
                FROM municipalities
                ORDER BY name ASC
                LIMIT $1 OFFSET $2`
        rows, err := r.db.QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var list []entities.Municipality
        for rows.Next() </span><span class="cov0" title="0">{
                var m entities.Municipality
                var name string
                if err := rows.Scan(&amp;m.ID, &amp;name, &amp;m.ProvinceID, &amp;m.CreatedAt, &amp;m.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">v, err := vos.NewMunicipality(name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">m.Name = v
                list = append(list, m)</span>
        }
        <span class="cov0" title="0">return list, nil</span>
}

func (r *municipalityPgRepository) Search(ctx context.Context, searchText, provinceFilter string, limit, offset int) ([]dtos.MunicipioResultDTO, error) <span class="cov0" title="0">{
        rows, err := r.db.QueryContext(ctx, `SELECT * FROM search_municipalities($1, $2, $3, $4)`, searchText, provinceFilter, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []dtos.MunicipioResultDTO
        for rows.Next() </span><span class="cov0" title="0">{
                var dto dtos.MunicipioResultDTO
                if err := rows.Scan(&amp;dto.ID, &amp;dto.Name, &amp;dto.ProvinciaID, &amp;dto.ProvinciaName, &amp;dto.CreatedAt, &amp;dto.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">results = append(results, dto)</span>
        }
        <span class="cov0" title="0">return results, nil</span>
}

func (r *municipalityPgRepository) ExistsByID(ctx context.Context, id uuid.UUID) (bool, error) <span class="cov0" title="0">{
        const query = `SELECT EXISTS (SELECT 1 FROM municipalities WHERE id = $1)`
        var exists bool
        err := r.db.QueryRowContext(ctx, query, id).Scan(&amp;exists)
        return exists, err
}</span>

func (r *municipalityPgRepository) ExistsByNameAndProvince(ctx context.Context, name string, provinceID uuid.UUID) (bool, error) <span class="cov0" title="0">{
        const query = `
                SELECT EXISTS (
                        SELECT 1 FROM municipalities
                        WHERE LOWER(name) = LOWER($1) AND province_id = $2)`
        var exists bool
        err := r.db.QueryRowContext(ctx, query, name, provinceID).Scan(&amp;exists)
        return exists, err
}</span>

var _ repos.MunicipalityRepository = (*municipalityPgRepository)(nil)
</pre>
		
		<pre class="file" id="file60" style="display: none">package persistence

import (
        "context"
        "database/sql"
        "errors"

        "rhapp/internal/domain/dtos"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type positionPgRepository struct {
        db *sql.DB
}

func NewPositionPgRepository(db *sql.DB) *positionPgRepository <span class="cov0" title="0">{
        return &amp;positionPgRepository{db: db}
}</span>

func (r *positionPgRepository) Create(ctx context.Context, pos entities.Position) error <span class="cov0" title="0">{
        const query = `
                INSERT INTO positions (id, name, department_id, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5)`
        _, err := r.db.ExecContext(ctx, query,
                pos.ID, pos.Name, pos.DepartmentID, pos.CreatedAt, pos.UpdatedAt)
        return err
}</span>

func (r *positionPgRepository) Update(ctx context.Context, pos entities.Position) error <span class="cov0" title="0">{
        const query = `
                UPDATE positions SET name = $1, department_id = $2, updated_at = $3
                WHERE id = $4`
        res, err := r.db.ExecContext(ctx, query,
                pos.Name, pos.DepartmentID, pos.UpdatedAt, pos.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows, _ := res.RowsAffected(); rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *positionPgRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        const query = `DELETE FROM positions WHERE id = $1`
        res, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows, _ := res.RowsAffected(); rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *positionPgRepository) FindByID(ctx context.Context, id uuid.UUID) (entities.Position, error) <span class="cov0" title="0">{
        const query = `
                SELECT id, name, department_id, created_at, updated_at
                FROM positions WHERE id = $1`
        var pos entities.Position
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;pos.ID, &amp;pos.Name, &amp;pos.DepartmentID, &amp;pos.CreatedAt, &amp;pos.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return entities.Position{}, err
                }</span>
                <span class="cov0" title="0">return entities.Position{}, err</span>
        }
        <span class="cov0" title="0">return pos, nil</span>
}

func (r *positionPgRepository) FindAll(ctx context.Context, limit, offset int) ([]entities.Position, error) <span class="cov0" title="0">{
        const query = `
                SELECT id, name, department_id, created_at, updated_at
                FROM positions ORDER BY created_at DESC LIMIT $1 OFFSET $2`
        rows, err := r.db.QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var result []entities.Position
        for rows.Next() </span><span class="cov0" title="0">{
                var pos entities.Position
                if err := rows.Scan(&amp;pos.ID, &amp;pos.Name, &amp;pos.DepartmentID, &amp;pos.CreatedAt, &amp;pos.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result = append(result, pos)</span>
        }
        <span class="cov0" title="0">return result, nil</span>
}

func (r *positionPgRepository) Search(ctx context.Context, searchText, departmentFilter string, limit, offset int) ([]dtos.PositionResultDTO, error) <span class="cov0" title="0">{
        const query = `SELECT * FROM search_positions($1, $2, $3, $4)`
        rows, err := r.db.QueryContext(ctx, query, searchText, departmentFilter, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []dtos.PositionResultDTO
        for rows.Next() </span><span class="cov0" title="0">{
                var dto dtos.PositionResultDTO
                if err := rows.Scan(
                        &amp;dto.ID, &amp;dto.Name, &amp;dto.DepartmentID, &amp;dto.DepartmentName, &amp;dto.CreatedAt, &amp;dto.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">results = append(results, dto)</span>
        }
        <span class="cov0" title="0">return results, nil</span>
}

func (r *positionPgRepository) ExistsByID(ctx context.Context, id uuid.UUID) (bool, error) <span class="cov0" title="0">{
        const query = `SELECT EXISTS (SELECT 1 FROM positions WHERE id = $1)`
        var exists bool
        err := r.db.QueryRowContext(ctx, query, id).Scan(&amp;exists)
        return exists, err
}</span>

func (r *positionPgRepository) ExistsByNameAndDepartment(ctx context.Context, name string, departmentID uuid.UUID) (bool, error) <span class="cov0" title="0">{
        const query = `
                SELECT EXISTS (
                        SELECT 1 FROM positions 
                        WHERE LOWER(name) = LOWER($1) AND department_id = $2
                )`
        var exists bool
        err := r.db.QueryRowContext(ctx, query, name, departmentID).Scan(&amp;exists)
        return exists, err
}</span>

var _ repos.PositionRepository = (*positionPgRepository)(nil)
</pre>
		
		<pre class="file" id="file61" style="display: none">package persistence

import (
        "context"
        "database/sql"
        "errors"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type provincePgRepository struct {
        db *sql.DB
}

func NewProvincePgRepository(db *sql.DB) *provincePgRepository <span class="cov8" title="1">{
        return &amp;provincePgRepository{db: db}
}</span>

func (r *provincePgRepository) Create(ctx context.Context, p entities.Province) error <span class="cov8" title="1">{
        query := `INSERT INTO provinces (id, nome, created_at, updated_at) VALUES ($1, $2, $3, $4)`
        _, err := r.db.ExecContext(ctx, query, p.ID, p.Nome.String(), p.CreatedAt, p.UpdatedAt)
        return err
}</span>

func (r *provincePgRepository) Update(ctx context.Context, p entities.Province) error <span class="cov8" title="1">{
        query := `UPDATE provinces SET nome = $1, updated_at = $2 WHERE id = $3`
        res, err := r.db.ExecContext(ctx, query, p.Nome.String(), p.UpdatedAt, p.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if rows, _ := res.RowsAffected(); rows == 0 </span><span class="cov8" title="1">{
                return sql.ErrNoRows
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *provincePgRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        query := `DELETE FROM provinces WHERE id = $1`
        res, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if rows, _ := res.RowsAffected(); rows == 0 </span><span class="cov8" title="1">{
                return sql.ErrNoRows
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *provincePgRepository) FindByID(ctx context.Context, id uuid.UUID) (entities.Province, error) <span class="cov8" title="1">{
        query := `SELECT id, nome, created_at, updated_at FROM provinces WHERE id = $1`
        var p entities.Province
        var nome string

        err := r.db.QueryRowContext(ctx, query, id).Scan(&amp;p.ID, &amp;nome, &amp;p.CreatedAt, &amp;p.UpdatedAt)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return entities.Province{}, err
                }</span>
                <span class="cov8" title="1">return entities.Province{}, err</span>
        }

        <span class="cov8" title="1">v := vos.NewProvince(nome)
        p.Nome = v
        return p, nil</span>
}

func (r *provincePgRepository) FindAll(ctx context.Context, limit, offset int) ([]entities.Province, error) <span class="cov8" title="1">{
        query := `SELECT id, nome, created_at, updated_at FROM provinces ORDER BY nome ASC LIMIT $1 OFFSET $2`
        rows, err := r.db.QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var list []entities.Province
        for rows.Next() </span><span class="cov8" title="1">{
                var p entities.Province
                var nome string
                if err := rows.Scan(&amp;p.ID, &amp;nome, &amp;p.CreatedAt, &amp;p.UpdatedAt); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">v := vos.NewProvince(nome)
                p.Nome = v
                list = append(list, p)</span>
        }
        <span class="cov8" title="1">return list, nil</span>
}

func (r *provincePgRepository) ExistsByID(ctx context.Context, id uuid.UUID) (bool, error) <span class="cov8" title="1">{
        query := `SELECT EXISTS (SELECT 1 FROM provinces WHERE id = $1)`
        var exists bool
        err := r.db.QueryRowContext(ctx, query, id).Scan(&amp;exists)
        return exists, err
}</span>

func (r *provincePgRepository) ExistsByNome(ctx context.Context, nome string) (bool, error) <span class="cov8" title="1">{
        query := `SELECT EXISTS (SELECT 1 FROM provinces WHERE LOWER(nome) = LOWER($1))`
        var exists bool
        err := r.db.QueryRowContext(ctx, query, nome).Scan(&amp;exists)
        return exists, err
}</span>

func (r *provincePgRepository) Search(ctx context.Context, searchText, _ string, limit, offset int) ([]entities.Province, error) <span class="cov8" title="1">{
        rows, err := r.db.QueryContext(ctx, `SELECT * FROM search_provinces($1, $2, $3)`, searchText, limit, offset)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var results []entities.Province
        for rows.Next() </span><span class="cov8" title="1">{
                var p entities.Province
                var nome string
                if err := rows.Scan(&amp;p.ID, &amp;nome, &amp;p.CreatedAt, &amp;p.UpdatedAt); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">v := vos.NewProvince(nome)
                p.Nome = v
                results = append(results, p)</span>
        }
        <span class="cov8" title="1">return results, nil</span>
}

var _ repos.ProvinceRepository = (*provincePgRepository)(nil)
</pre>
		
		<pre class="file" id="file62" style="display: none">package persistence

import (
        "context"
        "database/sql"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type supervisorPgRepository struct {
        db *sql.DB
}

func NewSupervisorPgRepository(db *sql.DB) *supervisorPgRepository <span class="cov0" title="0">{
        return &amp;supervisorPgRepository{db: db}
}</span>

func (r *supervisorPgRepository) Create(ctx context.Context, s entities.SupervisorHistory) error <span class="cov0" title="0">{
        query := `
                INSERT INTO supervisor_histories (
                        id, employee_id, supervisor_id, start_date, end_date, created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, NOW(), NOW())
        `
        _, err := r.db.ExecContext(ctx, query,
                s.ID, s.EmployeeID, s.SupervisorID, s.StartDate, s.EndDate,
        )
        return err
}</span>

func (r *supervisorPgRepository) FindByID(ctx context.Context, id uuid.UUID) (*entities.SupervisorHistory, error) <span class="cov0" title="0">{
        query := `
                SELECT id, employee_id, supervisor_id, start_date, end_date, created_at, updated_at
                FROM supervisor_histories
                WHERE id = $1
        `
        var s entities.SupervisorHistory
        var supervisorID sql.NullString

        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;s.ID, &amp;s.EmployeeID, &amp;supervisorID, &amp;s.StartDate, &amp;s.EndDate, &amp;s.CreatedAt, &amp;s.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if supervisorID.Valid </span><span class="cov0" title="0">{
                sid, err := uuid.Parse(supervisorID.String)
                if err == nil </span><span class="cov0" title="0">{
                        s.SupervisorID = &amp;sid
                }</span>
        }

        <span class="cov0" title="0">return &amp;s, nil</span>
}

func (r *supervisorPgRepository) Update(ctx context.Context, s entities.SupervisorHistory) error <span class="cov0" title="0">{
        query := `
                UPDATE supervisor_histories
                SET employee_id = $2, supervisor_id = $3, start_date = $4, end_date = $5, updated_at = NOW()
                WHERE id = $1
        `
        _, err := r.db.ExecContext(ctx, query,
                s.ID, s.EmployeeID, s.SupervisorID, s.StartDate, s.EndDate,
        )
        return err
}</span>

func (r *supervisorPgRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        query := `DELETE FROM supervisor_histories WHERE id = $1`
        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows, _ := result.RowsAffected()
        if rows == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *supervisorPgRepository) ListByEmployeeID(ctx context.Context, employeeID uuid.UUID, limit, offset int) ([]entities.SupervisorHistory, error) <span class="cov0" title="0">{
        query := `
                SELECT id, employee_id, supervisor_id, start_date, end_date, created_at, updated_at
                FROM supervisor_histories
                WHERE employee_id = $1
                ORDER BY start_date DESC
                LIMIT $2 OFFSET $3
        `
        rows, err := r.db.QueryContext(ctx, query, employeeID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var list []entities.SupervisorHistory
        for rows.Next() </span><span class="cov0" title="0">{
                var s entities.SupervisorHistory
                var supervisorID sql.NullString

                if err := rows.Scan(
                        &amp;s.ID, &amp;s.EmployeeID, &amp;supervisorID, &amp;s.StartDate, &amp;s.EndDate, &amp;s.CreatedAt, &amp;s.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if supervisorID.Valid </span><span class="cov0" title="0">{
                        sid, err := uuid.Parse(supervisorID.String)
                        if err == nil </span><span class="cov0" title="0">{
                                s.SupervisorID = &amp;sid
                        }</span>
                }
                <span class="cov0" title="0">list = append(list, s)</span>
        }
        <span class="cov0" title="0">return list, nil</span>
}

var _ repos.SupervisorHistoryRepository = (*supervisorPgRepository)(nil)
</pre>
		
		<pre class="file" id="file63" style="display: none">package persistence

import (
        "context"
        "database/sql"
        "fmt"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type workHistoryPgRepository struct {
        db *sql.DB
}

func NewWorkHistoryPgRepository(db *sql.DB) repos.WorkHistoryRepository <span class="cov0" title="0">{
        return &amp;workHistoryPgRepository{db: db}
}</span>

func (r *workHistoryPgRepository) Create(ctx context.Context, wh entities.WorkHistory) error <span class="cov0" title="0">{
        query := `
                INSERT INTO work_histories (
                        id, employee_id, company, position, start_date, end_date, responsibilities, created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW(), NOW())
        `
        _, err := r.db.ExecContext(ctx, query,
                wh.ID, wh.EmployeeID, wh.Company, wh.Position,
                wh.StartDate, wh.EndDate, wh.Responsibilities,
        )
        return err
}</span>

func (r *workHistoryPgRepository) Update(ctx context.Context, wh entities.WorkHistory) error <span class="cov0" title="0">{
        query := `
                UPDATE work_histories SET
                        company = $1, position = $2, start_date = $3, end_date = $4,
                        responsibilities = $5, updated_at = NOW()
                WHERE id = $6
        `
        _, err := r.db.ExecContext(ctx, query,
                wh.Company, wh.Position, wh.StartDate, wh.EndDate,
                wh.Responsibilities, wh.ID,
        )
        return err
}</span>

func (r *workHistoryPgRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := r.db.ExecContext(ctx, `DELETE FROM work_histories WHERE id = $1`, id)
        return err
}</span>

func (r *workHistoryPgRepository) FindByID(ctx context.Context, id uuid.UUID) (entities.WorkHistory, error) <span class="cov0" title="0">{
        query := `
                SELECT id, employee_id, company, position, start_date, end_date,
                       responsibilities, created_at, updated_at
                FROM work_histories WHERE id = $1
        `
        var wh entities.WorkHistory
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;wh.ID, &amp;wh.EmployeeID, &amp;wh.Company, &amp;wh.Position,
                &amp;wh.StartDate, &amp;wh.EndDate, &amp;wh.Responsibilities,
                &amp;wh.CreatedAt, &amp;wh.UpdatedAt,
        )
        return wh, err
}</span>

func (r *workHistoryPgRepository) ListByEmployee(ctx context.Context, employeeID uuid.UUID, limit, offset int) ([]entities.WorkHistory, error) <span class="cov0" title="0">{
        query := `
                SELECT id, employee_id, company, position, start_date, end_date,
                       responsibilities, created_at, updated_at
                FROM work_histories
                WHERE employee_id = $1
                ORDER BY start_date DESC
                LIMIT $2 OFFSET $3
        `
        rows, err := r.db.QueryContext(ctx, query, employeeID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var list []entities.WorkHistory
        for rows.Next() </span><span class="cov0" title="0">{
                var wh entities.WorkHistory
                if err := rows.Scan(
                        &amp;wh.ID, &amp;wh.EmployeeID, &amp;wh.Company, &amp;wh.Position,
                        &amp;wh.StartDate, &amp;wh.EndDate, &amp;wh.Responsibilities,
                        &amp;wh.CreatedAt, &amp;wh.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">list = append(list, wh)</span>
        }
        <span class="cov0" title="0">return list, nil</span>
}

func (r *workHistoryPgRepository) Search(ctx context.Context, employeeID uuid.UUID, searchText string, startDate, endDate *string, limit, offset int) ([]entities.WorkHistory, error) <span class="cov0" title="0">{
        query := `
                SELECT id, employee_id, company, position, start_date, end_date,
                       responsibilities, created_at, updated_at
                FROM work_histories
                WHERE employee_id = $1
                AND (LOWER(company) LIKE LOWER($2))
        `
        params := []interface{}{employeeID, "%" + searchText + "%"}
        paramIndex := 3

        if startDate != nil </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND start_date &gt;= $%d", paramIndex)
                params = append(params, *startDate)
                paramIndex++
        }</span>
        <span class="cov0" title="0">if endDate != nil </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND end_date &lt;= $%d", paramIndex)
                params = append(params, *endDate)
                paramIndex++
        }</span>
        <span class="cov0" title="0">query += fmt.Sprintf(" ORDER BY start_date DESC LIMIT $%d OFFSET $%d", paramIndex, paramIndex+1)
        params = append(params, limit, offset)

        rows, err := r.db.QueryContext(ctx, query, params...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var list []entities.WorkHistory
        for rows.Next() </span><span class="cov0" title="0">{
                var wh entities.WorkHistory
                if err := rows.Scan(
                        &amp;wh.ID, &amp;wh.EmployeeID, &amp;wh.Company, &amp;wh.Position,
                        &amp;wh.StartDate, &amp;wh.EndDate, &amp;wh.Responsibilities,
                        &amp;wh.CreatedAt, &amp;wh.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">list = append(list, wh)</span>
        }
        <span class="cov0" title="0">return list, nil</span>
}

var _ repos.WorkHistoryRepository = (*workHistoryPgRepository)(nil)
</pre>
		
		<pre class="file" id="file64" style="display: none">package postgresdb

import (
        "database/sql"
        "log"
        "os"
        "time"

        _ "github.com/lib/pq"
)

var DB *sql.DB

func InitPostgres() <span class="cov0" title="0">{
        dbURL := os.Getenv("DB_URL")
        if dbURL == "" </span><span class="cov0" title="0">{
                dbURL = "postgres://postgres:postgres@localhost:5432/hrms?sslmode=disable"
        }</span>

        <span class="cov0" title="0">var err error
        DB, err = sql.Open("postgres", dbURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("❌ Erro ao conectar ao PostgreSQL: %v", err)
        }</span>

        <span class="cov0" title="0">DB.SetMaxOpenConns(25)
        DB.SetMaxIdleConns(25)
        DB.SetConnMaxLifetime(5 * time.Minute)

        if err := DB.Ping(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("❌ PostgreSQL não responde: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("✅ Conectado ao PostgreSQL com sucesso")</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package redisdb

import (
        "context"
        "log"
        "os"

        "github.com/redis/go-redis/v9"
)

var (
        Client *redis.Client
        Ctx    = context.Background()
)

func InitRedis() <span class="cov0" title="0">{
        addr := os.Getenv("REDIS_ADDR")
        if addr == "" </span><span class="cov0" title="0">{
                addr = "localhost:6379"
        }</span>

        <span class="cov0" title="0">password := os.Getenv("REDIS_PASSWORD") // vazio por padrão
        db := 0

        Client = redis.NewClient(&amp;redis.Options{
                Addr:     addr,
                Password: password,
                DB:       db,
        })

        if _, err := Client.Ping(Ctx).Result(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Erro ao conectar ao Redis: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("✅ Redis conectado com sucesso")</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package handlers

import (
        "net/http"

        "rhapp/internal/domain/vos"
        "rhapp/internal/usecase/agregados"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type AgregadosHandler struct {
        EmployeeAggUC *agregados.GetEmployeeAggregateByIDUseCase
        DocumentAggUC *agregados.GetDocumentsByOwnerUseCase
        LocationAggUC *agregados.GetLocationByProvinceIDUseCase
        OrgAggUC      *agregados.GetOrgStructureByDepartmentUseCase
}

func NewAgregadosHandler(
        empUC *agregados.GetEmployeeAggregateByIDUseCase,
        docUC *agregados.GetDocumentsByOwnerUseCase,
        locUC *agregados.GetLocationByProvinceIDUseCase,
        orgUC *agregados.GetOrgStructureByDepartmentUseCase,
) *AgregadosHandler <span class="cov0" title="0">{
        return &amp;AgregadosHandler{
                EmployeeAggUC: empUC,
                DocumentAggUC: docUC,
                LocationAggUC: locUC,
                OrgAggUC:      orgUC,
        }
}</span>

// GetEmployeeAggregate godoc
// @Summary      Buscar dados completos de um funcionário
// @Tags         Agregados
// @Produce      json
// @Param        id   path      string  true  "ID do Funcionário"
// @Success      200  {object}  agregados.EmployeeAggregate
// @Failure      400,404,500  {object}  gin.H
// @Router       /employees/{id}/aggregate [get]
func (h *AgregadosHandler) GetEmployeeAggregate(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">agg, err := h.EmployeeAggUC.Execute(c.Request.Context(), agregados.GetEmployeeAggregateInput{ID: id})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, agg)</span>
}

// GetDocumentsByOwner godoc
// @Summary      Buscar documentos por proprietário
// @Tags         Agregados
// @Produce      json
// @Param        owner_type  query     string  true  "employee ou dependent"
// @Param        owner_id    query     string  true  "UUID do proprietário"
// @Success      200  {object}  agregados.DocumentAggregate
// @Failure      400,404,500  {object}  gin.H
// @Router       /documents/aggregate [get]
func (h *AgregadosHandler) GetDocumentsByOwner(c *gin.Context) <span class="cov0" title="0">{
        ownerType := c.Query("owner_type")
        ownerIDStr := c.Query("owner_id")

        ownerID, err := uuid.Parse(ownerIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID do proprietário inválido"})
                return
        }</span>

        <span class="cov0" title="0">agg, err := h.DocumentAggUC.Execute(c.Request.Context(), agregados.GetDocumentsByOwnerInput{
                OwnerType: vos.DocumentOwnerType(ownerType),
                OwnerID:   ownerID,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, agg)</span>
}

// GetLocationAggregate godoc
// @Summary      Buscar província com municípios e distritos
// @Tags         Agregados
// @Produce      json
// @Param        id   path      string  true  "ID da Província"
// @Success      200  {object}  agregados.LocationAggregate
// @Failure      400,404,500  {object}  gin.H
// @Router       /provinces/{id}/aggregate [get]
func (h *AgregadosHandler) GetLocationAggregate(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">agg, err := h.LocationAggUC.Execute(c.Request.Context(), agregados.GetLocationByProvinceInput{ProvinceID: id})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, agg)</span>
}

// GetOrgStructureAggregate godoc
// @Summary      Buscar departamento com posições e funcionários
// @Tags         Agregados
// @Produce      json
// @Param        id   path      string  true  "ID do Departamento"
// @Success      200  {object}  agregados.OrgStructureAggregate
// @Failure      400,404,500  {object}  gin.H
// @Router       /departments/{id}/aggregate [get]
func (h *AgregadosHandler) GetOrgStructureAggregate(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">agg, err := h.OrgAggUC.Execute(c.Request.Context(), agregados.GetOrgStructureByDepartmentInput{DepartmentID: id})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, agg)</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package handlers

import (
        "net/http"
        "rhapp/internal/domain/dtos"
        "rhapp/internal/usecase/areas_estudo"
        "rhapp/internal/utils"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type AreaEstudoHandler struct {
        CreateUC *areas_estudo.CreateAreaEstudoUseCase
        UpdateUC *areas_estudo.UpdateAreaEstudoUseCase
        DeleteUC *areas_estudo.DeleteAreaEstudoUseCase
        GetUC    *areas_estudo.GetAreaEstudoByIDUseCase
        ListUC   *areas_estudo.ListAllAreasEstudoUseCase
}

func NewAreaEstudoHandler(
        createUC *areas_estudo.CreateAreaEstudoUseCase,
        updateUC *areas_estudo.UpdateAreaEstudoUseCase,
        deleteUC *areas_estudo.DeleteAreaEstudoUseCase,
        getUC *areas_estudo.GetAreaEstudoByIDUseCase,
        listUC *areas_estudo.ListAllAreasEstudoUseCase,
) *AreaEstudoHandler <span class="cov0" title="0">{
        return &amp;AreaEstudoHandler{
                CreateUC: createUC,
                UpdateUC: updateUC,
                DeleteUC: deleteUC,
                GetUC:    getUC,
                ListUC:   listUC,
        }
}</span>

// Create godoc
// @Summary      Criar nova Área de Estudo
// @Description  Cria uma nova área de estudo com nome e descrição obrigatórios.
// @Tags         Áreas de Estudo
// @Accept       json
// @Produce      json
// @Param        input  body      dtos.CreateAreaEstudoDTO  true  "Dados da Área de Estudo"
// @Success      201    {object}  dtos.AreaEstudoResponseDTO
// @Failure      400    {object}  map[string]interface{}  "Dados inválidos ou campos obrigatórios não preenchidos"
// @Failure      409    {object}  map[string]interface{}  "Área de estudo já existente"
// @Failure      500    {object}  map[string]interface{}  "Erro interno inesperado"
// @Router       /areas-estudo [post]
func (h *AreaEstudoHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        var input dtos.CreateAreaEstudoDTO
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "dados inválidos", "details": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">result, err := h.CreateUC.Execute(c.Request.Context(), areas_estudo.CreateAreaEstudoInput{
                Name:        input.Name,
                Description: input.Description,
        })
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case strings.Contains(err.Error(), "obrigatória"):<span class="cov0" title="0">
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})</span>
                case strings.Contains(err.Error(), "já existe"):<span class="cov0" title="0">
                        c.JSON(http.StatusConflict, gin.H{"error": err.Error()})</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "erro inesperado ao criar área de estudo", "details": err.Error()})</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusCreated, dtos.ToAreaEstudoResponseDTO(result))</span>
}

// Update godoc
// @Summary Atualizar área de estudo
// @Tags Áreas de Estudo
// @Accept json
// @Produce json
// @Param id path string true "ID da área de estudo"
// @Param input body dtos.UpdateAreaEstudoDTO true "Dados atualizados"
// @Success 200 {object} dtos.AreaEstudoResponseDTO
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /areas-estudo/{id} [put]
func (h *AreaEstudoHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>

        <span class="cov0" title="0">var input dtos.UpdateAreaEstudoDTO
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">result, err := h.UpdateUC.Execute(c.Request.Context(), areas_estudo.UpdateAreaEstudoInput{
                ID:          id,
                Name:        input.Name,
                Description: input.Description,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToAreaEstudoResponseDTO(result))</span>
}

// Delete godoc
// @Summary Excluir área de estudo
// @Tags Áreas de Estudo
// @Produce json
// @Param id path string true "ID da área de estudo"
// @Success 204 "Removido com sucesso"
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /areas-estudo/{id} [delete]
func (h *AreaEstudoHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.DeleteUC.Execute(c.Request.Context(), areas_estudo.DeleteAreaEstudoInput{ID: id}); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// GetByID godoc
// @Summary Obter área de estudo por ID
// @Tags Áreas de Estudo
// @Produce json
// @Param id path string true "ID da área de estudo"
// @Success 200 {object} dtos.AreaEstudoResponseDTO
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /areas-estudo/{id} [get]
func (h *AreaEstudoHandler) GetByID(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>

        <span class="cov0" title="0">result, err := h.GetUC.Execute(c.Request.Context(), areas_estudo.GetOneAreaEstudoInput{ID: id})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToAreaEstudoResponseDTO(result))</span>
}

// ListAll godoc
// @Summary Listar todas as áreas de estudo
// @Tags Áreas de Estudo
// @Produce json
// @Success 200 {array} dtos.AreaEstudoResponseDTO
// @Failure 500 {object} map[string]string
// @Router /areas-estudo [get]
func (h *AreaEstudoHandler) ListAll(c *gin.Context) <span class="cov0" title="0">{
        pagination := utils.PaginationInput(c)
        result, err := h.ListUC.Execute(c.Request.Context(), pagination.Limit, pagination.Offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao buscar dados"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToAreaEstudoResponseDTOList(result))</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package handlers

import (
        "context"
        "net/http"
        "rhapp/internal/domain/dtos"
        "rhapp/internal/usecase/departments"
        "rhapp/internal/utils"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type DepartmentHandler struct {
        CreateUC *departments.CreateDepartmentUseCase
        UpdateUC *departments.UpdateDepartmentUseCase
        DeleteUC *departments.DeleteDepartmentUseCase
        GetUC    *departments.FindDepartmentByIDUseCase
        ListUC   *departments.FindAllDepartmentsUseCase
}

func NewDepartmentHandler(
        createUC *departments.CreateDepartmentUseCase,
        updateUC *departments.UpdateDepartmentUseCase,
        deleteUC *departments.DeleteDepartmentUseCase,
        getUC *departments.FindDepartmentByIDUseCase,
        listUC *departments.FindAllDepartmentsUseCase,
) *DepartmentHandler <span class="cov0" title="0">{
        return &amp;DepartmentHandler{
                CreateUC: createUC,
                UpdateUC: updateUC,
                DeleteUC: deleteUC,
                GetUC:    getUC,
                ListUC:   listUC,
        }
}</span>

// Create godoc
// @Summary Criar novo departamento
// @Description Cria um novo departamento com nome único
// @Tags Departamentos
// @Accept json
// @Produce json
// @Param input body dtos.CreateDepartmentDTO true "Dados do departamento"
// @Success 201 {object} dtos.DepartmentResponseDTO
// @Failure 400 {object} map[string]string
// @Failure 409 {object} map[string]string
// @Router /departments [post]
func (h *DepartmentHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        var input dtos.CreateDepartmentDTO
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">result, err := h.CreateUC.Execute(c, departments.CreateDepartmentInput{
                Name: input.Name,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, dtos.ToDepartmentResponseDTO(result))</span>
}

// Update godoc
// @Summary Atualizar departamento
// @Description Atualiza os dados de um departamento existente
// @Tags Departamentos
// @Accept json
// @Produce json
// @Param id path string true "ID do departamento"
// @Param input body dtos.UpdateDepartmentDTO true "Dados atualizados"
// @Success 200 {object} dtos.DepartmentResponseDTO
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /departments/{id} [put]
func (h *DepartmentHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        var input dtos.UpdateDepartmentDTO
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">result, err := h.UpdateUC.Execute(c, departments.UpdateDepartmentInput{
                ID:   id,
                Name: input.Name,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToDepartmentResponseDTO(result))</span>
}

// Delete godoc
// @Summary Remover departamento
// @Description Exclui um departamento existente pelo ID
// @Tags Departamentos
// @Produce json
// @Param id path string true "ID do departamento"
// @Success 204 "No Content"
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /departments/{id} [delete]
func (h *DepartmentHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")

        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if err := h.DeleteUC.Execute(c, departments.DeleteDepartmentInput{ID: id}); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// FindByID godoc
// @Summary Buscar departamento por ID
// @Description Retorna os dados de um departamento específico
// @Tags Departamentos
// @Produce json
// @Param id path string true "ID do departamento"
// @Success 200 {object} dtos.DepartmentResponseDTO
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /departments/{id} [get]
func (h *DepartmentHandler) FindByID(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">result, err := h.GetUC.Execute(c, departments.FindDepartmentByIDInput{ID: id})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToDepartmentResponseDTO(result))</span>
}

// FindAll godoc
// @Summary Listar todos os departamentos
// @Description Retorna uma lista de todos os departamentos cadastrados
// @Tags Departamentos
// @Produce json
// @Success 200 {array} dtos.DepartmentResponseDTO
// @Failure 500 {object} map[string]string
// @Router /departments [get]
func (h *DepartmentHandler) FindAll(c *gin.Context) <span class="cov0" title="0">{
        pagination := utils.PaginationInput(c)
        list, err := h.ListUC.Execute(context.Background(), pagination.Limit, pagination.Offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao listar departamentos"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToDepartmentResponseDTOList(list))</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package handlers

import (
        "context"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "rhapp/internal/domain/dtos"
        "rhapp/internal/usecase/dependents"
        "rhapp/internal/utils"
)

type DependentHandler struct {
        CreateUC *dependents.CreateDependentUseCase
        UpdateUC *dependents.UpdateDependentUseCase
        DeleteUC *dependents.DeleteDependentUseCase
        FindUC   *dependents.FindDependentByIDUseCase
        ListUC   *dependents.ListDependentsUseCase
}

func NewDependentHandler(
        createUC *dependents.CreateDependentUseCase,
        updateUC *dependents.UpdateDependentUseCase,
        deleteUC *dependents.DeleteDependentUseCase,
        getUC *dependents.FindDependentByIDUseCase,
        listUC *dependents.ListDependentsUseCase,
) *DependentHandler <span class="cov0" title="0">{
        return &amp;DependentHandler{
                CreateUC: createUC,
                UpdateUC: updateUC,
                DeleteUC: deleteUC,
                FindUC:   getUC,
                ListUC:   listUC,
        }
}</span>

func (h *DependentHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        var input dtos.CreateDependentDTO
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "dados inválidos: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">employeeID, err := uuid.Parse(input.EmployeeID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "UUID de funcionário inválido"})
                return
        }</span>

        <span class="cov0" title="0">result, err := h.CreateUC.Execute(c.Request.Context(), dependents.CreateDependentInput{
                EmployeeID:   employeeID,
                FullName:     input.FullName,
                Relationship: input.Relationship,
                Gender:       input.Gender,
                DateOfBirth:  input.DateOfBirth,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, dtos.ToDependentResponseDTO(result))</span>
}

// @Summary Atualizar dependente
// @Tags Dependentes
// @Accept json
// @Produce json
// @Param id path string true "ID do dependente"
// @Param input body dtos.UpdateDependentDTO true "Dados do dependente"
// @Success 200 {object} dtos.DependentResponseDTO
// @Failure 400,404 {object} gin.H
// @Router /dependents/{id} [put]
func (h *DependentHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>

        <span class="cov0" title="0">var input dtos.UpdateDependentDTO
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">updated, err := h.UpdateUC.Execute(c.Request.Context(), dependents.UpdateDependentInput{
                ID:           id,
                FullName:     input.FullName,
                Relationship: input.Relationship,
                Gender:       input.Gender,
                DateOfBirth:  input.DateOfBirth,
                IsActive:     input.IsActive,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToDependentResponseDTO(updated))</span>
}

// @Summary Deletar dependente
// @Tags Dependentes
// @Produce json
// @Param id path string true "ID do dependente"
// @Success 204 {object} nil
// @Failure 404 {object} gin.H
// @Router /dependents/{id} [delete]
func (h *DependentHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.DeleteUC.Execute(context.Background(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// @Summary Buscar dependente por ID
// @Tags Dependentes
// @Produce json
// @Param id path string true "ID do dependente"
// @Success 200 {object} dtos.DependentResponseDTO
// @Failure 404 {object} gin.H
// @Router /dependents/{id} [get]
func (h *DependentHandler) FindByID(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>

        <span class="cov0" title="0">d, err := h.FindUC.Execute(context.Background(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToDependentResponseDTO(d))</span>
}

// @Summary Listar dependentes
// @Tags Dependentes
// @Produce json
// @Param limit query int false "Limite"
// @Param offset query int false "Offset"
// @Success 200 {array} dtos.DependentResponseDTO
// @Router /dependents [get]
func (h *DependentHandler) List(c *gin.Context) <span class="cov0" title="0">{
        pagination := utils.PaginationInput(c)
        list, err := h.ListUC.Execute(c.Request.Context(), pagination.Limit, pagination.Offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToDependentResponseDTOList(list))</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package handlers

import (
        "context"
        "net/http"
        "rhapp/internal/domain/dtos"
        "rhapp/internal/usecase/distritos"
        "rhapp/internal/utils"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type DistrictHandler struct {
        CreateUC   *distritos.CreateDistrictUseCase
        UpdateUC   *distritos.UpdateDistrictUseCase
        DeleteUC   *distritos.DeleteDistrictUseCase
        FindByIDUC *distritos.FindDistrictByIDUseCase
        ListUC     *distritos.ListAllDistrictsUseCase
}

func NewDistrictHandler(
        createUC *distritos.CreateDistrictUseCase,
        updateUC *distritos.UpdateDistrictUseCase,
        deleteUC *distritos.DeleteDistrictUseCase,
        findByIDUC *distritos.FindDistrictByIDUseCase,
        listUC *distritos.ListAllDistrictsUseCase,
) *DistrictHandler <span class="cov0" title="0">{
        return &amp;DistrictHandler{
                CreateUC:   createUC,
                UpdateUC:   updateUC,
                DeleteUC:   deleteUC,
                FindByIDUC: findByIDUC,
                ListUC:     listUC,
        }
}</span>

// CreateDistrict godoc
// @Summary Cria um novo distrito
// @Description Registra um novo distrito associado a um município
// @Tags Distritos
// @Accept json
// @Produce json
// @Param input body dtos.CreateDistritoDTO true "Dados do distrito"
// @Success 201 {object} dtos.DistritoResponseDTO
// @Failure 400 {object} map[string]string
// @Failure 409 {object} map[string]string
// @Router /districts [post]
func (h *DistrictHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        var input dtos.CreateDistritoDTO
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">idMun, err := uuid.Parse(input.MunicipioID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">entity, err := h.CreateUC.Execute(context.Background(), distritos.CreateDistrictInput{
                Name:        input.Name,
                MunicipioID: idMun,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusCreated, dtos.ToDistritoResponseDTO(entity))</span>
}

// UpdateDistrict godoc
// @Summary Atualiza os dados de um distrito
// @Description Modifica o nome e/ou município de um distrito existente
// @Tags Distritos
// @Accept json
// @Produce json
// @Param id path string true "ID do distrito"
// @Param input body dtos.UpdateDistritoDTO true "Dados atualizados"
// @Success 200 {object} dtos.DistritoResponseDTO
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /districts/{id} [put]
func (h *DistrictHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>

        <span class="cov0" title="0">var input dtos.UpdateDistritoDTO
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">idMun, err := uuid.Parse(input.MunicipioID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">entity, err := h.UpdateUC.Execute(context.Background(), distritos.UpdateDistrictInput{
                ID:          id,
                Name:        input.Name,
                MunicipioID: idMun,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToDistritoResponseDTO(entity))</span>
}

// DeleteDistrict godoc
// @Summary Remove um distrito
// @Description Exclui um distrito pelo ID
// @Tags Distritos
// @Produce json
// @Param id path string true "ID do distrito"
// @Success 204 "No Content"
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /districts/{id} [delete]
func (h *DistrictHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">if err := h.DeleteUC.Execute(context.Background(), distritos.DeleteDistrictInput{ID: id}); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// GetDistrictByID godoc
// @Summary Busca um distrito pelo ID
// @Description Retorna os dados de um distrito específico
// @Tags Distritos
// @Produce json
// @Param id path string true "ID do distrito"
// @Success 200 {object} dtos.DistritoResponseDTO
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /districts/{id} [get]
func (h *DistrictHandler) FindByID(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">entity, err := h.FindByIDUC.Execute(context.Background(), distritos.FindDistrictByIDInput{ID: id})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToDistritoResponseDTO(entity))</span>
}

// ListDistricts godoc
// @Summary Lista todos os distritos
// @Description Retorna uma lista com todos os distritos cadastrados
// @Tags Distritos
// @Produce json
// @Success 200 {array} dtos.DistritoResponseDTO
// @Failure 500 {object} map[string]string
// @Router /districts [get]
func (h *DistrictHandler) List(c *gin.Context) <span class="cov0" title="0">{
        pagination := utils.PaginationInput(c)
        entities, err := h.ListUC.Execute(context.Background(), pagination.Limit, pagination.Offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToDistritoResponseDTOList(entities))</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package handlers

import (
        "net/http"

        "rhapp/internal/domain/dtos"
        "rhapp/internal/usecase/documents_uc"
        "rhapp/internal/utils"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type DocumentHandler struct {
        CreateUC *documents_uc.CreateDocumentUseCase
        UpdateUC *documents_uc.UpdateDocumentUseCase
        DeleteUC *documents_uc.DeleteDocumentUseCase
        ListUC   *documents_uc.ListDocumentsUseCase
        FindUC   *documents_uc.FindDocumentByIDUseCase
}

func NewDocumentHandler(
        createUC *documents_uc.CreateDocumentUseCase,
        updateUC *documents_uc.UpdateDocumentUseCase,
        deleteUC *documents_uc.DeleteDocumentUseCase,
        findOneUC *documents_uc.FindDocumentByIDUseCase,
        findAllUC *documents_uc.ListDocumentsUseCase,
) *DocumentHandler <span class="cov0" title="0">{
        return &amp;DocumentHandler{
                CreateUC: createUC,
                UpdateUC: updateUC,
                DeleteUC: deleteUC,
                FindUC:   findOneUC,
                ListUC:   findAllUC,
        }
}</span>

func (h *DocumentHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        var input documents_uc.CreateDocumentInput
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">doc, err := h.CreateUC.Execute(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, dtos.ToDocumentResponseDTO(doc))</span>
}

// @Summary Buscar Documento por ID
// @Tags Documentos
// @Produce json
// @Param id path string true "ID do documento"
// @Success 200 {object} dtos.DocumentResponseDTO
// @Failure 404 {object} gin.H
// @Router /documents/{id} [get]
func (h *DocumentHandler) FindByID(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>

        <span class="cov0" title="0">doc, err := h.FindUC.Execute(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Documento não encontrado"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToDocumentResponseDTO(doc))</span>
}

// @Summary Listar Documentos
// @Tags Documentos
// @Produce json
// @Param limit query int false "Limite"
// @Param offset query int false "Offset"
// @Success 200 {array} dtos.DocumentResponseDTO
// @Router /documents [get]
func (h *DocumentHandler) List(c *gin.Context) <span class="cov0" title="0">{
        pagination := utils.PaginationInput(c)

        list, err := h.ListUC.Execute(c.Request.Context(), pagination.Limit, pagination.Offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToDocumentResponseDTOList(list))</span>
}

// @Summary Atualizar Documento
// @Tags Documentos
// @Accept json
// @Produce json
// @Param id path string true "ID do documento"
// @Param data body dtos.UpdateDocumentDTO true "Dados atualizados"
// @Success 200 {object} dtos.DocumentResponseDTO
// @Failure 400 {object} gin.H
// @Failure 404 {object} gin.H
// @Router /documents/{id} [put]
func (h *DocumentHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>

        <span class="cov0" title="0">var input dtos.UpdateDocumentDTO
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">doc, err := h.UpdateUC.Execute(c.Request.Context(), documents_uc.UpdateDocumentInput{
                ID:          id,
                DocumentDTO: input,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToDocumentResponseDTO(doc))</span>
}

// @Summary Deletar Documento
// @Tags Documentos
// @Produce json
// @Param id path string true "ID do documento"
// @Success 204
// @Failure 404 {object} gin.H
// @Router /documents/{id} [delete]
func (h *DocumentHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.DeleteUC.Execute(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Documento não encontrado"})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package handlers

import (
        "net/http"
        "rhapp/internal/domain/dtos"
        "rhapp/internal/usecase/education"
        "rhapp/internal/utils"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type EducationHandler struct {
        CreateUC *education.CreateEducationHistoryUseCase
        UpdateUC *education.UpdateEducationHistoryUseCase
        DeleteUC *education.DeleteEducationHistoryUseCase
        FindUC   *education.FindEducationHistoryByIDUseCase
        ListUC   *education.ListEducationHistoriesUseCase
}

func NewEducationHandler(
        create *education.CreateEducationHistoryUseCase,
        update *education.UpdateEducationHistoryUseCase,
        delete *education.DeleteEducationHistoryUseCase,
        find *education.FindEducationHistoryByIDUseCase,
        list *education.ListEducationHistoriesUseCase,
) *EducationHandler <span class="cov0" title="0">{
        return &amp;EducationHandler{
                CreateUC: create,
                UpdateUC: update,
                DeleteUC: delete,
                FindUC:   find,
                ListUC:   list,
        }
}</span>

func (h *EducationHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        var input dtos.CreateEducationDTO
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">empID, err := uuid.Parse(input.EmployeeID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">areaEstudo, err := uuid.Parse(input.FieldOfStudy)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">startDate, err := time.Parse("2006-01-02", input.StartDate)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">endDate, err := time.Parse("2006-01-02", input.EndDate)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">result, err := h.CreateUC.Execute(c.Request.Context(), education.CreateEducationHistoryInput{
                EmployeeID:   empID,
                Institution:  input.Institution,
                Degree:       input.Degree,
                AreaEstudoID: areaEstudo,
                StartDate:    startDate,
                EndDate:      &amp;endDate,
                Description:  input.Description,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, dtos.ToEducationResponseDTO(result))</span>
}

func (h *EducationHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        idParam := c.Param("id")
        id, err := uuid.Parse(idParam)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>

        <span class="cov0" title="0">var input dtos.UpdateEducationDTO
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">startDate, err := time.Parse("2006-01-02", input.StartDate)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">endDate, err := time.Parse("2006-01-02", input.EndDate)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">areaEstudo, err := uuid.Parse(input.FieldOfStudy)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">result, err := h.UpdateUC.Execute(c.Request.Context(), education.UpdateEducationHistoryInput{
                ID:           id,
                Institution:  input.Institution,
                Degree:       input.Degree,
                AreaEstudoID: areaEstudo,
                StartDate:    startDate,
                EndDate:      &amp;endDate,
                Description:  input.Description,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToEducationResponseDTO(result))</span>
}

func (h *EducationHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.DeleteUC.Execute(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

func (h *EducationHandler) FindByID(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>

        <span class="cov0" title="0">res, err := h.FindUC.Execute(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToEducationResponseDTO(res))</span>
}

func (h *EducationHandler) List(c *gin.Context) <span class="cov0" title="0">{
        employeeID, err := uuid.Parse(c.Query("employee_id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "employee_id inválido"})
                return
        }</span>
        <span class="cov0" title="0">pagination := utils.PaginationInput(c)

        res, err := h.ListUC.Execute(c.Request.Context(), employeeID, pagination.Limit, pagination.Offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToEducationResponseDTOList(res))</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package handlers

import (
        "context"
        "net/http"
        "rhapp/internal/domain/dtos"
        "rhapp/internal/usecase/employees"
        "rhapp/internal/utils"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type EmployeeHandler struct {
        CreateUC   *employees.CreateEmployeeUseCase
        UpdateUC   *employees.UpdateEmployeeUseCase
        DeleteUC   *employees.DeleteEmployeeUseCase
        FindByIDUC *employees.FindEmployeeByIDUseCase
        ListUC     *employees.ListEmployeesUseCase
}

func NewEmployeeHandler(
        create *employees.CreateEmployeeUseCase,
        update *employees.UpdateEmployeeUseCase,
        deleteUC *employees.DeleteEmployeeUseCase,
        find *employees.FindEmployeeByIDUseCase,
        list *employees.ListEmployeesUseCase) *EmployeeHandler <span class="cov0" title="0">{
        return &amp;EmployeeHandler{
                CreateUC:   create,
                UpdateUC:   update,
                DeleteUC:   deleteUC,
                FindByIDUC: find,
                ListUC:     list,
        }
}</span>

// CreateEmployee godoc
// @Summary Cria um novo funcionário
// @Description Registra um novo funcionário no sistema com todos os dados obrigatórios
// @Tags Funcionários
// @Accept json
// @Produce json
// @Param input body dtos.CreateEmployeeDTO true "Dados do funcionário"
// @Success 201 {object} dtos.EmployeeResponseDTO
// @Failure 400 {object} map[string]string
// @Router /employees [post]
func (h *EmployeeHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        var input dtos.CreateEmployeeDTO
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">entity, err := h.CreateUC.Execute(context.Background(), employees.CreateEmployeeInput{
                CreateEmployeeDTO: input,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusCreated, dtos.ToEmployeeResponseDTO(entity))</span>
}

func (h *EmployeeHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">var input dtos.UpdateEmployeeDTO
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">entity, err := h.UpdateUC.Execute(context.Background(), employees.UpdateEmployeeInput{ID: id, EmployeeDTo: input})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToEmployeeResponseDTO(entity))</span>
}

func (h *EmployeeHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">if err := h.DeleteUC.Execute(context.Background(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

func (h *EmployeeHandler) FindByID(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">entity, err := h.FindByIDUC.Execute(context.Background(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToEmployeeResponseDTO(entity))</span>
}

func (h *EmployeeHandler) List(c *gin.Context) <span class="cov0" title="0">{
        pagination := utils.PaginationInput(c)
        result, err := h.ListUC.Execute(context.Background(), pagination.Limit, pagination.Offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToEmployeeResponseDTOList(result))</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package handlers

import (
        "net/http"

        "rhapp/internal/usecase/employee_status"
        "rhapp/internal/utils"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type EmployeeStatusHandler struct {
        CreateUC         *employee_status.CreateEmployeeStatusUseCase
        UpdateUC         *employee_status.UpdateEmployeeStatusUseCase
        DeleteUC         *employee_status.DeleteEmployeeStatusUseCase
        FindByIDUC       *employee_status.FindEmployeeStatusByIDUseCase
        ListByEmployeeUC *employee_status.ListEmployeeStatusByEmployeeUseCase
}

func NewEmployeeStatusHandler(
        create *employee_status.CreateEmployeeStatusUseCase,
        update *employee_status.UpdateEmployeeStatusUseCase,
        deleteUC *employee_status.DeleteEmployeeStatusUseCase,
        find *employee_status.FindEmployeeStatusByIDUseCase,
        list *employee_status.ListEmployeeStatusByEmployeeUseCase) *EmployeeStatusHandler <span class="cov0" title="0">{
        return &amp;EmployeeStatusHandler{
                CreateUC:         create,
                UpdateUC:         update,
                DeleteUC:         deleteUC,
                FindByIDUC:       find,
                ListByEmployeeUC: list,
        }
}</span>

// @Summary Criar status de funcionário
// @Tags EmployeeStatus
// @Accept json
// @Produce json
// @Param input body employee_status.CreateEmployeeStatusInput true "Dados do status"
// @Success 201 {object} employee_status.CreateEmployeeStatusInput
// @Failure 400,409 {object} gin.H
// @Router /employee-status [post]
func (h *EmployeeStatusHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        var input employee_status.CreateEmployeeStatusInput
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">result, err := h.CreateUC.Execute(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusConflict, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusCreated, result)</span>
}

// @Summary Atualizar status
// @Tags EmployeeStatus
// @Accept json
// @Produce json
// @Param id path string true "ID do status"
// @Param input body employee_status.UpdateEmployeeStatusInput true "Atualização"
// @Success 200 {object} employee_status.UpdateEmployeeStatusInput
// @Failure 400,404 {object} gin.H
// @Router /employee-status/{id} [put]
func (h *EmployeeStatusHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>

        <span class="cov0" title="0">var input employee_status.UpdateEmployeeStatusInput
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">input.ID = id

        result, err := h.UpdateUC.Execute(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, result)</span>
}

// @Summary Remover status
// @Tags EmployeeStatus
// @Param id path string true "ID do status"
// @Success 204
// @Failure 400,404 {object} gin.H
// @Router /employee-status/{id} [delete]
func (h *EmployeeStatusHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">if err := h.DeleteUC.Execute(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// @Summary Buscar status por ID
// @Tags EmployeeStatus
// @Param id path string true "ID do status"
// @Success 200 {object} employee_status.CreateEmployeeStatusInput
// @Failure 404 {object} gin.H
// @Router /employee-status/{id} [get]
func (h *EmployeeStatusHandler) FindByID(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">result, err := h.FindByIDUC.Execute(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, result)</span>
}

// @Summary Listar status de funcionário
// @Tags EmployeeStatus
// @Param employee_id query string true "ID do funcionário"
// @Param limit query int false "Limite de resultados"
// @Param offset query int false "Offset de paginação"
// @Success 200 {array} employee_status.CreateEmployeeStatusInput
// @Failure 400 {object} gin.H
// @Router /employee-status [get]
func (h *EmployeeStatusHandler) ListByEmployee(c *gin.Context) <span class="cov0" title="0">{
        empID, err := uuid.Parse(c.Query("employee_id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "employee_id inválido"})
                return
        }</span>
        <span class="cov0" title="0">pagination := utils.PaginationInput(c)

        result, err := h.ListByEmployeeUC.Execute(c.Request.Context(), empID, pagination.Limit, pagination.Offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, result)</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package handlers

import (
        "net/http"
        "rhapp/internal/domain/dtos"
        "rhapp/internal/usecase/municipios"
        "rhapp/internal/utils"

        "context"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type MunicipalityHandler struct {
        CreateUC   *municipios.CreateMunicipalityUseCase
        UpdateUC   *municipios.UpdateMunicipalityUseCase
        DeleteUC   *municipios.DeleteMunicipalityUseCase
        FindByIDUC *municipios.FindMunicipalityByIDUseCase
        ListUC     *municipios.ListMunicipalitiesUseCase
}

func NewMunicipalityHandler(
        createUC *municipios.CreateMunicipalityUseCase,
        updateUC *municipios.UpdateMunicipalityUseCase,
        deleteUC *municipios.DeleteMunicipalityUseCase,
        findByIDUC *municipios.FindMunicipalityByIDUseCase,
        listUC *municipios.ListMunicipalitiesUseCase,
) *MunicipalityHandler <span class="cov0" title="0">{
        return &amp;MunicipalityHandler{
                CreateUC:   createUC,
                UpdateUC:   updateUC,
                DeleteUC:   deleteUC,
                FindByIDUC: findByIDUC,
                ListUC:     listUC,
        }
}</span>

// CreateMunicipality godoc
// @Summary Cria um novo município
// @Description Registra um novo município associado a uma província
// @Tags Municípios
// @Accept json
// @Produce json
// @Param input body dtos.CreateMunicipioDTO true "Dados do município"
// @Success 201 {object} dtos.MunicipioResponseDTO
// @Failure 400 {object} map[string]string
// @Failure 409 {object} map[string]string
// @Router /municipalities [post]
func (h *MunicipalityHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        var input dtos.CreateMunicipioDTO
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">idProv, err := uuid.Parse(input.ProvinciaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">entity, err := h.CreateUC.Execute(context.Background(), municipios.CreateMunicipalityInput{
                Name:       input.Name,
                ProvinceID: idProv,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusCreated, dtos.ToMunicipioResponseDTO(entity))</span>
}

// UpdateMunicipality godoc
// @Summary Atualiza os dados de um município
// @Description Modifica o nome ou província associada a um município existente
// @Tags Municípios
// @Accept json
// @Produce json
// @Param id path string true "ID do município"
// @Param input body dtos.UpdateMunicipioDTO true "Dados atualizados"
// @Success 200 {object} dtos.MunicipioResponseDTO
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /municipalities/{id} [put]
func (h *MunicipalityHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>

        <span class="cov0" title="0">var input dtos.UpdateMunicipioDTO
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">idProv, err := uuid.Parse(input.ProvinciaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">entity, err := h.UpdateUC.Execute(context.Background(), municipios.UpdateMunicipalityInput{
                ID:         id,
                Name:       input.Name,
                ProvinceID: idProv,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToMunicipioResponseDTO(entity))</span>
}

// DeleteMunicipality godoc
// @Summary Remove um município
// @Description Exclui um município pelo ID
// @Tags Municípios
// @Produce json
// @Param id path string true "ID do município"
// @Success 204 "No Content"
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /municipalities/{id} [delete]
func (h *MunicipalityHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">if err := h.DeleteUC.Execute(context.Background(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// GetMunicipalityByID godoc
// @Summary Busca um município pelo ID
// @Description Retorna os dados de um município específico
// @Tags Municípios
// @Produce json
// @Param id path string true "ID do município"
// @Success 200 {object} dtos.MunicipioResponseDTO
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /municipalities/{id} [get]
func (h *MunicipalityHandler) FindByID(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">entity, err := h.FindByIDUC.Execute(context.Background(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToMunicipioResponseDTO(entity))</span>
}

// ListMunicipalities godoc
// @Summary Lista todos os municípios
// @Description Retorna todos os municípios cadastrados
// @Tags Municípios
// @Produce json
// @Success 200 {array} dtos.MunicipioResponseDTO
// @Failure 500 {object} map[string]string
// @Router /municipalities [get]
func (h *MunicipalityHandler) List(c *gin.Context) <span class="cov0" title="0">{
        pagination := utils.PaginationInput(c)
        entities, err := h.ListUC.Execute(context.Background(), pagination.Limit, pagination.Offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToMunicipioResponseDTOList(entities))</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package handlers

import (
        "net/http"
        "rhapp/internal/domain/dtos"
        "rhapp/internal/usecase/positions"
        "rhapp/internal/utils"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type PositionHandler struct {
        CreateUC  *positions.CreatePositionUseCase
        UpdateUC  *positions.UpdatePositionUseCase
        DeleteUC  *positions.DeletePositionUseCase
        FindOneUC *positions.FindPositionByIDUseCase
        FindAllUC *positions.FindAllPositionsUseCase
}

func NewPositionHandler(
        createUC *positions.CreatePositionUseCase,
        updateUC *positions.UpdatePositionUseCase,
        deleteUC *positions.DeletePositionUseCase,
        findOneUC *positions.FindPositionByIDUseCase,
        findAllUC *positions.FindAllPositionsUseCase,
) *PositionHandler <span class="cov0" title="0">{
        return &amp;PositionHandler{
                CreateUC:  createUC,
                UpdateUC:  updateUC,
                DeleteUC:  deleteUC,
                FindOneUC: findOneUC,
                FindAllUC: findAllUC,
        }
}</span>

// Create godoc
// @Summary Criar nova posição
// @Description Cria uma nova posição (cargo) associada a um departamento
// @Tags Posições
// @Accept json
// @Produce json
// @Param payload body dtos.CreatePositionDTO true "Dados da posição"
// @Success 201 {object} dtos.PositionResponseDTO
// @Failure 400 {object} map[string]string
// @Failure 409 {object} map[string]string
// @Router /positions [post]
func (h *PositionHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        var input dtos.CreatePositionDTO
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">deptID, err := uuid.Parse(input.DepartmentID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">position, err := h.CreateUC.Execute(c.Request.Context(), positions.CreatePositionInput{
                Name:         input.Name,
                DepartmentID: deptID,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, dtos.ToPositionResponseDTO(position))</span>
}

// Update godoc
// @Summary Atualizar posição
// @Description Atualiza os dados de uma posição existente
// @Tags Posições
// @Accept json
// @Produce json
// @Param id path string true "ID da posição"
// @Param payload body dtos.UpdatePositionDTO true "Campos atualizados"
// @Success 200 {object} dtos.PositionResponseDTO
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /positions/{id} [put]
func (h *PositionHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        var input dtos.UpdatePositionDTO
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">id := c.Param("id")

        posID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">depID, err := uuid.Parse(input.DepartmentID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">position, err := h.UpdateUC.Execute(c.Request.Context(), positions.UpdatePositionInput{
                ID:           posID,
                Name:         input.Name,
                DepartmentID: depID,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToPositionResponseDTO(position))</span>
}

// Delete godoc
// @Summary Remover posição
// @Description Remove uma posição com base no ID
// @Tags Posições
// @Produce json
// @Param id path string true "ID da posição"
// @Success 204 "No Content"
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /positions/{id} [delete]
func (h *PositionHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">err = h.DeleteUC.Execute(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// FindByID godoc
// @Summary Buscar posição por ID
// @Description Retorna os dados de uma posição específica
// @Tags Posições
// @Produce json
// @Param id path string true "ID da posição"
// @Success 200 {object} dtos.PositionResponseDTO
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /positions/{id} [get]
func (h *PositionHandler) FindByID(c *gin.Context) <span class="cov0" title="0">{

        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">position, err := h.FindOneUC.Execute(c.Request.Context(), positions.FindPositionByIDInput{
                ID: id,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToPositionResponseDTO(position))</span>
}

// FindAll godoc
// @Summary Listar posições
// @Description Lista todas as posições cadastradas
// @Tags Posições
// @Produce json
// @Success 200 {array} dtos.PositionResponseDTO
// @Failure 500 {object} map[string]string
// @Router /positions [get]
func (h *PositionHandler) FindAll(c *gin.Context) <span class="cov0" title="0">{
        pagination := utils.PaginationInput(c)
        list, err := h.FindAllUC.Execute(c.Request.Context(), pagination.Limit, pagination.Offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "erro ao buscar posições"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToPositionResponseDTOList(list))</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package handlers

import (
        "context"
        "fmt"
        "net/http"
        "rhapp/internal/domain/dtos"
        "rhapp/internal/usecase/provincias"
        "rhapp/internal/utils"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type ProvinceHandler struct {
        CreateUC  *provincias.CreateProvinceUseCase
        UpdateUC  *provincias.UpdateProvinceUseCase
        DeleteUC  *provincias.DeleteProvinceUseCase
        GetByIDUC *provincias.FindProvinceByIDUseCase
        ListAllUC *provincias.FindAllProvincesUseCase
        SearchUC  *provincias.SearchProvinceUseCase
}

func NewProvinceHandler(
        createUC *provincias.CreateProvinceUseCase,
        updateUC *provincias.UpdateProvinceUseCase,
        deleteUC *provincias.DeleteProvinceUseCase,
        getByIDUC *provincias.FindProvinceByIDUseCase,
        listAllUC *provincias.FindAllProvincesUseCase,
        searchUC *provincias.SearchProvinceUseCase,
) *ProvinceHandler <span class="cov8" title="1">{
        return &amp;ProvinceHandler{
                CreateUC:  createUC,
                UpdateUC:  updateUC,
                DeleteUC:  deleteUC,
                GetByIDUC: getByIDUC,
                ListAllUC: listAllUC,
                SearchUC:  searchUC,
        }
}</span>

// Create godoc
// @Summary      Criar Província
// @Description  Cria uma nova província
// @Tags         Províncias
// @Accept       json
// @Produce      json
// @Param        input  body    dtos.CreateProvinceDoc   true  "Dados da província"
// @Success      201    {object}  dtos.ProvinceResponseDTO
// @Failure          400         {object}  utils.Payload         "Validation error with fields detail"
// @Failure      409    {object}  utils.Payload     "Conflito (chave única)"
// @Failure      500    {object}  utils.Payload     "Erro interno"
// @Router       /provinces [post]
func (h *ProvinceHandler) Create(c *gin.Context) <span class="cov8" title="1">{

        var dto dtos.CreateProvinceDTO

        if err := utils.BindAndValidateStrict(c, &amp;dto); err != nil </span><span class="cov8" title="1">{
                if fields := utils.HumanizeValidation(dto, err); len(fields) &gt; 0 </span><span class="cov8" title="1">{
                        msg := "Dados inválidos. Corrija os campos destacados."
                        c.JSON(http.StatusBadRequest, utils.Payload{
                                Error:   "Validação dos campos",
                                Message: msg,
                                Fields:  fields,
                        })
                        return
                }</span>

                <span class="cov8" title="1">c.JSON(http.StatusBadRequest, utils.Payload{
                        Error:   "Pedido inválido",
                        Message: err.Error(),
                })
                return</span>
        }

        <span class="cov8" title="1">input := provincias.CreateProvinceInput{Name: dto.Nome}
        province, err := h.CreateUC.Execute(c.Request.Context(), input)
        fmt.Println(err)
        if err != nil </span><span class="cov8" title="1">{
                if ok, payload, status := utils.HumanizeDB(err); ok </span><span class="cov8" title="1">{
                        c.JSON(status, payload)
                        return
                }</span>

                <span class="cov8" title="1">msg := "Erro interno do servidor"
                c.JSON(http.StatusInternalServerError, utils.Payload{
                        Error:   "internal",
                        Message: msg,
                })
                return</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusCreated, dtos.ToProvinceResponseDTO(province))</span>
}

// Update godoc
// @Summary Atualizar Província
// @Description Atualiza os dados de uma província existente
// @Tags Províncias
// @Accept json
// @Produce json
// @Param id path string true "ID da província"
// @Param input body dtos.UpdateProvinceDTO true "Dados atualizados"
// @Success 200 {object} dtos.ProvinceResponseDTO
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /provinces/{id} [put]
func (h *ProvinceHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        var dto dtos.UpdateProvinceDTO
        if err := c.ShouldBindJSON(&amp;dto); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">id := c.Param("id")

        uid, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">input := provincias.UpdateProvinceInput{
                ID:   uid,
                Name: dto.Nome,
        }

        province, err := h.UpdateUC.Execute(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToProvinceResponseDTO(province))</span>
}

// Delete godoc
// @Summary Remover Província
// @Description Remove uma província existente pelo ID
// @Tags Províncias
// @Produce json
// @Param id path string true "ID da província"
// @Success 204 "No Content"
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /provinces/{id} [delete]
func (h *ProvinceHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        uid, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">err = h.DeleteUC.Execute(c.Request.Context(), uid)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// GetByID godoc
// @Summary Buscar Província por ID
// @Description Retorna os dados de uma província pelo seu ID
// @Tags Províncias
// @Produce json
// @Param id path string true "ID da província"
// @Success 200 {object} dtos.ProvinceResponseDTO
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /api/provinces/{id} [get]
func (h *ProvinceHandler) GetByID(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        uid, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">province, err := h.GetByIDUC.Execute(c.Request.Context(), provincias.FindProvinceByIDInput{ID: uid})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToProvinceResponseDTO(province))</span>
}

// List godoc
// @Summary Listar Províncias
// @Description Retorna a lista de todas as províncias cadastradas
// @Tags Províncias
// @Produce json
// @Success 200 {array} dtos.ProvinceResponseDTO
// @Failure 500 {object} map[string]string
// @Router /provinces [get]
func (h *ProvinceHandler) List(c *gin.Context) <span class="cov0" title="0">{
        pagination := utils.PaginationInput(c)
        list, err := h.ListAllUC.Execute(c.Request.Context(), pagination.Limit, pagination.Offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToProvinceResponseDTOList(list))</span>
}

// SearchProvinces godoc
// @Summary Buscar províncias
// @Description Busca províncias com filtros e paginação
// @Tags Busca
// @Accept json
// @Produce json
// @Param search query string false "Texto de busca (nome da província)"
// @Param filter query string false "Filtro genérico"
// @Param limit query int false "Número máximo de registros a retornar"
// @Param offset query int false "Número de registros a ignorar (para paginação)"
// @Success 200 {array} dtos.ProvinceResponseDTO
// @Failure 500 {object} map[string]string
// @Router /search/provinces [get]
func (h *ProvinceHandler) SearchProvinces(c *gin.Context) <span class="cov0" title="0">{
        input := utils.ParseSearchInput(c)
        results, err := h.SearchUC.Execute(context.Background(), input)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToProvinceResponseDTOList(results))</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package handlers

import (
        "net/http"
        "rhapp/internal/domain/dtos"
        "rhapp/internal/usecase/supervisor"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type SupervisorHandler struct {
        CreateUC *supervisor.CreateUseCase
        UpdateUC *supervisor.UpdateUseCase
        DeleteUC *supervisor.DeleteUseCase
        FindUC   *supervisor.FindByIDUseCase
        ListUC   *supervisor.ListByEmployeeIDUseCase
}

func NewSupervisorHandler(
        create *supervisor.CreateUseCase,
        update *supervisor.UpdateUseCase,
        delete *supervisor.DeleteUseCase,
        find *supervisor.FindByIDUseCase,
        list *supervisor.ListByEmployeeIDUseCase,
) *SupervisorHandler <span class="cov0" title="0">{
        return &amp;SupervisorHandler{
                CreateUC: create,
                UpdateUC: update,
                DeleteUC: delete,
                FindUC:   find,
                ListUC:   list,
        }
}</span>

func (h *SupervisorHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        var input supervisor.CreateInput
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">result, err := h.CreateUC.Execute(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusCreated, result)</span>
}

func (h *SupervisorHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">var dto dtos.UpdateSupervisorDTO
        if err := c.ShouldBindJSON(&amp;dto); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">startDate, err := time.Parse("2006-01-02", dto.StartDate)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">endDate, err := time.Parse("2006-01-02", dto.EndDate)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">supervidorID, err := uuid.Parse(*dto.SupervisorID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">input := supervisor.UpdateInput{ID: id, SupervisorID: &amp;supervidorID, StartDate: startDate, EndDate: &amp;endDate}
        result, err := h.UpdateUC.Execute(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, result)</span>
}

func (h *SupervisorHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">if err := h.DeleteUC.Execute(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

func (h *SupervisorHandler) FindByID(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">result, err := h.FindUC.Execute(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, result)</span>
}

func (h *SupervisorHandler) ListByEmployee(c *gin.Context) <span class="cov0" title="0">{
        employeeIDStr := c.Param("employee_id")
        employeeID, err := uuid.Parse(employeeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "employee_id inválido"})
                return
        }</span>
        <span class="cov0" title="0">limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
        list, err := h.ListUC.Execute(c.Request.Context(), employeeID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, list)</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package handlers

import (
        "net/http"
        "rhapp/internal/domain/dtos"
        "rhapp/internal/usecase/workhistory"

        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type WorkHandler struct {
        CreateUC *workhistory.CreateWorkHistoryUseCase
        UpdateUC *workhistory.UpdateWorkHistoryUseCase
        DeleteUC *workhistory.DeleteWorkHistoryUseCase
        FindUC   *workhistory.FindWorkHistoryByIDUseCase
        ListUC   *workhistory.ListWorkHistoryByEmployeeUseCase
}

func NewWorkHandler(
        create *workhistory.CreateWorkHistoryUseCase,
        update *workhistory.UpdateWorkHistoryUseCase,
        delete *workhistory.DeleteWorkHistoryUseCase,
        find *workhistory.FindWorkHistoryByIDUseCase,
        list *workhistory.ListWorkHistoryByEmployeeUseCase,
) *WorkHandler <span class="cov0" title="0">{
        return &amp;WorkHandler{
                CreateUC: create,
                UpdateUC: update,
                DeleteUC: delete,
                FindUC:   find,
                ListUC:   list,
        }
}</span>

// CreateWorkHistory godoc
// @Summary Criar novo histórico profissional
// @Tags Histórico Profissional
// @Accept json
// @Produce json
// @Param data body dtos.CreateWorkDTO true "Dados do histórico profissional"
// @Success 201 {object} dtos.WorkResponseDTO
// @Failure 400,500 {object} map[string]string
// @Router /work_history [post]
func (h *WorkHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        var dto dtos.CreateWorkDTO
        if err := c.ShouldBindJSON(&amp;dto); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">work, err := dtos.ToWorkFromCreateDTO(dto)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">created, err := h.CreateUC.Execute(c.Request.Context(), work)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusCreated, dtos.ToWorkResponseDTO(created))</span>
}

// UpdateWorkHistory godoc
// @Summary Atualizar histórico profissional
// @Tags Histórico Profissional
// @Accept json
// @Produce json
// @Param id path string true "ID do Histórico"
// @Param data body dtos.UpdateWorkDTO true "Campos a atualizar"
// @Success 200 {object} dtos.WorkResponseDTO
// @Failure 400,404,500 {object} map[string]string
// @Router /work_history/{id} [put]
func (h *WorkHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">var dto dtos.UpdateWorkDTO
        if err := c.ShouldBindJSON(&amp;dto); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">updated, err := h.UpdateUC.Execute(c.Request.Context(), workhistory.UpdateWorkHistoryInput{ID: id, WorkDTO: dto})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToWorkResponseDTO(updated))</span>
}

// DeleteWorkHistory godoc
// @Summary Remover histórico profissional
// @Tags Histórico Profissional
// @Produce json
// @Param id path string true "ID do Histórico"
// @Success 204
// @Failure 400,404,500 {object} map[string]string
// @Router /work_history/{id} [delete]
func (h *WorkHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">if err := h.DeleteUC.Execute(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// FindWorkHistoryByID godoc
// @Summary Buscar histórico profissional por ID
// @Tags Histórico Profissional
// @Produce json
// @Param id path string true "ID do Histórico"
// @Success 200 {object} dtos.WorkResponseDTO
// @Failure 400,404,500 {object} map[string]string
// @Router /work_history/{id} [get]
func (h *WorkHandler) FindByID(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
                return
        }</span>
        <span class="cov0" title="0">work, err := h.FindUC.Execute(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToWorkResponseDTO(work))</span>
}

// ListWorkHistoryByEmployee godoc
// @Summary Listar históricos profissionais de um funcionário
// @Tags Histórico Profissional
// @Produce json
// @Param employee_id path string true "ID do Funcionário"
// @Param limit query int false "Limite"
// @Param offset query int false "Offset"
// @Success 200 {array} dtos.WorkResponseDTO
// @Failure 400,500 {object} map[string]string
// @Router /employees/{employee_id}/work_history [get]
func (h *WorkHandler) ListByEmployee(c *gin.Context) <span class="cov0" title="0">{
        employeeIDStr := c.Param("employee_id")
        employeeID, err := uuid.Parse(employeeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "employee_id inválido"})
                return
        }</span>
        <span class="cov0" title="0">limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

        list, err := h.ListUC.Execute(c.Request.Context(), employeeID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, dtos.ToWorkResponseDTOList(list))</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package middleware

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

// Ensures the user has permission to access the resource.

func RBACMiddleware(requiredRole string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                role := c.GetString("role")
                if role != requiredRole </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "forbidden"})
                        return
                }</span>
                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package middleware

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
)

func BodySizeLimit(limitBytes int64) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // c.Request.Body = http.MaxBytesReader(writer, body, size)
                c.Request.Body = http.MaxBytesReader(c.Writer, c.Request.Body, limitBytes)

                if err := c.Request.ParseForm(); err != nil &amp;&amp; err.Error() == "http: request body too large" </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusRequestEntityTooLarge, gin.H{
                                "error": "Payload muito grande. O limite é " + strconv.FormatInt(limitBytes, 10) + " bytes",
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package middleware

import (
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
)

func CORSMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return cors.New(cors.Config{
                AllowOrigins:     []string{"*"},
                AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
                ExposeHeaders:    []string{"Content-Length"},
                AllowCredentials: true,
                MaxAge:           12 * time.Hour,
        })
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">// middleware/json_validation.go
package middleware

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

// RequireJSON rejects non-JSON requests early.
func RequireJSON() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                if c.ContentType() != "application/json" </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnsupportedMediaType, gin.H{
                                "error": "Content-Type must be application/json",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.Next()</span>
        }
}

// ValidateJSON binds &amp; validates a JSON body to T and stores it in context.
// Use struct tags like `binding:"required,email"` on T's fields.
func ValidateJSON[T any](ctxKey string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var payload T
                if err := c.ShouldBindJSON(&amp;payload); err != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{
                                "error":   "invalid input",
                                "details": err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.Set(ctxKey, payload)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package middleware

import (
        "log"
        "time"

        "github.com/gin-gonic/gin"
)

// LoggerMiddleware registra a duração da requisição e o caminho
func LoggerMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()

                // Processa a requisição
                c.Next()

                // Log após a requisição
                duration := time.Since(start)
                log.Printf("[%s] %s | %d | %s",
                        c.Request.Method,
                        c.Request.URL.Path,
                        c.Writer.Status(),
                        duration,
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package middleware

import (
        "time"

        "github.com/gin-gonic/gin"
        "github.com/redis/go-redis/v9"
        "github.com/ulule/limiter/v3"
        ginlimiter "github.com/ulule/limiter/v3/drivers/middleware/gin"
        redisstore "github.com/ulule/limiter/v3/drivers/store/redis"
)

// RateLimiterRedisMiddleware aplica rate limiting por IP com Redis como backend
func RateLimiterRedisMiddleware(limit int64, period time.Duration, client *redis.Client) gin.HandlerFunc <span class="cov0" title="0">{
        rate := limiter.Rate{
                Period: period,
                Limit:  limit,
        }

        store, err := redisstore.NewStoreWithOptions(client, limiter.StoreOptions{
                Prefix:   "ratelimiter",
                MaxRetry: 3,
        })
        if err != nil </span><span class="cov0" title="0">{
                panic("Erro ao criar Redis RateLimiter Store: " + err.Error())</span>
        }

        <span class="cov0" title="0">return ginlimiter.NewMiddleware(limiter.New(store, rate))</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package middleware

import (
        "log"
        "net/http"

        "github.com/gin-gonic/gin"
)

// Prevents crashes due to panics and returns 500 gracefully.
func Recovery() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                log.Println("Recovered from panic:", err)
                                c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": "internal error"})
                        }</span>
                }()
                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package middleware

import (
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

func RequestID() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                id := uuid.New().String()
                c.Set("RequestID", id)
                c.Writer.Header().Set("X-Request-ID", id)
                c.Next()
        }</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package middleware

import (
        "strings"

        "github.com/gin-gonic/gin"
)

func StripTrailingSlash() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Request.URL.Path = strings.TrimSuffix(c.Request.URL.Path, "/")
                c.Next()
        }</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package middleware

import "github.com/gin-gonic/gin"

func UserContext() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // parse token, fetch user from DB, attach to context
                var user string
                c.Set("user", user)
                c.Next()
        }</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package middleware

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

func ValidateInput(schema interface{}) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                if err := c.ShouldBindJSON(&amp;schema); err != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "invalid input"})
                        return
                }</span>
                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package router

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        ginSwagger "github.com/swaggo/gin-swagger"

        _ "rhapp/docs" // &lt;- certifique-se de que o path corresponde ao seu módulo
        "rhapp/internal/infrastructure/redisdb"
        "rhapp/internal/interfaces/handlers"
        "rhapp/internal/interfaces/middleware"

        swaggerFiles "github.com/swaggo/files"
)

func SetupRouter(
        provinceHandler *handlers.ProvinceHandler,
        areaEstudoHandler *handlers.AreaEstudoHandler,
        departmentHandler *handlers.DepartmentHandler,
        positionHandler *handlers.PositionHandler,
        municipalityHandler *handlers.MunicipalityHandler,
        //        searchHandler *handlers.SearchHandler,
        districtHandler *handlers.DistrictHandler,
        employeeHandler *handlers.EmployeeHandler,
        dependentHandler *handlers.DependentHandler,
        documentHandler *handlers.DocumentHandler,
        educationHandler *handlers.EducationHandler,
        empStatusHandler *handlers.EmployeeStatusHandler,
        supervisorHandler *handlers.SupervisorHandler,
        workHandler *handlers.WorkHandler,

) *gin.Engine <span class="cov0" title="0">{
        router := gin.Default()

        // Middlewares globais
        router.Use(middleware.LoggerMiddleware())
        router.Use(middleware.CORSMiddleware())
        router.Use(middleware.Recovery())
        router.Use(middleware.StripTrailingSlash())
        // Aplica rate limit de 10 requisições por minuto por IP
        router.Use(middleware.RateLimiterRedisMiddleware(15, time.Minute, redisdb.Client)) // Redis-based limiter
        router.Use(middleware.BodySizeLimit(1 * 1024 * 1024))                              // 1MB
        router.MaxMultipartMemory = 8 &lt;&lt; 20                                                // 8 MiB - Upload de arquivos

        router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
        router.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{ c.JSON(http.StatusOK, gin.H{"status": "ok"}) }</span>)

        <span class="cov0" title="0">api := router.Group("/api")

        provinces := api.Group("/provinces")
        </span><span class="cov0" title="0">{
                provinces.POST("", provinceHandler.Create)
                provinces.PUT("/:id", provinceHandler.Update)
                provinces.DELETE("/:id", provinceHandler.Delete)
                provinces.GET("/:id", provinceHandler.GetByID)
                provinces.GET("", provinceHandler.List)
        }</span>

        /*
                search := api.Group("/search")
                {
                        search.GET("/municipalities", searchHandler.SearchMunicipalities)
                        search.GET("/departments", searchHandler.SearchDepartments)
                        search.GET("/positions", searchHandler.SearchPositions)
                        search.GET("/provinces", searchHandler.SearchProvinces)
                        search.GET("/areas-estudo", searchHandler.SearchAreasEstudo)
                        search.GET("/districts", searchHandler.SearchDistrito)
                        search.GET("/employees", searchHandler.SearchEmployee)
                }
        */

        <span class="cov0" title="0">municipalities := api.Group("/municipalities")
        </span><span class="cov0" title="0">{
                municipalities.POST("", municipalityHandler.Create)
                municipalities.PUT("/:id", municipalityHandler.Update)
                municipalities.DELETE("/:id", municipalityHandler.Delete)
                municipalities.GET("/:id", municipalityHandler.FindByID)
                municipalities.GET("", municipalityHandler.List)
        }</span>

        <span class="cov0" title="0">areasestudo := api.Group("/areas-estudo")
        </span><span class="cov0" title="0">{
                areasestudo.POST("", areaEstudoHandler.Create)
                areasestudo.PUT("/:id", areaEstudoHandler.Update)
                areasestudo.DELETE("/:id", areaEstudoHandler.Delete)
                areasestudo.GET("/:id", areaEstudoHandler.GetByID)
                areasestudo.GET("", areaEstudoHandler.ListAll)
        }</span>

        <span class="cov0" title="0">departments := api.Group("/departments")
        </span><span class="cov0" title="0">{
                departments.POST("", departmentHandler.Create)
                departments.PUT("/:id", departmentHandler.Update)
                departments.DELETE("/:id", departmentHandler.Delete)
                departments.GET("/:id", departmentHandler.FindByID)
                departments.GET("", departmentHandler.FindAll)
        }</span>

        <span class="cov0" title="0">positions := api.Group("/positions")
        </span><span class="cov0" title="0">{
                positions.POST("", positionHandler.Create)
                positions.PUT("/:id", positionHandler.Update)
                positions.DELETE("/:id", positionHandler.Delete)
                positions.GET("/:id", positionHandler.FindByID)
                positions.GET("", positionHandler.FindAll)
        }</span>

        <span class="cov0" title="0">districts := api.Group("/districts")
        </span><span class="cov0" title="0">{
                districts.POST("", districtHandler.Create)
                districts.PUT("/:id", districtHandler.Update)
                districts.DELETE("/:id", districtHandler.Delete)
                districts.GET("/:id", districtHandler.FindByID)
                districts.GET("", districtHandler.List)
        }</span>

        <span class="cov0" title="0">employees := api.Group("/employees")
        </span><span class="cov0" title="0">{
                employees.POST("", employeeHandler.Create)
                employees.PUT("/:id", employeeHandler.Update)
                employees.DELETE("/:id", employeeHandler.Delete)
                employees.GET("/:id", employeeHandler.FindByID)
                employees.GET("", employeeHandler.List)
        }</span>

        <span class="cov0" title="0">dependent := api.Group("/dependents")
        </span><span class="cov0" title="0">{
                dependent.POST("", dependentHandler.Create)
                dependent.PUT("/:id", dependentHandler.Update)
                dependent.DELETE("/:id", dependentHandler.Delete)
                dependent.GET("/:id", dependentHandler.FindByID)
                dependent.GET("", dependentHandler.List)
        }</span>

        <span class="cov0" title="0">document := api.Group("/documents")
        </span><span class="cov0" title="0">{
                document.POST("", documentHandler.Create)
                document.PUT("/:id", documentHandler.Update)
                document.DELETE("/:id", documentHandler.Delete)
                document.GET("/:id", documentHandler.FindByID)
                document.GET("", documentHandler.List)
        }</span>

        <span class="cov0" title="0">education := api.Group("/educations")
        </span><span class="cov0" title="0">{
                education.POST("", educationHandler.Create)
                education.PUT("/:id", educationHandler.Update)
                education.DELETE("/:id", educationHandler.Delete)
                education.GET("/:id", educationHandler.FindByID)
                education.GET("", educationHandler.List)
        }</span>

        <span class="cov0" title="0">emp_status := api.Group("/empstatus")
        </span><span class="cov0" title="0">{
                emp_status.POST("", empStatusHandler.Create)
                emp_status.PUT("/:id", empStatusHandler.Update)
                emp_status.DELETE("/:id", empStatusHandler.Delete)
                emp_status.GET("/:id", empStatusHandler.FindByID)
                emp_status.GET("", empStatusHandler.ListByEmployee)
        }</span>

        <span class="cov0" title="0">supervisor := api.Group("/supervisors")
        </span><span class="cov0" title="0">{
                supervisor.POST("", supervisorHandler.Create)
                supervisor.PUT("/:id", supervisorHandler.Update)
                supervisor.DELETE("/:id", supervisorHandler.Delete)
                supervisor.GET("/:id", supervisorHandler.FindByID)
                supervisor.GET("", supervisorHandler.ListByEmployee)
        }</span>

        <span class="cov0" title="0">work := api.Group("/works")
        </span><span class="cov0" title="0">{
                work.POST("", workHandler.Create)
                work.PUT("/:id", workHandler.Update)
                work.DELETE("/:id", workHandler.Delete)
                work.GET("/:id", workHandler.FindByID)
                work.GET("", workHandler.ListByEmployee)
        }</span>
        <span class="cov0" title="0">return router</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package agregados

import (
        "context"
        "fmt"
        "rhapp/internal/domain/agregados"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type GetDocumentsByOwnerInput struct {
        OwnerType vos.DocumentOwnerType
        OwnerID   uuid.UUID
}

type GetDocumentsByOwnerUseCase struct {
        Repo agregados.DocumentAggregateRepository
}

func NewGetDocumentsByOwnerUseCase(repo agregados.DocumentAggregateRepository) *GetDocumentsByOwnerUseCase <span class="cov0" title="0">{
        return &amp;GetDocumentsByOwnerUseCase{Repo: repo}
}</span>

func (uc *GetDocumentsByOwnerUseCase) Execute(ctx context.Context, input GetDocumentsByOwnerInput) (*agregados.DocumentAggregate, error) <span class="cov0" title="0">{
        if input.OwnerType == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tipo de proprietário é obrigatório")
        }</span>
        <span class="cov0" title="0">if input.OwnerID == uuid.Nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ID do proprietário inválido")
        }</span>

        <span class="cov0" title="0">return uc.Repo.GetByOwner(ctx, input.OwnerType, input.OwnerID)</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package agregados

import (
        "context"
        "fmt"

        "rhapp/internal/domain/agregados"

        "github.com/google/uuid"
)

/*
***********

/employees/:id/aggregate

***************
*/
type GetEmployeeAggregateByIDUseCase struct {
        Repo agregados.EmployeeAggregateRepository
}

type GetEmployeeAggregateInput struct {
        ID uuid.UUID
}

func (uc *GetEmployeeAggregateByIDUseCase) Execute(ctx context.Context, input GetEmployeeAggregateInput) (*agregados.EmployeeAggregate, error) <span class="cov0" title="0">{
        if input.ID == uuid.Nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ID do funcionário é obrigatório")
        }</span>

        <span class="cov0" title="0">agg, err := uc.Repo.GetFullByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao buscar funcionário completo: %w", err)
        }</span>
        <span class="cov0" title="0">return agg, nil</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package agregados

import (
        "context"
        "fmt"

        "rhapp/internal/domain/agregados"

        "github.com/google/uuid"
)

type GetLocationByProvinceIDUseCase struct {
        Repo agregados.LocationAggregateRepository
}

type GetLocationByProvinceInput struct {
        ProvinceID uuid.UUID
}

func (uc *GetLocationByProvinceIDUseCase) Execute(ctx context.Context, input GetLocationByProvinceInput) (*agregados.LocationAggregate, error) <span class="cov0" title="0">{
        if input.ProvinceID == uuid.Nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ID da província inválido")
        }</span>
        <span class="cov0" title="0">locationAgg, err := uc.Repo.GetByProvinceID(ctx, input.ProvinceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao obter dados da localização: %w", err)
        }</span>
        <span class="cov0" title="0">return locationAgg, nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package agregados

import (
        "context"
        "fmt"

        "rhapp/internal/domain/agregados"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type GetOrgStructureByDepartmentInput struct {
        DepartmentID uuid.UUID
}

type GetOrgStructureByDepartmentUseCase struct {
        Repo repos.OrgStructureAggregateRepository
}

func NewGetOrgStructureByDepartmentUseCase(repo repos.OrgStructureAggregateRepository) *GetOrgStructureByDepartmentUseCase <span class="cov0" title="0">{
        return &amp;GetOrgStructureByDepartmentUseCase{Repo: repo}
}</span>

func (uc *GetOrgStructureByDepartmentUseCase) Execute(ctx context.Context, input GetOrgStructureByDepartmentInput) (*agregados.OrgStructureAggregate, error) <span class="cov0" title="0">{
        if input.DepartmentID == uuid.Nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ID do departamento inválido")
        }</span>

        <span class="cov0" title="0">orgAgg, err := uc.Repo.GetByDepartmentID(ctx, input.DepartmentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao obter estrutura organizacional: %w", err)
        }</span>

        <span class="cov0" title="0">return orgAgg, nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package areas_estudo

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type CreateAreaEstudoUseCase struct {
        Repo repos.AreaEstudoRepository
}

type CreateAreaEstudoInput struct {
        Name        string
        Description string
}

func (uc *CreateAreaEstudoUseCase) Execute(ctx context.Context, input CreateAreaEstudoInput) (entities.AreaEstudo, error) <span class="cov0" title="0">{
        // Normalizar entrada
        name := strings.TrimSpace(input.Name)
        description := strings.TrimSpace(input.Description)

        // Validação básica
        if name == "" </span><span class="cov0" title="0">{
                return entities.AreaEstudo{}, errors.New("o nome da área de estudo é obrigatório")
        }</span>
        <span class="cov0" title="0">if description == "" </span><span class="cov0" title="0">{
                return entities.AreaEstudo{}, errors.New("a descrição da área de estudo é obrigatória")
        }</span>

        // Verificação de duplicidade
        <span class="cov0" title="0">exists, err := uc.Repo.ExistsByName(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                return entities.AreaEstudo{}, fmt.Errorf("erro ao verificar se área já existe: %w", err)
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return entities.AreaEstudo{}, fmt.Errorf("já existe uma área de estudo com o nome '%s'", name)
        }</span>

        // Criar entidade
        <span class="cov0" title="0">now := time.Now()
        area := entities.AreaEstudo{
                ID:          uuid.New(),
                Name:        name,
                Description: description,
                CreatedAt:   now,
                UpdatedAt:   now,
        }

        // Persistir no repositório
        if err := uc.Repo.Create(ctx, area); err != nil </span><span class="cov0" title="0">{
                return entities.AreaEstudo{}, fmt.Errorf("erro ao criar área de estudo: %w", err)
        }</span>

        <span class="cov0" title="0">return area, nil</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package areas_estudo

import (
        "context"
        "errors"
        "fmt"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type DeleteAreaEstudoUseCase struct {
        Repo repos.AreaEstudoRepository
}

type DeleteAreaEstudoInput struct {
        ID uuid.UUID
}

func (uc *DeleteAreaEstudoUseCase) Execute(ctx context.Context, input DeleteAreaEstudoInput) error <span class="cov0" title="0">{
        if input.ID == uuid.Nil </span><span class="cov0" title="0">{
                return errors.New("ID da área de estudo é obrigatório")
        }</span>

        <span class="cov0" title="0">if err := uc.Repo.Delete(ctx, input.ID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erro ao excluir área de estudo com ID %s: %w", input.ID, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">package areas_estudo

import (
        "context"
        "errors"
        "fmt"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type GetAreaEstudoByIDUseCase struct {
        Repo repos.AreaEstudoRepository
}

type GetOneAreaEstudoInput struct {
        ID uuid.UUID
}

func (uc *GetAreaEstudoByIDUseCase) Execute(ctx context.Context, input GetOneAreaEstudoInput) (entities.AreaEstudo, error) <span class="cov0" title="0">{
        if input.ID == uuid.Nil </span><span class="cov0" title="0">{
                return entities.AreaEstudo{}, errors.New("ID da área de estudo é obrigatório")
        }</span>

        <span class="cov0" title="0">area, err := uc.Repo.FindByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.AreaEstudo{}, fmt.Errorf("erro ao buscar área de estudo com ID %s: %w", input.ID, err)
        }</span>

        <span class="cov0" title="0">return area, nil</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package areas_estudo

import (
        "context"
        "errors"
        "fmt"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
)

type ListAllAreasEstudoUseCase struct {
        Repo repos.AreaEstudoRepository
}

func (uc *ListAllAreasEstudoUseCase) Execute(ctx context.Context, limit, offset int) ([]entities.AreaEstudo, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10 // valor padrão
        }</span>
        <span class="cov0" title="0">if offset &lt; 0 </span><span class="cov0" title="0">{
                return nil, errors.New("offset não pode ser negativo")
        }</span>

        <span class="cov0" title="0">areas, err := uc.Repo.FindAll(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao listar áreas de estudo: %w", err)
        }</span>

        <span class="cov0" title="0">return areas, nil</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package areas_estudo

import (
        "context"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/utils"
)

// SearchAreaEstudoUseCase retorna áreas de estudo
type SearchAreaEstudoUseCase struct {
        Repo repos.AreaEstudoRepository
}

func (uc *SearchAreaEstudoUseCase) Execute(ctx context.Context, input utils.SearchInput) ([]entities.AreaEstudo, error) <span class="cov0" title="0">{
        utils.ApplyDefaults(&amp;input)
        return uc.Repo.Search(ctx, input.SearchText, input.Filter, input.Limit, input.Offset)
}</span>
</pre>
		
		<pre class="file" id="file101" style="display: none">package areas_estudo

import (
        "context"
        "fmt"
        "strings"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type UpdateAreaEstudoUseCase struct {
        Repo repos.AreaEstudoRepository
}

type UpdateAreaEstudoInput struct {
        ID          uuid.UUID
        Name        string
        Description string
}

func (uc *UpdateAreaEstudoUseCase) Execute(ctx context.Context, input UpdateAreaEstudoInput) (entities.AreaEstudo, error) <span class="cov0" title="0">{
        // Buscar área existente
        area, err := uc.Repo.FindByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.AreaEstudo{}, fmt.Errorf("área de estudo não encontrada: %w", err)
        }</span>

        // Normalizar entrada
        <span class="cov0" title="0">newName := strings.TrimSpace(input.Name)
        newDesc := strings.TrimSpace(input.Description)

        // Atualizar nome, se diferente
        if newName != "" &amp;&amp; newName != area.Name </span><span class="cov0" title="0">{
                exists, err := uc.Repo.ExistsByName(ctx, newName)
                if err != nil </span><span class="cov0" title="0">{
                        return entities.AreaEstudo{}, fmt.Errorf("erro ao verificar duplicidade: %w", err)
                }</span>
                <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                        return entities.AreaEstudo{}, fmt.Errorf("área de estudo com o nome '%s' já existe", newName)
                }</span>
                <span class="cov0" title="0">area.Name = newName</span>
        }

        // Atualizar descrição, se fornecida
        <span class="cov0" title="0">if newDesc != "" </span><span class="cov0" title="0">{
                area.Description = newDesc
        }</span>

        <span class="cov0" title="0">area.UpdatedAt = time.Now()

        // Persistir atualização
        if err := uc.Repo.Update(ctx, area); err != nil </span><span class="cov0" title="0">{
                return entities.AreaEstudo{}, fmt.Errorf("erro ao atualizar área de estudo: %w", err)
        }</span>

        <span class="cov0" title="0">return area, nil</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package departments

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type CreateDepartmentUseCase struct {
        Repo repos.DepartmentRepository
}

type CreateDepartmentInput struct {
        Name string
}

func (uc *CreateDepartmentUseCase) Execute(ctx context.Context, input CreateDepartmentInput) (entities.Department, error) <span class="cov0" title="0">{
        input.Name = strings.TrimSpace(input.Name)
        if input.Name == "" </span><span class="cov0" title="0">{
                return entities.Department{}, errors.New("o nome do departamento é obrigatório")
        }</span>

        <span class="cov0" title="0">exists, err := uc.Repo.ExistsByName(ctx, input.Name)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Department{}, fmt.Errorf("erro ao verificar existência do nome: %w", err)
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return entities.Department{}, fmt.Errorf("já existe um departamento com o nome '%s'", input.Name)
        }</span>

        <span class="cov0" title="0">now := time.Now()
        dept := entities.Department{
                ID:        uuid.New(),
                Name:      input.Name,
                CreatedAt: now,
                UpdatedAt: now,
        }

        if err := uc.Repo.Create(ctx, dept); err != nil </span><span class="cov0" title="0">{
                return entities.Department{}, fmt.Errorf("erro ao criar departamento: %w", err)
        }</span>

        <span class="cov0" title="0">return dept, nil</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package departments

import (
        "context"
        "errors"
        "fmt"

        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type DeleteDepartmentUseCase struct {
        Repo repos.DepartmentRepository
}

type DeleteDepartmentInput struct {
        ID uuid.UUID
}

func (uc *DeleteDepartmentUseCase) Execute(ctx context.Context, input DeleteDepartmentInput) error <span class="cov0" title="0">{
        if input.ID == uuid.Nil </span><span class="cov0" title="0">{
                return errors.New("ID do departamento inválido")
        }</span>

        <span class="cov0" title="0">err := uc.Repo.Delete(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erro ao excluir departamento: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">package departments

import (
        "context"
        "errors"
        "fmt"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type FindDepartmentByIDUseCase struct {
        Repo repos.DepartmentRepository
}

type FindDepartmentByIDInput struct {
        ID uuid.UUID
}

func (uc *FindDepartmentByIDUseCase) Execute(ctx context.Context, input FindDepartmentByIDInput) (entities.Department, error) <span class="cov0" title="0">{
        if input.ID == uuid.Nil </span><span class="cov0" title="0">{
                return entities.Department{}, errors.New("ID do departamento inválido")
        }</span>

        <span class="cov0" title="0">dept, err := uc.Repo.FindByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Department{}, fmt.Errorf("erro ao buscar departamento: %w", err)
        }</span>

        <span class="cov0" title="0">return dept, nil</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package departments

import (
        "context"
        "errors"
        "fmt"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
)

type FindAllDepartmentsUseCase struct {
        Repo repos.DepartmentRepository
}

func (uc *FindAllDepartmentsUseCase) Execute(ctx context.Context, limit, offset int) ([]entities.Department, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("o parâmetro 'limit' deve ser maior que zero")
        }</span>
        <span class="cov0" title="0">if offset &lt; 0 </span><span class="cov0" title="0">{
                return nil, errors.New("o parâmetro 'offset' não pode ser negativo")
        }</span>

        <span class="cov0" title="0">departments, err := uc.Repo.FindAll(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao listar departamentos: %w", err)
        }</span>

        <span class="cov0" title="0">return departments, nil</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package departments

import (
        "context"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/utils"
)

// SearchDepartmentUseCase retorna entidades completas
type SearchDepartmentUseCase struct {
        Repo repos.DepartmentRepository
}

func (uc *SearchDepartmentUseCase) Execute(ctx context.Context, input utils.SearchInput) ([]entities.Department, error) <span class="cov0" title="0">{
        utils.ApplyDefaults(&amp;input)
        return uc.Repo.Search(ctx, input.SearchText, input.Filter, input.Limit, input.Offset)
}</span>
</pre>
		
		<pre class="file" id="file107" style="display: none">package departments

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type UpdateDepartmentUseCase struct {
        Repo repos.DepartmentRepository
}

type UpdateDepartmentInput struct {
        ID   string
        Name string
}

func (uc *UpdateDepartmentUseCase) Execute(ctx context.Context, input UpdateDepartmentInput) (entities.Department, error) <span class="cov0" title="0">{
        // Validar e converter ID
        id, err := uuid.Parse(strings.TrimSpace(input.ID))
        if err != nil </span><span class="cov0" title="0">{
                return entities.Department{}, errors.New("ID do departamento é inválido")
        }</span>

        // Buscar o departamento atual
        <span class="cov0" title="0">dept, err := uc.Repo.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Department{}, fmt.Errorf("erro ao buscar departamento: %w", err)
        }</span>

        // Limpar e validar novo nome
        <span class="cov0" title="0">newName := strings.TrimSpace(input.Name)
        if newName != "" &amp;&amp; newName != dept.Name </span><span class="cov0" title="0">{
                // Verificar duplicidade
                exists, err := uc.Repo.ExistsByName(ctx, newName)
                if err != nil </span><span class="cov0" title="0">{
                        return entities.Department{}, fmt.Errorf("erro ao verificar nome duplicado: %w", err)
                }</span>
                <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                        return entities.Department{}, fmt.Errorf("já existe um departamento com o nome '%s'", newName)
                }</span>

                <span class="cov0" title="0">dept.Name = newName
                dept.UpdatedAt = time.Now()

                if err := uc.Repo.Update(ctx, dept); err != nil </span><span class="cov0" title="0">{
                        return entities.Department{}, fmt.Errorf("erro ao atualizar departamento: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return dept, nil</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package dependents

import (
        "context"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type CreateDependentInput struct {
        EmployeeID   uuid.UUID
        FullName     string
        Relationship string
        Gender       string
        DateOfBirth  string
        DocumentID   *uuid.UUID
}

type CreateDependentUseCase struct {
        Repo repos.DependentRepository
}

func (uc *CreateDependentUseCase) Execute(ctx context.Context, input CreateDependentInput) (entities.Dependent, error) <span class="cov0" title="0">{
        now := time.Now()

        dep := entities.Dependent{
                ID:           uuid.New(),
                EmployeeID:   input.EmployeeID,
                FullName:     vos.MustNewPersonalName(input.FullName),
                Relationship: vos.MustNewRelationshipType(input.Relationship),
                Gender:       vos.MustNewGender(input.Gender),
                DateOfBirth:  vos.MustNewBirthDate(input.DateOfBirth),
                IsActive:     true,
                CreatedAt:    now,
                UpdatedAt:    now,
        }

        if err := uc.Repo.Create(ctx, dep); err != nil </span><span class="cov0" title="0">{
                return entities.Dependent{}, err
        }</span>
        <span class="cov0" title="0">return dep, nil</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package dependents

import (
        "context"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type DeleteDependentUseCase struct {
        Repo repos.DependentRepository
}

func (uc *DeleteDependentUseCase) Execute(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return uc.Repo.Delete(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file110" style="display: none">package dependents

import (
        "context"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type FindDependentByIDUseCase struct {
        Repo repos.DependentRepository
}

func (uc *FindDependentByIDUseCase) Execute(ctx context.Context, id uuid.UUID) (entities.Dependent, error) <span class="cov0" title="0">{
        return uc.Repo.FindByID(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">package dependents

import (
        "context"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
)

type ListDependentsUseCase struct {
        Repo repos.DependentRepository
}

func (uc *ListDependentsUseCase) Execute(ctx context.Context, limit, offset int) ([]entities.Dependent, error) <span class="cov0" title="0">{
        return uc.Repo.FindAll(ctx, limit, offset)
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">package dependents

import (
        "context"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/utils"

        "github.com/google/uuid"
)

// SearchDependentsUseCase retorna entidades de dependentes
type SearchDependentsUseCase struct {
        Repo repos.DependentRepository
}

func (uc *SearchDependentsUseCase) Execute(ctx context.Context, input utils.SearchInput, empID *uuid.UUID) ([]entities.Dependent, error) <span class="cov0" title="0">{
        utils.ApplyDefaults(&amp;input)
        return uc.Repo.Search(ctx, input.SearchText, input.Filter, input.Limit, input.Offset, empID)
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">package dependents

import (
        "context"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type UpdateDependentInput struct {
        ID           uuid.UUID
        FullName     string
        Relationship string
        Gender       string
        DateOfBirth  string
        IsActive     bool
}

type UpdateDependentUseCase struct {
        Repo repos.DependentRepository
}

func (uc *UpdateDependentUseCase) Execute(ctx context.Context, input UpdateDependentInput) (entities.Dependent, error) <span class="cov0" title="0">{
        d, err := uc.Repo.FindByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Dependent{}, err
        }</span>

        <span class="cov0" title="0">if input.FullName != "" </span><span class="cov0" title="0">{
                d.FullName = vos.MustNewPersonalName(input.FullName)
        }</span>
        <span class="cov0" title="0">if input.Relationship != "" </span><span class="cov0" title="0">{
                d.Relationship = vos.MustNewRelationshipType(input.Relationship)
        }</span>
        <span class="cov0" title="0">if input.Gender != "" </span><span class="cov0" title="0">{
                d.Gender = vos.MustNewGender(input.Gender)
        }</span>
        <span class="cov0" title="0">if input.DateOfBirth != "" </span><span class="cov0" title="0">{
                d.DateOfBirth = vos.MustNewBirthDate(input.DateOfBirth)
        }</span>

        <span class="cov0" title="0">d.IsActive = input.IsActive

        d.UpdatedAt = time.Now()

        if err := uc.Repo.Update(ctx, d); err != nil </span><span class="cov0" title="0">{
                return entities.Dependent{}, err
        }</span>
        <span class="cov0" title="0">return d, nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package distritos

import (
        "context"
        "fmt"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type CreateDistrictUseCase struct {
        Repo          repos.DistrictRepository
        MunicipioRepo repos.MunicipalityRepository
}

type CreateDistrictInput struct {
        Name        string
        MunicipioID uuid.UUID
}

func (uc *CreateDistrictUseCase) Execute(ctx context.Context, input CreateDistrictInput) (entities.District, error) <span class="cov0" title="0">{
        // Verificar se o distrito já existe no município
        exists, err := uc.Repo.ExistsByNameAndMunicipio(ctx, input.Name, input.MunicipioID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.District{}, fmt.Errorf("erro ao verificar duplicidade do distrito: %w", err)
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return entities.District{}, fmt.Errorf("o distrito '%s' já existe nesse município", input.Name)
        }</span>

        // Validar existência do município
        <span class="cov0" title="0">existsMun, err := uc.MunicipioRepo.ExistsByID(ctx, input.MunicipioID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.District{}, fmt.Errorf("erro ao validar município: %w", err)
        }</span>
        <span class="cov0" title="0">if !existsMun </span><span class="cov0" title="0">{
                return entities.District{}, fmt.Errorf("município com ID %s não encontrado", input.MunicipioID)
        }</span>

        // Criar entidade
        <span class="cov0" title="0">now := time.Now()
        district := entities.District{
                ID:             uuid.New(),
                Name:           vos.MustNewDistrict(input.Name),
                MunicipalityID: input.MunicipioID,
                CreatedAt:      now,
                UpdatedAt:      now,
        }

        // Persistir
        if err := uc.Repo.Create(ctx, district); err != nil </span><span class="cov0" title="0">{
                return entities.District{}, fmt.Errorf("erro ao criar distrito: %w", err)
        }</span>

        <span class="cov0" title="0">return district, nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package distritos

import (
        "context"
        "fmt"

        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type DeleteDistrictUseCase struct {
        Repo repos.DistrictRepository
}

type DeleteDistrictInput struct {
        ID uuid.UUID
}

func (uc *DeleteDistrictUseCase) Execute(ctx context.Context, input DeleteDistrictInput) error <span class="cov0" title="0">{
        // Verificar se o distrito existe antes de tentar excluir
        exists, err := uc.Repo.ExistsByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erro ao verificar existência do distrito: %w", err)
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("distrito com ID %s não encontrado", input.ID)
        }</span>

        // Excluir o distrito
        <span class="cov0" title="0">if err := uc.Repo.Delete(ctx, input.ID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erro ao excluir distrito: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package distritos

import (
        "context"
        "fmt"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
)

type ListAllDistrictsUseCase struct {
        Repo repos.DistrictRepository
}

func (uc *ListAllDistrictsUseCase) Execute(ctx context.Context, limit, offset int) ([]entities.District, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10 // Valor padrão
        }</span>
        <span class="cov0" title="0">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">districts, err := uc.Repo.FindAll(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao listar distritos: %w", err)
        }</span>
        <span class="cov0" title="0">return districts, nil</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package distritos

import (
        "context"
        "errors"
        "fmt"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type FindDistrictByIDUseCase struct {
        Repo repos.DistrictRepository
}

type FindDistrictByIDInput struct {
        ID uuid.UUID
}

func (uc *FindDistrictByIDUseCase) Execute(ctx context.Context, input FindDistrictByIDInput) (entities.District, error) <span class="cov0" title="0">{
        if input.ID == uuid.Nil </span><span class="cov0" title="0">{
                return entities.District{}, errors.New("ID do distrito é obrigatório")
        }</span>

        <span class="cov0" title="0">district, err := uc.Repo.FindByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.District{}, fmt.Errorf("erro ao buscar distrito por ID: %w", err)
        }</span>

        <span class="cov0" title="0">return district, nil</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package distritos

import (
        "context"
        "rhapp/internal/domain/dtos"
        "rhapp/internal/domain/repos"
        "rhapp/internal/utils"
)

// SearchDistrictUseCase retorna distritos com nome de município
type SearchDistrictUseCase struct {
        Repo repos.DistrictRepository
}

func (uc *SearchDistrictUseCase) Execute(ctx context.Context, input utils.SearchInput) ([]dtos.DistritoResultDTO, error) <span class="cov0" title="0">{
        utils.ApplyDefaults(&amp;input)
        return uc.Repo.Search(ctx, input.SearchText, input.Filter, input.Limit, input.Offset)
}</span>
</pre>
		
		<pre class="file" id="file119" style="display: none">package distritos

import (
        "context"
        "errors"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"
        "time"

        "github.com/google/uuid"
)

type UpdateDistrictUseCase struct {
        Repo             repos.DistrictRepository
        MunicipalityRepo repos.MunicipalityRepository
}

type UpdateDistrictInput struct {
        ID          uuid.UUID
        Name        string
        MunicipioID uuid.UUID
}

func (uc *UpdateDistrictUseCase) Execute(ctx context.Context, input UpdateDistrictInput) (entities.District, error) <span class="cov0" title="0">{
        d, err := uc.Repo.FindByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.District{}, err
        }</span>

        <span class="cov0" title="0">if input.Name != "" </span><span class="cov0" title="0">{
                d.Name = vos.MustNewDistrict(input.Name)
        }</span>

        <span class="cov0" title="0">if input.MunicipioID != uuid.Nil </span><span class="cov0" title="0">{
                if ok, err := uc.MunicipalityRepo.ExistsByID(ctx, input.MunicipioID); err != nil || !ok </span><span class="cov0" title="0">{
                        return entities.District{}, errors.New("municipio inválido")
                }</span>
                <span class="cov0" title="0">d.MunicipalityID = input.MunicipioID</span>
        }
        <span class="cov0" title="0">d.UpdatedAt = time.Now()

        if err := uc.Repo.Update(ctx, d); err != nil </span><span class="cov0" title="0">{
                return entities.District{}, err
        }</span>

        <span class="cov0" title="0">return d, nil</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">package documents_uc

import (
        "context"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type CreateDocumentInput struct {
        OwnerType string
        OwnerID   uuid.UUID
        Type      string
        FileName  string
        FileURL   string
        Extension string
        IsActive  bool
}

type CreateDocumentUseCase struct {
        Repo repos.DocumentRepository
}

func (uc *CreateDocumentUseCase) Execute(ctx context.Context, input CreateDocumentInput) (entities.Document, error) <span class="cov0" title="0">{
        doc := entities.Document{
                ID:         uuid.New(),
                OwnerType:  vos.DocumentOwnerType(input.OwnerType),
                OwnerID:    input.OwnerID,
                Type:       vos.MustNewDocumentType(input.Type),
                FileName:   vos.MustNewFilename(input.FileName),
                FileURL:    vos.MustNewDocumentURL(input.FileURL),
                Extension:  vos.MustNewFileExtension(input.Extension),
                IsActive:   input.IsActive,
                UploadedAt: time.Now(),
        }

        if err := uc.Repo.Create(ctx, doc); err != nil </span><span class="cov0" title="0">{
                return entities.Document{}, err
        }</span>
        <span class="cov0" title="0">return doc, nil</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package documents_uc

import (
        "context"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type DeleteDocumentUseCase struct {
        Repo repos.DocumentRepository
}

func (uc *DeleteDocumentUseCase) Execute(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return uc.Repo.Delete(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file122" style="display: none">package documents_uc

import (
        "context"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
)

type ListDocumentsUseCase struct {
        Repo repos.DocumentRepository
}

func (uc *ListDocumentsUseCase) Execute(ctx context.Context, limit, offset int) ([]entities.Document, error) <span class="cov0" title="0">{
        return uc.Repo.FindAll(ctx, limit, offset)
}</span>
</pre>
		
		<pre class="file" id="file123" style="display: none">package documents_uc

import (
        "context"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type FindDocumentByIDUseCase struct {
        Repo repos.DocumentRepository
}

func (uc *FindDocumentByIDUseCase) Execute(ctx context.Context, id uuid.UUID) (entities.Document, error) <span class="cov0" title="0">{
        return uc.Repo.FindByID(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file124" style="display: none">package documents_uc

import (
        "context"
        "fmt"

        "rhapp/internal/domain/dtos"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type UpdateDocumentInput struct {
        ID          uuid.UUID
        DocumentDTO dtos.UpdateDocumentDTO
}

type UpdateDocumentUseCase struct {
        Repo repos.DocumentRepository
}

func (uc *UpdateDocumentUseCase) Execute(ctx context.Context, input UpdateDocumentInput) (entities.Document, error) <span class="cov0" title="0">{

        // Buscar o funcionário existente
        doc, err := uc.Repo.FindByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Document{}, fmt.Errorf("documentos não encontrado: %w", err)
        }</span>

        // Aplicar atualizações no documento
        <span class="cov0" title="0">if err := dtos.ApplyUpdateToDocument(&amp;doc, input.DocumentDTO); err != nil </span><span class="cov0" title="0">{
                return entities.Document{}, fmt.Errorf("erro ao aplicar atualizações: %w", err)
        }</span>

        <span class="cov0" title="0">if err := uc.Repo.Update(ctx, doc); err != nil </span><span class="cov0" title="0">{
                return entities.Document{}, err
        }</span>
        <span class="cov0" title="0">return doc, nil</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package education

import (
        "context"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type CreateEducationHistoryInput struct {
        EmployeeID   uuid.UUID
        Institution  string
        Degree       string
        AreaEstudoID uuid.UUID
        StartDate    time.Time
        EndDate      *time.Time
        Description  string
}

type CreateEducationHistoryUseCase struct {
        Repo repos.EducationHistoryRepository
}

func (uc *CreateEducationHistoryUseCase) Execute(ctx context.Context, input CreateEducationHistoryInput) (entities.EducationHistory, error) <span class="cov0" title="0">{
        history := entities.EducationHistory{
                ID:           uuid.New(),
                EmployeeID:   input.EmployeeID,
                Institution:  input.Institution,
                Degree:       vos.MustNewSchoolDegree(input.Degree),
                AreaEstudoID: input.AreaEstudoID,
                StartDate:    input.StartDate,
                EndDate:      *input.EndDate,
                Description:  input.Description,
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        if err := uc.Repo.Create(ctx, history); err != nil </span><span class="cov0" title="0">{
                return entities.EducationHistory{}, err
        }</span>
        <span class="cov0" title="0">return history, nil</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package education

import (
        "context"

        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type DeleteEducationHistoryUseCase struct {
        Repo repos.EducationHistoryRepository
}

func (uc *DeleteEducationHistoryUseCase) Execute(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return uc.Repo.Delete(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file127" style="display: none">package education

import (
        "context"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type ListEducationHistoriesUseCase struct {
        Repo repos.EducationHistoryRepository
}

func (uc *ListEducationHistoriesUseCase) Execute(ctx context.Context, employeeID uuid.UUID, limit, offset int) ([]entities.EducationHistory, error) <span class="cov0" title="0">{
        return uc.Repo.FindAllByEmployee(ctx, employeeID, limit, offset)
}</span>
</pre>
		
		<pre class="file" id="file128" style="display: none">package education

import (
        "context"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type FindEducationHistoryByIDUseCase struct {
        Repo repos.EducationHistoryRepository
}

func (uc *FindEducationHistoryByIDUseCase) Execute(ctx context.Context, id uuid.UUID) (entities.EducationHistory, error) <span class="cov0" title="0">{
        return uc.Repo.FindByID(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file129" style="display: none">package education

import (
        "context"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type UpdateEducationHistoryInput struct {
        ID           uuid.UUID
        Institution  string
        Degree       string
        AreaEstudoID uuid.UUID
        StartDate    time.Time
        EndDate      *time.Time
        Description  string
}

type UpdateEducationHistoryUseCase struct {
        Repo repos.EducationHistoryRepository
}

func (uc *UpdateEducationHistoryUseCase) Execute(ctx context.Context, input UpdateEducationHistoryInput) (entities.EducationHistory, error) <span class="cov0" title="0">{
        h, err := uc.Repo.FindByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.EducationHistory{}, err
        }</span>

        <span class="cov0" title="0">h.Institution = input.Institution
        h.Degree = vos.MustNewSchoolDegree(input.Degree)
        h.AreaEstudoID = input.AreaEstudoID
        h.StartDate = input.StartDate
        h.EndDate = *input.EndDate
        h.Description = input.Description
        h.UpdatedAt = time.Now()

        if err := uc.Repo.Update(ctx, h); err != nil </span><span class="cov0" title="0">{
                return entities.EducationHistory{}, err
        }</span>
        <span class="cov0" title="0">return h, nil</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">package employee_status

import (
        "context"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type CreateEmployeeStatusInput struct {
        EmployeeID uuid.UUID
        Status     string
        Reason     string
        StartDate  time.Time
        EndDate    *time.Time
        IsCurrent  bool
}

type CreateEmployeeStatusUseCase struct {
        Repo repos.EmployeeStatusRepository
}

func (uc *CreateEmployeeStatusUseCase) Execute(ctx context.Context, input CreateEmployeeStatusInput) (entities.EmployeeStatus, error) <span class="cov0" title="0">{
        now := time.Now()
        s := entities.EmployeeStatus{
                ID:         uuid.New(),
                EmployeeID: input.EmployeeID,
                Status:     vos.MustNewEmployeeStatusValue(input.Status),
                Reason:     vos.MustNewStatusReason(input.Reason),
                StartDate:  input.StartDate,
                EndDate:    input.EndDate,
                IsCurrent:  input.IsCurrent,
                CreatedAt:  now,
                UpdatedAt:  now,
        }
        if err := uc.Repo.Create(ctx, s); err != nil </span><span class="cov0" title="0">{
                return entities.EmployeeStatus{}, err
        }</span>
        <span class="cov0" title="0">return s, nil</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">package employee_status

import (
        "context"

        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type DeleteEmployeeStatusUseCase struct {
        Repo repos.EmployeeStatusRepository
}

func (uc *DeleteEmployeeStatusUseCase) Execute(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return uc.Repo.Delete(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file132" style="display: none">package employee_status

import (
        "context"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type ListEmployeeStatusByEmployeeUseCase struct {
        Repo repos.EmployeeStatusRepository
}

func (uc *ListEmployeeStatusByEmployeeUseCase) Execute(ctx context.Context, employeeID uuid.UUID, limit, offset int) ([]entities.EmployeeStatus, error) <span class="cov0" title="0">{
        return uc.Repo.FindAllByEmployee(ctx, employeeID, limit, offset)
}</span>
</pre>
		
		<pre class="file" id="file133" style="display: none">package employee_status

import (
        "context"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type FindEmployeeStatusByIDUseCase struct {
        Repo repos.EmployeeStatusRepository
}

func (uc *FindEmployeeStatusByIDUseCase) Execute(ctx context.Context, id uuid.UUID) (entities.EmployeeStatus, error) <span class="cov0" title="0">{
        return uc.Repo.FindByID(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file134" style="display: none">package employee_status

import (
        "context"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type UpdateEmployeeStatusInput struct {
        ID        uuid.UUID
        Status    string
        Reason    string
        StartDate time.Time
        EndDate   *time.Time
        IsCurrent bool
}

type UpdateEmployeeStatusUseCase struct {
        Repo repos.EmployeeStatusRepository
}

func (uc *UpdateEmployeeStatusUseCase) Execute(ctx context.Context, input UpdateEmployeeStatusInput) (entities.EmployeeStatus, error) <span class="cov0" title="0">{
        s, err := uc.Repo.FindByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.EmployeeStatus{}, err
        }</span>

        <span class="cov0" title="0">s.Status = vos.MustNewEmployeeStatusValue(input.Status)
        s.Reason = vos.MustNewStatusReason(input.Reason)
        s.StartDate = input.StartDate
        s.EndDate = input.EndDate
        s.IsCurrent = input.IsCurrent
        s.UpdatedAt = time.Now()

        if err := uc.Repo.Update(ctx, s); err != nil </span><span class="cov0" title="0">{
                return entities.EmployeeStatus{}, err
        }</span>

        <span class="cov0" title="0">return s, nil</span>
}
</pre>
		
		<pre class="file" id="file135" style="display: none">package employees

import (
        "context"
        "errors"
        "fmt"
        "time"

        "rhapp/internal/domain/dtos"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type CreateEmployeeInput struct {
        dtos.CreateEmployeeDTO
}

type CreateEmployeeUseCase struct {
        Repo repos.EmployeeRepository
}

func (uc *CreateEmployeeUseCase) Execute(ctx context.Context, input CreateEmployeeInput) (entities.Employee, error) <span class="cov0" title="0">{
        emp, err := toEmployeeEntity(input)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, fmt.Errorf("erro ao montar entidade: %w", err)
        }</span>

        // Verifica se tem pelo menos 18 anos
        <span class="cov0" title="0">if age := time.Since(emp.DateOfBirth).Hours() / 24 / 365.25; age &lt; 18 </span><span class="cov0" title="0">{
                return entities.Employee{}, errors.New("funcionário deve ter pelo menos 18 anos")
        }</span>

        <span class="cov0" title="0">if err := uc.Repo.Create(ctx, emp); err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, fmt.Errorf("erro ao criar funcionário: %w", err)
        }</span>

        <span class="cov0" title="0">return emp, nil</span>
}

func toEmployeeEntity(input CreateEmployeeInput) (entities.Employee, error) <span class="cov0" title="0">{
        parseDate := func(s string) (time.Time, error) </span><span class="cov0" title="0">{
                return time.Parse("2006-01-02", s)
        }</span>
        <span class="cov0" title="0">parseUUID := func(s string) (uuid.UUID, error) </span><span class="cov0" title="0">{
                return uuid.Parse(s)
        }</span>

        <span class="cov0" title="0">dateOfBirth, err := parseDate(input.DateOfBirth)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, fmt.Errorf("data de nascimento inválida: %w", err)
        }</span>

        <span class="cov0" title="0">hiringDate, err := parseDate(input.HiringDate)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, fmt.Errorf("data de contratação inválida: %w", err)
        }</span>

        <span class="cov0" title="0">departmentID, err := parseUUID(input.DepartmentID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, fmt.Errorf("ID de departamento inválido: %w", err)
        }</span>

        <span class="cov0" title="0">positionID, err := parseUUID(input.PositionID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, fmt.Errorf("ID de cargo inválido: %w", err)
        }</span>

        <span class="cov0" title="0">districtID, err := parseUUID(input.DistrictID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, fmt.Errorf("ID de distrito inválido: %w", err)
        }</span>

        <span class="cov0" title="0">var supervisorID *uuid.UUID
        if input.SupervisorID != "" </span><span class="cov0" title="0">{
                id, err := parseUUID(input.SupervisorID)
                if err != nil </span><span class="cov0" title="0">{
                        return entities.Employee{}, fmt.Errorf("ID de supervisor inválido: %w", err)
                }</span>
                <span class="cov0" title="0">supervisorID = &amp;id</span>
        }

        <span class="cov0" title="0">now := time.Now()

        // Criação com Value Objects (usando funções que encapsulam erros internos)
        return entities.Employee{
                ID:             uuid.New(),
                EmployeeNumber: input.EmployeeNumber,
                FullName:       vos.MustNewPersonalName(input.FullName),
                Gender:         vos.MustNewGender(input.Gender),
                DateOfBirth:    dateOfBirth,
                Nationality:    vos.MustNewNationality(input.Nationality),
                MaritalStatus:  vos.MustNewMaritalStatus(input.MaritalStatus),
                PhoneNumber:    vos.MustNewPhoneNumber(input.PhoneNumber),
                Email:          vos.MustNewEmail(input.Email),
                BI:             vos.MustNewBI(input.BI),
                IBAN:           vos.MustNewIBAN(input.IBAN),
                Address:        vos.MustNewAddress(input.Address),
                DepartmentID:   departmentID,
                PositionID:     positionID,
                DistrictID:     districtID,
                HiringDate:     hiringDate,
                ContractType:   vos.MustNewContractType(input.ContractType),
                Salary:         vos.MustNewSalary(input.Salary),
                SocialSecurity: vos.MustNewSocialSecurity(input.SocialSecurity),
                SupervisorID:   supervisorID,
                IsActive:       true,
                CreatedAt:      now,
                UpdatedAt:      now,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">package employees

import (
        "context"
        "errors"

        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type DeleteEmployeeUseCase struct {
        Repo repos.EmployeeRepository
}

// Execute exclui um funcionário com base no ID fornecido.
func (uc *DeleteEmployeeUseCase) Execute(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        if id == uuid.Nil </span><span class="cov0" title="0">{
                return errors.New("ID do funcionário é obrigatório")
        }</span>

        <span class="cov0" title="0">return uc.Repo.Delete(ctx, id)</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">package employees

import (
        "context"
        "errors"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type FindEmployeeByIDUseCase struct {
        Repo repos.EmployeeRepository
}

// Execute busca um funcionário pelo ID fornecido.
func (uc *FindEmployeeByIDUseCase) Execute(ctx context.Context, id uuid.UUID) (entities.Employee, error) <span class="cov0" title="0">{
        if id == uuid.Nil </span><span class="cov0" title="0">{
                return entities.Employee{}, errors.New("ID do funcionário é obrigatório")
        }</span>
        <span class="cov0" title="0">return uc.Repo.FindByID(ctx, id)</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">package employees

import (
        "context"
        "fmt"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
)

type ListEmployeesUseCase struct {
        Repo repos.EmployeeRepository
}

func (uc *ListEmployeesUseCase) Execute(ctx context.Context, limit, offset int) ([]entities.Employee, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10 // Valor padrão
        }</span>
        <span class="cov0" title="0">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">employees, err := uc.Repo.List(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao listar funcionários: %w", err)
        }</span>
        <span class="cov0" title="0">return employees, nil</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">package employees

import (
        "context"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/utils"
)

// SearchEmployeesUseCase retorna entidades de funcionários
type SearchEmployeesUseCase struct {
        Repo repos.EmployeeRepository
}

func (uc *SearchEmployeesUseCase) Execute(ctx context.Context, input utils.SearchInput) ([]entities.Employee, error) <span class="cov0" title="0">{
        utils.ApplyDefaults(&amp;input)
        return uc.Repo.Search(ctx, input.SearchText, input.Filter, input.Limit, input.Offset)
}</span>
</pre>
		
		<pre class="file" id="file140" style="display: none">package employees

import (
        "context"
        "fmt"

        "rhapp/internal/domain/dtos"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type UpdateEmployeeInput struct {
        ID          uuid.UUID
        EmployeeDTo dtos.UpdateEmployeeDTO
}

type UpdateEmployeeUseCase struct {
        Repo repos.EmployeeRepository
}

func (uc *UpdateEmployeeUseCase) Execute(ctx context.Context, input UpdateEmployeeInput) (entities.Employee, error) <span class="cov0" title="0">{
        // Buscar o funcionário existente
        emp, err := uc.Repo.FindByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, fmt.Errorf("funcionário não encontrado: %w", err)
        }</span>

        // Aplicar atualizações no funcionário
        <span class="cov0" title="0">if err := dtos.ApplyUpdateToEmployee(&amp;emp, input.EmployeeDTo); err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, fmt.Errorf("erro ao aplicar atualizações: %w", err)
        }</span>

        // Persistir alterações
        <span class="cov0" title="0">if err := uc.Repo.Update(ctx, emp); err != nil </span><span class="cov0" title="0">{
                return entities.Employee{}, fmt.Errorf("erro ao atualizar funcionário: %w", err)
        }</span>

        <span class="cov0" title="0">return emp, nil</span>
}
</pre>
		
		<pre class="file" id="file141" style="display: none">package municipios

import (
        "context"
        "fmt"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type CreateMunicipalityInput struct {
        Name       string
        ProvinceID uuid.UUID
}

type CreateMunicipalityUseCase struct {
        Repo      repos.MunicipalityRepository
        ProvinceR repos.ProvinceRepository
}

func (uc *CreateMunicipalityUseCase) Execute(ctx context.Context, input CreateMunicipalityInput) (entities.Municipality, error) <span class="cov0" title="0">{
        // Verificar se município já existe na província
        exists, err := uc.Repo.ExistsByNameAndProvince(ctx, input.Name, input.ProvinceID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Municipality{}, fmt.Errorf("erro ao verificar duplicidade de município: %w", err)
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return entities.Municipality{}, fmt.Errorf("município com o nome '%s' já existe na província", input.Name)
        }</span>

        // Verificar se província existe
        <span class="cov0" title="0">ok, err := uc.ProvinceR.ExistsByID(ctx, input.ProvinceID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Municipality{}, fmt.Errorf("erro ao validar província: %w", err)
        }</span>
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                return entities.Municipality{}, fmt.Errorf("província com ID '%s' não encontrada", input.ProvinceID)
        }</span>

        // Criar VO
        <span class="cov0" title="0">municipioName, err := vos.NewMunicipality(input.Name)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Municipality{}, fmt.Errorf("nome de município inválido: %w", err)
        }</span>

        <span class="cov0" title="0">now := time.Now()

        m := entities.Municipality{
                ID:         uuid.New(),
                Name:       municipioName,
                ProvinceID: input.ProvinceID,
                CreatedAt:  now,
                UpdatedAt:  now,
        }

        if err := uc.Repo.Create(ctx, m); err != nil </span><span class="cov0" title="0">{
                return entities.Municipality{}, fmt.Errorf("erro ao criar município: %w", err)
        }</span>

        <span class="cov0" title="0">return m, nil</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">package municipios

import (
        "context"
        "errors"

        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type DeleteMunicipalityUseCase struct {
        Repo repos.MunicipalityRepository
}

// Execute exclui um município pelo ID.
func (uc *DeleteMunicipalityUseCase) Execute(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{

        if id == uuid.Nil </span><span class="cov0" title="0">{
                return errors.New("ID do funcionário é obrigatório")
        }</span>

        <span class="cov0" title="0">return uc.Repo.Delete(ctx, id)</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">package municipios

import (
        "context"
        "fmt"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
)

type ListMunicipalitiesUseCase struct {
        Repo repos.MunicipalityRepository
}

// Execute retorna uma lista paginada de municípios.
func (uc *ListMunicipalitiesUseCase) Execute(ctx context.Context, limit, offset int) ([]entities.Municipality, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10 // Valor padrão
        }</span>
        <span class="cov0" title="0">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">municipalities, err := uc.Repo.FindAll(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao listar municípios: %w", err)
        }</span>
        <span class="cov0" title="0">return municipalities, nil</span>
}
</pre>
		
		<pre class="file" id="file144" style="display: none">package municipios

import (
        "context"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type FindMunicipalityByIDUseCase struct {
        Repo repos.MunicipalityRepository
}

func (uc *FindMunicipalityByIDUseCase) Execute(ctx context.Context, id uuid.UUID) (entities.Municipality, error) <span class="cov0" title="0">{
        return uc.Repo.FindByID(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file145" style="display: none">package municipios

import (
        "context"
        "rhapp/internal/domain/dtos"
        "rhapp/internal/domain/repos"
        "rhapp/internal/utils"
)

// SearchMunicipalityUseCase retorna DTOs customizados de municípios
type SearchMunicipalityUseCase struct {
        Repo repos.MunicipalityRepository
}

func (uc *SearchMunicipalityUseCase) Execute(ctx context.Context, input utils.SearchInput) ([]dtos.MunicipioResultDTO, error) <span class="cov0" title="0">{
        utils.ApplyDefaults(&amp;input)
        return uc.Repo.Search(ctx, input.SearchText, input.Filter, input.Limit, input.Offset)
}</span>
</pre>
		
		<pre class="file" id="file146" style="display: none">package municipios

import (
        "context"
        "errors"
        "fmt"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type UpdateMunicipalityInput struct {
        ID         uuid.UUID
        Name       string
        ProvinceID uuid.UUID
}

type UpdateMunicipalityUseCase struct {
        Repo      repos.MunicipalityRepository
        ProvinceR repos.ProvinceRepository
}

func (uc *UpdateMunicipalityUseCase) Execute(ctx context.Context, input UpdateMunicipalityInput) (entities.Municipality, error) <span class="cov0" title="0">{
        municipality, err := uc.Repo.FindByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Municipality{}, fmt.Errorf("município não encontrado: %w", err)
        }</span>

        <span class="cov0" title="0">if name := input.Name; name != "" &amp;&amp; name != municipality.Name.String() </span><span class="cov0" title="0">{
                newName, err := vos.NewMunicipality(name)
                if err != nil </span><span class="cov0" title="0">{
                        return entities.Municipality{}, fmt.Errorf("nome inválido: %w", err)
                }</span>
                <span class="cov0" title="0">municipality.Name = newName</span>
        }

        <span class="cov0" title="0">if input.ProvinceID != uuid.Nil &amp;&amp; input.ProvinceID != municipality.ProvinceID </span><span class="cov0" title="0">{
                valid, err := uc.ProvinceR.ExistsByID(ctx, input.ProvinceID)
                if err != nil </span><span class="cov0" title="0">{
                        return entities.Municipality{}, fmt.Errorf("erro ao verificar província: %w", err)
                }</span>
                <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                        return entities.Municipality{}, errors.New("província inválida")
                }</span>
                <span class="cov0" title="0">municipality.ProvinceID = input.ProvinceID</span>
        }

        <span class="cov0" title="0">municipality.UpdatedAt = time.Now()

        if err := uc.Repo.Update(ctx, municipality); err != nil </span><span class="cov0" title="0">{
                return entities.Municipality{}, fmt.Errorf("erro ao atualizar município: %w", err)
        }</span>

        <span class="cov0" title="0">return municipality, nil</span>
}
</pre>
		
		<pre class="file" id="file147" style="display: none">package positions

import (
        "context"
        "errors"
        "fmt"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type CreatePositionUseCase struct {
        Repo     repos.PositionRepository
        DeptRepo repos.DepartmentRepository
}

type CreatePositionInput struct {
        Name         string
        DepartmentID uuid.UUID
}

func (uc *CreatePositionUseCase) Execute(ctx context.Context, input CreatePositionInput) (entities.Position, error) <span class="cov0" title="0">{
        // Verificar se o departamento existe
        exists, err := uc.DeptRepo.ExistsByID(ctx, input.DepartmentID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Position{}, fmt.Errorf("erro ao verificar departamento: %w", err)
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return entities.Position{}, errors.New("departamento não encontrado")
        }</span>

        // Verificar duplicidade
        <span class="cov0" title="0">duplicated, err := uc.Repo.ExistsByNameAndDepartment(ctx, input.Name, input.DepartmentID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Position{}, fmt.Errorf("erro ao verificar duplicidade: %w", err)
        }</span>
        <span class="cov0" title="0">if duplicated </span><span class="cov0" title="0">{
                return entities.Position{}, fmt.Errorf("posição com o nome '%s' já existe neste departamento", input.Name)
        }</span>

        <span class="cov0" title="0">now := time.Now()
        position := entities.Position{
                ID:           uuid.New(),
                Name:         input.Name,
                DepartmentID: input.DepartmentID,
                CreatedAt:    now,
                UpdatedAt:    now,
        }

        if err := uc.Repo.Create(ctx, position); err != nil </span><span class="cov0" title="0">{
                return entities.Position{}, fmt.Errorf("erro ao criar posição: %w", err)
        }</span>

        <span class="cov0" title="0">return position, nil</span>
}
</pre>
		
		<pre class="file" id="file148" style="display: none">package positions

import (
        "context"
        "fmt"

        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type DeletePositionUseCase struct {
        Repo repos.PositionRepository
}

func (uc *DeletePositionUseCase) Execute(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        exists, err := uc.Repo.ExistsByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("posição com ID %s não encontrada", id)
        }</span>
        <span class="cov0" title="0">return uc.Repo.Delete(ctx, id)</span>
}
</pre>
		
		<pre class="file" id="file149" style="display: none">package positions

import (
        "context"
        "fmt"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
)

type FindAllPositionsUseCase struct {
        Repo repos.PositionRepository
}

// Execute retorna todas as posições com suporte a paginação.
func (uc *FindAllPositionsUseCase) Execute(ctx context.Context, limit, offset int) ([]entities.Position, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10 // valor padrão
        }</span>
        <span class="cov0" title="0">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">positions, err := uc.Repo.FindAll(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao buscar posições: %w", err)
        }</span>
        <span class="cov0" title="0">return positions, nil</span>
}
</pre>
		
		<pre class="file" id="file150" style="display: none">package positions

import (
        "context"
        "errors"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type FindPositionByIDUseCase struct {
        Repo repos.PositionRepository
}

type FindPositionByIDInput struct {
        ID uuid.UUID
}

func (uc *FindPositionByIDUseCase) Execute(ctx context.Context, input FindPositionByIDInput) (entities.Position, error) <span class="cov0" title="0">{
        if input.ID == uuid.Nil </span><span class="cov0" title="0">{
                return entities.Position{}, errors.New("ID da posição é obrigatório")
        }</span>

        <span class="cov0" title="0">position, err := uc.Repo.FindByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                // return entities.Position{}, fmt.Errorf("erro ao buscar posição: %w", err)
                return entities.Position{}, err
        }</span>

        <span class="cov0" title="0">return position, nil</span>
}
</pre>
		
		<pre class="file" id="file151" style="display: none">package positions

import (
        "context"
        "rhapp/internal/domain/dtos"
        "rhapp/internal/domain/repos"
        "rhapp/internal/utils"
)

// SearchPositionUseCase retorna DTOs de posições com nome de departamento
type SearchPositionUseCase struct {
        Repo repos.PositionRepository
}

func (uc *SearchPositionUseCase) Execute(ctx context.Context, input utils.SearchInput) ([]dtos.PositionResultDTO, error) <span class="cov0" title="0">{
        utils.ApplyDefaults(&amp;input)
        return uc.Repo.Search(ctx, input.SearchText, input.Filter, input.Limit, input.Offset)
}</span>
</pre>
		
		<pre class="file" id="file152" style="display: none">package positions

import (
        "context"
        "errors"
        "fmt"
        "strings"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type UpdatePositionUseCase struct {
        Repo     repos.PositionRepository
        DeptRepo repos.DepartmentRepository
}

type UpdatePositionInput struct {
        ID           uuid.UUID
        Name         string
        DepartmentID uuid.UUID
}

func (uc *UpdatePositionUseCase) Execute(ctx context.Context, input UpdatePositionInput) (entities.Position, error) <span class="cov0" title="0">{
        if input.ID == uuid.Nil </span><span class="cov0" title="0">{
                return entities.Position{}, errors.New("ID da posição é obrigatório")
        }</span>
        <span class="cov0" title="0">if input.DepartmentID == uuid.Nil </span><span class="cov0" title="0">{
                return entities.Position{}, errors.New("ID do departamento é obrigatório")
        }</span>

        // Buscar posição existente
        <span class="cov0" title="0">position, err := uc.Repo.FindByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Position{}, fmt.Errorf("posição não encontrada: %w", err)
        }</span>

        // Validar e atualizar nome se informado
        <span class="cov0" title="0">if input.Name != "" </span><span class="cov0" title="0">{
                input.Name = strings.TrimSpace(input.Name)
                if input.Name == "" </span><span class="cov0" title="0">{
                        return entities.Position{}, errors.New("o nome da posição não pode ser vazio")
                }</span>
                <span class="cov0" title="0">if input.Name != position.Name </span><span class="cov0" title="0">{
                        exists, err := uc.Repo.ExistsByNameAndDepartment(ctx, input.Name, input.DepartmentID)
                        if err != nil </span><span class="cov0" title="0">{
                                return entities.Position{}, fmt.Errorf("erro ao verificar duplicidade: %w", err)
                        }</span>
                        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                                return entities.Position{}, fmt.Errorf("posição com o nome '%s' já existe neste departamento", input.Name)
                        }</span>
                        <span class="cov0" title="0">position.Name = input.Name</span>
                }
        }

        // Validar existência do departamento
        <span class="cov0" title="0">deptExists, err := uc.DeptRepo.ExistsByID(ctx, input.DepartmentID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Position{}, fmt.Errorf("erro ao verificar departamento: %w", err)
        }</span>
        <span class="cov0" title="0">if !deptExists </span><span class="cov0" title="0">{
                return entities.Position{}, errors.New("departamento não encontrado")
        }</span>
        <span class="cov0" title="0">position.DepartmentID = input.DepartmentID

        // Persistir atualização
        if err := uc.Repo.Update(ctx, position); err != nil </span><span class="cov0" title="0">{
                return entities.Position{}, fmt.Errorf("erro ao atualizar posição: %w", err)
        }</span>

        <span class="cov0" title="0">return position, nil</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">package provincias

import (
        "context"
        "strings"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"

        "github.com/google/uuid"
)

type CreateProvinceUseCase struct {
        Repo repos.ProvinceRepository
}

type CreateProvinceInput struct {
        Name string
}

func (uc *CreateProvinceUseCase) Execute(ctx context.Context, input CreateProvinceInput) (entities.Province, error) <span class="cov8" title="1">{
        // Sanitização e validação
        name := strings.TrimSpace(input.Name)

        // Construção do VO
        prov := vos.NewProvince(name)

        now := time.Now()
        province := entities.Province{
                ID:        uuid.New(),
                Nome:      prov,
                CreatedAt: now,
                UpdatedAt: now,
        }

        // Persistência
        if err := uc.Repo.Create(ctx, province); err != nil </span><span class="cov8" title="1">{
                return entities.Province{}, err
        }</span>

        <span class="cov8" title="1">return province, nil</span>
}
</pre>
		
		<pre class="file" id="file154" style="display: none">package provincias

import (
        "context"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type DeleteProvinceUseCase struct {
        Repo repos.ProvinceRepository
}

// Execute remove uma província pelo ID
func (uc *DeleteProvinceUseCase) Execute(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return uc.Repo.Delete(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file155" style="display: none">package provincias

import (
        "context"
        "errors"
        "fmt"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type FindProvinceByIDUseCase struct {
        Repo repos.ProvinceRepository
}

type FindProvinceByIDInput struct {
        ID uuid.UUID
}

// Execute busca uma província pelo ID e retorna erro se não for encontrada.
func (uc *FindProvinceByIDUseCase) Execute(ctx context.Context, input FindProvinceByIDInput) (entities.Province, error) <span class="cov0" title="0">{
        // Verificação básica de UUID vazio
        if input.ID == uuid.Nil </span><span class="cov0" title="0">{
                return entities.Province{}, errors.New("ID de província inválido")
        }</span>

        <span class="cov0" title="0">prov, err := uc.Repo.FindByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Province{}, fmt.Errorf("erro ao buscar província: %w", err)
        }</span>

        // Verificação se retornou uma província válida
        <span class="cov0" title="0">if prov.ID == uuid.Nil </span><span class="cov0" title="0">{
                return entities.Province{}, errors.New("província não encontrada")
        }</span>

        <span class="cov0" title="0">return prov, nil</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">package provincias

import (
        "context"
        "fmt"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
)

type FindAllProvincesUseCase struct {
        Repo repos.ProvinceRepository
}

// Execute retorna todas as províncias com suporte a paginação.
func (uc *FindAllProvincesUseCase) Execute(ctx context.Context, limit, offset int) ([]entities.Province, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10 // valor padrão
        }</span>
        <span class="cov0" title="0">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">provinces, err := uc.Repo.FindAll(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao listar províncias: %w", err)
        }</span>
        <span class="cov0" title="0">return provinces, nil</span>
}
</pre>
		
		<pre class="file" id="file157" style="display: none">package provincias

import (
        "context"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/utils"
)

// SearchProvinceUseCase retorna províncias
type SearchProvinceUseCase struct {
        Repo repos.ProvinceRepository
}

func (uc *SearchProvinceUseCase) Execute(ctx context.Context, input utils.SearchInput) ([]entities.Province, error) <span class="cov0" title="0">{
        utils.ApplyDefaults(&amp;input)
        return uc.Repo.Search(ctx, input.SearchText, input.Filter, input.Limit, input.Offset)
}</span>
</pre>
		
		<pre class="file" id="file158" style="display: none">package provincias

import (
        "context"
        "errors"
        "fmt"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"
        "rhapp/internal/domain/vos"
        "strings"
        "time"

        "github.com/google/uuid"
)

type UpdateProvinceUseCase struct {
        Repo repos.ProvinceRepository
}

type UpdateProvinceInput struct {
        ID   uuid.UUID
        Name string
}

func (uc *UpdateProvinceUseCase) Execute(ctx context.Context, input UpdateProvinceInput) (entities.Province, error) <span class="cov0" title="0">{
        if input.ID == uuid.Nil </span><span class="cov0" title="0">{
                return entities.Province{}, errors.New("ID de província inválido")
        }</span>

        <span class="cov0" title="0">input.Name = strings.TrimSpace(input.Name)
        if input.Name == "" </span><span class="cov0" title="0">{
                return entities.Province{}, errors.New("o nome da província é obrigatório")
        }</span>

        // Buscar província atual
        <span class="cov0" title="0">province, err := uc.Repo.FindByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Province{}, fmt.Errorf("erro ao buscar província: %w", err)
        }</span>

        // Verificar se o nome realmente mudou
        <span class="cov0" title="0">if input.Name != province.Nome.String() </span><span class="cov0" title="0">{

                // Verificação de duplicidade
                exists, err := uc.Repo.ExistsByNome(ctx, input.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return entities.Province{}, fmt.Errorf("erro ao verificar duplicidade: %w", err)
                }</span>
                <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                        return entities.Province{}, fmt.Errorf("província com o nome '%s' já existe", input.Name)
                }</span>

                <span class="cov0" title="0">province.Nome = vos.NewProvince(input.Name)
                province.UpdatedAt = time.Now()

                if err := uc.Repo.Update(ctx, province); err != nil </span><span class="cov0" title="0">{
                        return entities.Province{}, fmt.Errorf("erro ao atualizar província: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return province, nil</span>
}
</pre>
		
		<pre class="file" id="file159" style="display: none">package supervisor

import (
        "context"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type CreateInput struct {
        EmployeeID   uuid.UUID
        SupervisorID *uuid.UUID
        StartDate    time.Time
        EndDate      *time.Time
}

type CreateUseCase struct {
        Repo repos.SupervisorHistoryRepository
}

func (uc *CreateUseCase) Execute(ctx context.Context, input CreateInput) (entities.SupervisorHistory, error) <span class="cov0" title="0">{
        sh := entities.SupervisorHistory{
                ID:           uuid.New(),
                EmployeeID:   input.EmployeeID,
                SupervisorID: input.SupervisorID,
                StartDate:    input.StartDate,
                EndDate:      input.EndDate,
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }
        if err := uc.Repo.Create(ctx, sh); err != nil </span><span class="cov0" title="0">{
                return entities.SupervisorHistory{}, err
        }</span>
        <span class="cov0" title="0">return sh, nil</span>
}
</pre>
		
		<pre class="file" id="file160" style="display: none">package supervisor

import (
        "context"

        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type DeleteUseCase struct {
        Repo repos.SupervisorHistoryRepository
}

func (uc *DeleteUseCase) Execute(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return uc.Repo.Delete(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file161" style="display: none">package supervisor

import (
        "context"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type FindByIDUseCase struct {
        Repo repos.SupervisorHistoryRepository
}

func (uc *FindByIDUseCase) Execute(ctx context.Context, id uuid.UUID) (*entities.SupervisorHistory, error) <span class="cov0" title="0">{
        return uc.Repo.FindByID(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file162" style="display: none">package supervisor

import (
        "context"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type ListByEmployeeIDUseCase struct {
        Repo repos.SupervisorHistoryRepository
}

func (uc *ListByEmployeeIDUseCase) Execute(ctx context.Context, employeeID uuid.UUID, limit, offset int) ([]entities.SupervisorHistory, error) <span class="cov0" title="0">{
        return uc.Repo.ListByEmployeeID(ctx, employeeID, limit, offset)
}</span>
</pre>
		
		<pre class="file" id="file163" style="display: none">package supervisor

import (
        "context"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type UpdateInput struct {
        ID           uuid.UUID
        SupervisorID *uuid.UUID
        StartDate    time.Time
        EndDate      *time.Time
}

type UpdateUseCase struct {
        Repo repos.SupervisorHistoryRepository
}

func (uc *UpdateUseCase) Execute(ctx context.Context, input UpdateInput) (entities.SupervisorHistory, error) <span class="cov0" title="0">{
        sh := entities.SupervisorHistory{
                ID:           input.ID,
                SupervisorID: input.SupervisorID,
                StartDate:    input.StartDate,
                EndDate:      input.EndDate,
                UpdatedAt:    time.Now(),
        }
        if err := uc.Repo.Update(ctx, sh); err != nil </span><span class="cov0" title="0">{
                return entities.SupervisorHistory{}, err
        }</span>
        <span class="cov0" title="0">return sh, nil</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">package workhistory

import (
        "context"
        "time"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type CreateWorkHistoryInput struct {
        EmployeeID       uuid.UUID
        Company          string
        Position         string
        StartDate        time.Time
        EndDate          *time.Time
        Responsibilities string
}

type CreateWorkHistoryUseCase struct {
        Repo repos.WorkHistoryRepository
}

func (uc *CreateWorkHistoryUseCase) Execute(ctx context.Context, input entities.WorkHistory) (entities.WorkHistory, error) <span class="cov0" title="0">{
        now := time.Now()
        work := entities.WorkHistory{
                ID:               uuid.New(),
                EmployeeID:       input.EmployeeID,
                Company:          input.Company,
                Position:         input.Position,
                StartDate:        input.StartDate,
                EndDate:          input.EndDate,
                Responsibilities: input.Responsibilities,
                CreatedAt:        now,
                UpdatedAt:        now,
        }
        if err := uc.Repo.Create(ctx, work); err != nil </span><span class="cov0" title="0">{
                return entities.WorkHistory{}, err
        }</span>
        <span class="cov0" title="0">return work, nil</span>
}
</pre>
		
		<pre class="file" id="file165" style="display: none">package workhistory

import (
        "context"

        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type DeleteWorkHistoryUseCase struct {
        Repo repos.WorkHistoryRepository
}

func (uc *DeleteWorkHistoryUseCase) Execute(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return uc.Repo.Delete(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file166" style="display: none">package workhistory

import (
        "context"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type FindWorkHistoryByIDUseCase struct {
        Repo repos.WorkHistoryRepository
}

func (uc *FindWorkHistoryByIDUseCase) Execute(ctx context.Context, id uuid.UUID) (entities.WorkHistory, error) <span class="cov0" title="0">{
        return uc.Repo.FindByID(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file167" style="display: none">package workhistory

import (
        "context"

        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type ListWorkHistoryByEmployeeUseCase struct {
        Repo repos.WorkHistoryRepository
}

func (uc *ListWorkHistoryByEmployeeUseCase) Execute(ctx context.Context, employeeID uuid.UUID, limit, offset int) ([]entities.WorkHistory, error) <span class="cov0" title="0">{
        return uc.Repo.ListByEmployee(ctx, employeeID, limit, offset)
}</span>
</pre>
		
		<pre class="file" id="file168" style="display: none">package workhistory

import (
        "context"
        "time"

        "rhapp/internal/domain/dtos"
        "rhapp/internal/domain/entities"
        "rhapp/internal/domain/repos"

        "github.com/google/uuid"
)

type UpdateWorkHistoryInput struct {
        ID      uuid.UUID
        WorkDTO dtos.UpdateWorkDTO
}

type UpdateWorkHistoryUseCase struct {
        Repo repos.WorkHistoryRepository
}

func (uc *UpdateWorkHistoryUseCase) Execute(ctx context.Context, input UpdateWorkHistoryInput) (entities.WorkHistory, error) <span class="cov0" title="0">{
        work, err := uc.Repo.FindByID(ctx, input.ID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.WorkHistory{}, err
        }</span>

        <span class="cov0" title="0">if err := dtos.ApplyUpdateToWork(&amp;work, input.WorkDTO); err != nil </span><span class="cov0" title="0">{
                return entities.WorkHistory{}, err
        }</span>

        <span class="cov0" title="0">work.UpdatedAt = time.Now()
        if err := uc.Repo.Update(ctx, work); err != nil </span><span class="cov0" title="0">{
                return entities.WorkHistory{}, err
        }</span>
        <span class="cov0" title="0">return work, nil</span>
}
</pre>
		
		<pre class="file" id="file169" style="display: none">package utils

import (
        "errors"
        "fmt"
        "net/http"
        "reflect"
        "strings"

        "github.com/go-playground/validator/v10"
        "github.com/jackc/pgconn"
        "github.com/lib/pq"
        "golang.org/x/text/cases"
        "golang.org/x/text/language"
)

type FieldError struct {
        Field   string      `json:"field"`
        Label   string      `json:"label"`
        Tag     string      `json:"tag"`
        Message string      `json:"message"`
        Value   interface{} `json:"value,omitempty"`
}

type Payload struct {
        Error   string       `json:"error"`             // ex: validation_failed, conflict, internal
        Message string       `json:"message,omitempty"` // resumo humanizado
        Fields  []FieldError `json:"fields,omitempty"`  // detalhes por campo
}

var v = validator.New()

func init() <span class="cov0" title="0">{
        // Mostra o nome do json como "campo" quando label não existir
        v.RegisterTagNameFunc(func(fld reflect.StructField) string </span><span class="cov0" title="0">{
                tag := fld.Tag.Get("json")
                if tag == "" || tag == "-" </span><span class="cov0" title="0">{
                        return fld.Name
                }</span>
                <span class="cov0" title="0">return strings.Split(tag, ",")[0]</span>
        })
}

func labelOf(sf reflect.StructField) string <span class="cov0" title="0">{
        if l := sf.Tag.Get("label"); l != "" </span><span class="cov0" title="0">{
                return l
        }</span>
        // fallback para json
        <span class="cov0" title="0">j := sf.Tag.Get("json")
        if j != "" &amp;&amp; j != "-" </span><span class="cov0" title="0">{
                return strings.Split(j, ",")[0]
        }</span>
        <span class="cov0" title="0">return sf.Name</span>
}

func fieldLabel(dto any, fe validator.FieldError) string <span class="cov0" title="0">{
        t := reflect.TypeOf(dto)
        if t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>
        <span class="cov0" title="0">if t.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return fe.Field()
        }</span>
        // caminhar pela estrutura para achar o field
        <span class="cov0" title="0">parts := strings.Split(fe.StructNamespace(), ".")
        // parts[0] é o nome do tipo; ignorar
        cur := t
        var sf reflect.StructField
        var ok bool

        for i := 1; i &lt; len(parts); i++ </span><span class="cov0" title="0">{
                name := parts[i]
                sf, ok = cur.FieldByName(name)
                if !ok </span><span class="cov0" title="0">{
                        return fe.Field()
                }</span>
                <span class="cov0" title="0">if i == len(parts)-1 </span><span class="cov0" title="0">{
                        return labelOf(sf)
                }</span>
                <span class="cov0" title="0">tt := sf.Type
                if tt.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        tt = tt.Elem()
                }</span>
                <span class="cov0" title="0">if tt.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        return labelOf(sf)
                }</span>
                <span class="cov0" title="0">cur = tt</span>
        }
        <span class="cov0" title="0">return fe.Field()</span>
}

// fieldLabelFromDTO prefers `label:"..."`, then `json:"..."`, otherwise struct field name.
func fieldLabelFromDTO(dto any, fe validator.FieldError) string <span class="cov0" title="0">{
        if dto == nil </span><span class="cov0" title="0">{
                return fe.Field()
        }</span>
        <span class="cov0" title="0">t := reflect.TypeOf(dto)
        // Handle pointer/slice/map wrappers
        for t.Kind() == reflect.Ptr || t.Kind() == reflect.Slice || t.Kind() == reflect.Array || t.Kind() == reflect.Map </span><span class="cov0" title="0">{
                t = t.Elem()
                if t == nil </span><span class="cov0" title="0">{
                        return fe.Field()
                }</span>
        }
        <span class="cov0" title="0">if t.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return fe.Field()
        }</span>

        // Use the StructField by walking the namespace (handles nested structs)
        <span class="cov0" title="0">sf := structFieldByNamespace(t, fe.StructNamespace())
        if sf == nil </span><span class="cov0" title="0">{
                // Fallback to direct Field lookup
                if f, ok := t.FieldByName(fe.StructField()); ok </span><span class="cov0" title="0">{
                        sf = &amp;f
                }</span>
        }
        <span class="cov0" title="0">if sf == nil </span><span class="cov0" title="0">{
                return fe.Field()
        }</span>

        // label has priority
        <span class="cov0" title="0">if label := sf.Tag.Get("label"); label != "" </span><span class="cov0" title="0">{
                return label
        }</span>

        // json tag (strip ",omitempty")
        <span class="cov0" title="0">if jsonTag := sf.Tag.Get("json"); jsonTag != "" &amp;&amp; jsonTag != "-" </span><span class="cov0" title="0">{
                if idx := strings.IndexByte(jsonTag, ','); idx &gt;= 0 </span><span class="cov0" title="0">{
                        return jsonTag[:idx]
                }</span>
                <span class="cov0" title="0">return jsonTag</span>
        }

        <span class="cov0" title="0">return sf.Name</span>
}

// structFieldByNamespace finds the StructField for a nested namespace like "CreateProvinceDTO.Nome".
func structFieldByNamespace(root reflect.Type, ns string) *reflect.StructField <span class="cov0" title="0">{
        if ns == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">parts := strings.Split(ns, ".")
        // Drop the root type name if present
        if len(parts) &gt; 0 &amp;&amp; parts[0] == root.Name() </span><span class="cov0" title="0">{
                parts = parts[1:]
        }</span>
        <span class="cov0" title="0">current := root
        var sf reflect.StructField
        for _, p := range parts </span><span class="cov0" title="0">{
                if current.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">f, ok := current.FieldByName(p)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">sf = f
                current = f.Type
                // Deref pointers
                for current.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        current = current.Elem()
                }</span>
        }
        <span class="cov0" title="0">return &amp;sf</span>
}

// buildTagMessage creates friendly messages for common tags.
func buildTagMessage(label string, fe validator.FieldError) string <span class="cov0" title="0">{
        param := fe.Param()
        switch fe.Tag() </span>{
        case "required":<span class="cov0" title="0">
                return fmt.Sprintf("%s é obrigatório.", label)</span>
        case "min":<span class="cov0" title="0">
                return fmt.Sprintf("%s deve ter no mínimo %s caracteres.", label, param)</span>
        case "max":<span class="cov0" title="0">
                return fmt.Sprintf("%s deve ter no máximo %s caracteres.", label, param)</span>
        case "len":<span class="cov0" title="0">
                return fmt.Sprintf("%s deve ter exatamente %s caracteres.", label, param)</span>
        case "email":<span class="cov0" title="0">
                return fmt.Sprintf("%s deve ser um e-mail válido.", label)</span>
        case "oneof":<span class="cov0" title="0">
                return fmt.Sprintf("%s deve ser um dos valores: %s.", label, param)</span>
        case "uuid", "uuid4":<span class="cov0" title="0">
                return fmt.Sprintf("%s deve ser um UUID válido.", label)</span>
        case "gte":<span class="cov0" title="0">
                return fmt.Sprintf("%s deve ser maior ou igual a %s.", label, param)</span>
        case "lte":<span class="cov0" title="0">
                return fmt.Sprintf("%s deve ser menor ou igual a %s.", label, param)</span>
        case "datetime":<span class="cov0" title="0">
                // e.g., datetime=2006-01-02
                if param != "" </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s deve estar no formato de data/hora: %s.", label, param)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%s deve estar em um formato de data/hora válido.", label)</span>
        default:<span class="cov0" title="0">
                // Fallback: show tag for debugging without leaking internals
                if param != "" </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s é inválido (regra: %s=%s).", label, fe.Tag(), param)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%s é inválido (regra: %s).", label, fe.Tag())</span>
        }
}

// HumanizeValidation converts validator errors into friendly, labeled messages.
func HumanizeValidation(dto any, err error) []FieldError <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">var verrs validator.ValidationErrors
        if !errors.As(err, &amp;verrs) </span><span class="cov0" title="0">{
                // Not a validation error → return nil to let caller handle generic errors
                return nil
        }</span>

        <span class="cov0" title="0">fields := make([]FieldError, 0, len(verrs))
        for _, fe := range verrs </span><span class="cov0" title="0">{
                lbl := fieldLabelFromDTO(dto, fe)
                fields = append(fields, FieldError{
                        Field:   fe.Field(),
                        Label:   lbl,
                        Tag:     fe.Tag(),
                        Message: buildTagMessage(lbl, fe),
                        Value:   safeValue(fe.Value()),
                })
        }</span>
        <span class="cov0" title="0">return fields</span>
}

func HumanizeDB(err error) (ok bool, payload Payload, status int) <span class="cov0" title="0">{
        // --- pgx / pgconn ---
        var pgxErr *pgconn.PgError
        caser := cases.Title(language.Portuguese)
        if errors.As(err, &amp;pgxErr) </span><span class="cov0" title="0">{
                switch pgxErr.Code </span>{
                case "23505":<span class="cov0" title="0"> // unique_violation
                        col, val := parseDupFromDetail(pgxErr.Detail, pgxErr.ConstraintName)
                        msg := "Já existe um registro com esses dados"
                        var msgField string
                        if col != "" </span><span class="cov0" title="0">{
                                msgField = "O campo '" + col + "' já está em uso"
                        }</span>
                        <span class="cov0" title="0">return true, Payload{
                                Error:   "conflicto",
                                Message: msg,
                                Fields:  []FieldError{{Field: caser.String(col), Message: msgField, Value: val}},
                        }, http.StatusConflict</span>
                }
        }

        // --- lib/pq ---
        <span class="cov0" title="0">var pqErr *pq.Error
        if errors.As(err, &amp;pqErr) </span><span class="cov0" title="0">{
                switch string(pqErr.Code) </span>{
                case "23505":<span class="cov0" title="0"> // unique_violation
                        col, val := parseDupFromDetail(pqErr.Detail, pqErr.Constraint)
                        msg := "Já existe um registro com esses dados"
                        var msgField string
                        if col != "" </span><span class="cov0" title="0">{
                                msgField = "O campo '" + col + "' já está em uso"
                        }</span>
                        <span class="cov0" title="0">return true, Payload{
                                Error:   "conflicto",
                                Message: msg,
                                Fields:  []FieldError{{Field: caser.String(col), Message: msgField, Value: val}},
                        }, http.StatusConflict</span>
                }
        }

        <span class="cov0" title="0">return false, Payload{}, 0</span>
}

// DETAIL examples:
// "Key (name)=(Luanda) already exists."
// "Key (tenant_id, email)=(t1, foo@bar.com) already exists."
func parseDupFromDetail(detail, constraint string) (field, value string) <span class="cov0" title="0">{
        if detail != "" </span><span class="cov0" title="0">{
                start := strings.Index(detail, "Key (")
                if start != -1 </span><span class="cov0" title="0">{
                        start += len("Key (")
                        mid := strings.Index(detail[start:], ")=")
                        if mid != -1 </span><span class="cov0" title="0">{
                                cols := strings.TrimSpace(detail[start : start+mid])
                                vStart := strings.Index(detail, "=(")
                                if vStart != -1 </span><span class="cov0" title="0">{
                                        vStart += len("=(")
                                        if vEnd := strings.Index(detail[vStart:], ")"); vEnd != -1 </span><span class="cov0" title="0">{
                                                value = strings.TrimSpace(detail[vStart : vStart+vEnd])
                                        }</span>
                                }
                                <span class="cov0" title="0">if strings.Contains(cols, ",") </span><span class="cov0" title="0">{
                                        field = strings.TrimSpace(strings.Split(cols, ",")[0])
                                }</span> else<span class="cov0" title="0"> {
                                        field = cols
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                }
        }
        // Fallback: infer from constraint e.g. "provinces_name_key"
        <span class="cov0" title="0">if constraint != "" </span><span class="cov0" title="0">{
                parts := strings.Split(constraint, "_")
                if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                        field = parts[len(parts)-2]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// safeValue trims long values to avoid noisy payloads/logs.
func safeValue(v interface{}) interface{} <span class="cov0" title="0">{
        const max = 80
        switch x := v.(type) </span>{
        case string:<span class="cov0" title="0">
                if len(x) &gt; max </span><span class="cov0" title="0">{
                        return x[:max] + "…"
                }</span>
                <span class="cov0" title="0">return x</span>
        }
        <span class="cov0" title="0">return v</span>
}
</pre>
		
		<pre class="file" id="file170" style="display: none">package utils

import (
        "strconv"

        "github.com/gin-gonic/gin"
)

type Pagination struct {
        Limit  int
        Offset int
}

func PaginationInput(c *gin.Context) Pagination <span class="cov0" title="0">{
        limitStr := c.DefaultQuery("limit", "10")
        offsetStr := c.DefaultQuery("offset", "0")
        limit, _ := strconv.Atoi(limitStr)
        offset, _ := strconv.Atoi(offsetStr)

        return Pagination{
                Limit:  limit,
                Offset: offset,
        }
}</span>
</pre>
		
		<pre class="file" id="file171" style="display: none">package utils

import (
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"
)

type SearchInput struct {
        SearchText string
        Filter     string
        Limit      int
        Offset     int
}

// applyDefaults padroniza os valores de paginação
func ApplyDefaults(input *SearchInput) <span class="cov0" title="0">{
        if input.Limit &lt;= 0 </span><span class="cov0" title="0">{
                input.Limit = 10
        }</span>
        <span class="cov0" title="0">if input.Offset &lt; 0 </span><span class="cov0" title="0">{
                input.Offset = 0
        }</span>
}

func ParseSearchInput(c *gin.Context) SearchInput <span class="cov0" title="0">{
        search := strings.TrimSpace(c.Query("search"))
        filter := strings.TrimSpace(c.Query("filter"))
        limitStr := c.DefaultQuery("limit", "10")
        offsetStr := c.DefaultQuery("offset", "0")
        limit, _ := strconv.Atoi(limitStr)
        offset, _ := strconv.Atoi(offsetStr)

        return SearchInput{
                SearchText: search,
                Filter:     filter,
                Limit:      limit,
                Offset:     offset,
        }
}</span>
</pre>
		
		<pre class="file" id="file172" style="display: none">package utils

import (
        "encoding/json"
        "errors"

        "github.com/gin-gonic/gin"
        "github.com/gin-gonic/gin/binding"
)

func BindAndValidateStrict(c *gin.Context, dto interface{}) error <span class="cov0" title="0">{
        decoder := json.NewDecoder(c.Request.Body)
        decoder.DisallowUnknownFields() // reject unknown keys

        if err := decoder.Decode(dto); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Ensure there’s no extra data after JSON object
        <span class="cov0" title="0">if decoder.More() </span><span class="cov0" title="0">{
                return errors.New("invalid JSON: multiple objects")
        }</span>

        // Now run validator binding checks (if using `binding:"required"`, etc.)
        <span class="cov0" title="0">if err := binding.Validator.ValidateStruct(dto); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file173" style="display: none">package main

// @title HRMS API
// @version 1.0
// @description API de Gestão de Recursos Humanos (Províncias, Municípios, Departamentos, etc.)
// @termsOfService http://localhost:8080/terms
// @contact.name Equipa de Desenvolvimento
// @contact.email suporte@empresa.com
// @license.name MIT
// @license.url https://opensource.org/licenses/MIT
// @host localhost:8080
// @BasePath /api
// @schemes http

import (
        "log"

        "rhapp/internal/infrastructure/persistence"
        "rhapp/internal/infrastructure/postgresdb"
        "rhapp/internal/infrastructure/redisdb"
        "rhapp/internal/interfaces/handlers"
        "rhapp/internal/interfaces/router"
        "rhapp/internal/usecase/areas_estudo"
        "rhapp/internal/usecase/departments"
        "rhapp/internal/usecase/dependents"
        "rhapp/internal/usecase/distritos"
        "rhapp/internal/usecase/documents_uc"
        "rhapp/internal/usecase/education"
        "rhapp/internal/usecase/employee_status"
        "rhapp/internal/usecase/employees"
        "rhapp/internal/usecase/municipios"
        "rhapp/internal/usecase/positions"
        "rhapp/internal/usecase/provincias"
        "rhapp/internal/usecase/supervisor"
        "rhapp/internal/usecase/workhistory"

        "github.com/gin-contrib/cors"
        _ "github.com/lib/pq"
)

func main() <span class="cov0" title="0">{

        postgresdb.InitPostgres()
        defer postgresdb.DB.Close()

        // Redis
        redisdb.InitRedis()

        // Repositório
        provinceRepo := persistence.NewProvincePgRepository(postgresdb.DB)
        departmentRepo := persistence.NewDepartmentPgRepository(postgresdb.DB)
        positionRepo := persistence.NewPositionPgRepository(postgresdb.DB)
        areaEstudoRepo := persistence.NewAreaEstudoPgRepository(postgresdb.DB)
        municipalityRepo := persistence.NewMunicipalityPgRepository(postgresdb.DB)
        distRepo := persistence.NewDistrictPgRepository(postgresdb.DB)
        employeeRepo := persistence.NewEmployeePgRepository(postgresdb.DB)
        dependentRepo := persistence.NewDependentPgRepository(postgresdb.DB)
        documentRepo := persistence.NewDocumentPgRepository(postgresdb.DB)
        educationRepo := persistence.NewEducationPgRepository(postgresdb.DB)
        empStatusRepo := persistence.NewEmployeeStatusPgRepository(postgresdb.DB)
        supervisorRepo := persistence.NewSupervisorPgRepository(postgresdb.DB)
        workRepo := persistence.NewWorkHistoryPgRepository(postgresdb.DB)

        createSupervisorUC := &amp;supervisor.CreateUseCase{Repo: supervisorRepo}
        updateSupervisorUC := &amp;supervisor.UpdateUseCase{Repo: supervisorRepo}
        deleteSupervisorUC := &amp;supervisor.DeleteUseCase{Repo: supervisorRepo}
        getSupervisorUC := &amp;supervisor.FindByIDUseCase{Repo: supervisorRepo}
        listSupervisorUC := &amp;supervisor.ListByEmployeeIDUseCase{Repo: supervisorRepo}

        createWorkUC := &amp;workhistory.CreateWorkHistoryUseCase{Repo: workRepo}
        updateWorkUC := &amp;workhistory.UpdateWorkHistoryUseCase{Repo: workRepo}
        deleteWorkUC := &amp;workhistory.DeleteWorkHistoryUseCase{Repo: workRepo}
        getWorkUC := &amp;workhistory.FindWorkHistoryByIDUseCase{Repo: workRepo}
        listWorkUC := &amp;workhistory.ListWorkHistoryByEmployeeUseCase{Repo: workRepo}

        // Use cases
        createEmployeeStatusUC := &amp;employee_status.CreateEmployeeStatusUseCase{Repo: empStatusRepo}
        updateEmployeeStatusUC := &amp;employee_status.UpdateEmployeeStatusUseCase{Repo: empStatusRepo}
        deleteEmployeeStatusUC := &amp;employee_status.DeleteEmployeeStatusUseCase{Repo: empStatusRepo}
        getEmployeeStatusUC := &amp;employee_status.FindEmployeeStatusByIDUseCase{Repo: empStatusRepo}
        listEmployeeStatusUC := &amp;employee_status.ListEmployeeStatusByEmployeeUseCase{Repo: empStatusRepo}

        // Use cases
        createEducationUC := &amp;education.CreateEducationHistoryUseCase{Repo: educationRepo}
        updateEducationUC := &amp;education.UpdateEducationHistoryUseCase{Repo: educationRepo}
        deleteEducationUC := &amp;education.DeleteEducationHistoryUseCase{Repo: educationRepo}
        getEducationUC := &amp;education.FindEducationHistoryByIDUseCase{Repo: educationRepo}
        listEducationUC := &amp;education.ListEducationHistoriesUseCase{Repo: educationRepo}

        // Use cases
        createDocumentUC := &amp;documents_uc.CreateDocumentUseCase{Repo: documentRepo}
        updateDocumentUC := &amp;documents_uc.UpdateDocumentUseCase{Repo: documentRepo}
        deleteDocumentUC := &amp;documents_uc.DeleteDocumentUseCase{Repo: documentRepo}
        getDocumentUC := &amp;documents_uc.FindDocumentByIDUseCase{Repo: documentRepo}
        listDocumentsUC := &amp;documents_uc.ListDocumentsUseCase{Repo: documentRepo}

        // Use cases
        createProvinceUC := &amp;provincias.CreateProvinceUseCase{Repo: provinceRepo}
        updateProvinceUC := &amp;provincias.UpdateProvinceUseCase{Repo: provinceRepo}
        deleteProvinceUC := &amp;provincias.DeleteProvinceUseCase{Repo: provinceRepo}
        getProvinceUC := &amp;provincias.FindProvinceByIDUseCase{Repo: provinceRepo}
        listProvincesUC := &amp;provincias.FindAllProvincesUseCase{Repo: provinceRepo}
        searchProvinceUC := &amp;provincias.SearchProvinceUseCase{Repo: provinceRepo}

        // Use cases - Municipality
        createMunicipalityUC := &amp;municipios.CreateMunicipalityUseCase{Repo: municipalityRepo, ProvinceR: provinceRepo}
        updateMunicipalityUC := &amp;municipios.UpdateMunicipalityUseCase{Repo: municipalityRepo, ProvinceR: provinceRepo}
        deleteMunicipalityUC := &amp;municipios.DeleteMunicipalityUseCase{Repo: municipalityRepo}
        findMunicipalityByIDUC := &amp;municipios.FindMunicipalityByIDUseCase{Repo: municipalityRepo}
        listMunicipalityUC := &amp;municipios.ListMunicipalitiesUseCase{Repo: municipalityRepo}

        // 🧠 Use Cases - Department
        createDeptUC := &amp;departments.CreateDepartmentUseCase{Repo: departmentRepo}
        updateDeptUC := &amp;departments.UpdateDepartmentUseCase{Repo: departmentRepo}
        deleteDeptUC := &amp;departments.DeleteDepartmentUseCase{Repo: departmentRepo}
        getDeptUC := &amp;departments.FindDepartmentByIDUseCase{Repo: departmentRepo}
        listDeptsUC := &amp;departments.FindAllDepartmentsUseCase{Repo: departmentRepo}

        // 🧠 Use Cases - Position
        createPosUC := &amp;positions.CreatePositionUseCase{Repo: positionRepo, DeptRepo: departmentRepo}
        updatePosUC := &amp;positions.UpdatePositionUseCase{Repo: positionRepo, DeptRepo: departmentRepo}
        deletePosUC := &amp;positions.DeletePositionUseCase{Repo: positionRepo}
        getPosUC := &amp;positions.FindPositionByIDUseCase{Repo: positionRepo}
        listPosUC := &amp;positions.FindAllPositionsUseCase{Repo: positionRepo}

        // 🧠 Use Cases - AreaEstudo
        createAreaUC := &amp;areas_estudo.CreateAreaEstudoUseCase{Repo: areaEstudoRepo}
        updateAreaUC := &amp;areas_estudo.UpdateAreaEstudoUseCase{Repo: areaEstudoRepo}
        deleteAreaUC := &amp;areas_estudo.DeleteAreaEstudoUseCase{Repo: areaEstudoRepo}
        getAreaUC := &amp;areas_estudo.GetAreaEstudoByIDUseCase{Repo: areaEstudoRepo}
        listAreaUC := &amp;areas_estudo.ListAllAreasEstudoUseCase{Repo: areaEstudoRepo}

        // Use Cases de Busca

        /*
                searchMunicipalityUC := &amp;usecase.SearchMunicipalityUseCase{Repo: municipalityRepo}
                searchDepartmentUC := &amp;usecase.SearchDepartmentUseCase{Repo: departmentRepo}
                searchPositionUC := &amp;usecase.SearchPositionUseCase{Repo: positionRepo}
                searchProvinceUC := &amp;usecase.SearchProvinceUseCase{Repo: provinceRepo}
                searchAreaEstudoUC := &amp;usecase.SearchAreaEstudoUseCase{Repo: areaEstudoRepo}
                searchDistrito := &amp;usecase.SearchDistrictUseCase{Repo: distRepo}
                searchEmployee := &amp;usecase.SearchEmployeesUseCase{Repo: employeeRepo}
        */

        // Use Cases de District
        createDistrictUC := &amp;distritos.CreateDistrictUseCase{Repo: distRepo, MunicipioRepo: municipalityRepo}
        updateDistrictUC := &amp;distritos.UpdateDistrictUseCase{Repo: distRepo, MunicipalityRepo: municipalityRepo}
        deleteDistrictUC := &amp;distritos.DeleteDistrictUseCase{Repo: distRepo}
        findDistrictUC := &amp;distritos.FindDistrictByIDUseCase{Repo: distRepo}
        listDistrictUC := &amp;distritos.ListAllDistrictsUseCase{Repo: distRepo}

        // Use Cases de Employee
        createEmployeeUC := &amp;employees.CreateEmployeeUseCase{Repo: employeeRepo}
        updateEmployeeUC := &amp;employees.UpdateEmployeeUseCase{Repo: employeeRepo}
        deleteEmployeeUC := &amp;employees.DeleteEmployeeUseCase{Repo: employeeRepo}
        findEmployeeUC := &amp;employees.FindEmployeeByIDUseCase{Repo: employeeRepo}
        listEmployeeUC := &amp;employees.ListEmployeesUseCase{Repo: employeeRepo}

        // Use Cases de Employee
        createDependentUC := &amp;dependents.CreateDependentUseCase{Repo: dependentRepo}
        updateDependentUC := &amp;dependents.UpdateDependentUseCase{Repo: dependentRepo}
        deleteDependentUC := &amp;dependents.DeleteDependentUseCase{Repo: dependentRepo}
        findDependentUC := &amp;dependents.FindDependentByIDUseCase{Repo: dependentRepo}
        listDependentUC := &amp;dependents.ListDependentsUseCase{Repo: dependentRepo}

        provinceHandler := handlers.NewProvinceHandler(createProvinceUC, updateProvinceUC, deleteProvinceUC, getProvinceUC, listProvincesUC, searchProvinceUC)
        departmentHandler := handlers.NewDepartmentHandler(createDeptUC, updateDeptUC, deleteDeptUC, getDeptUC, listDeptsUC)
        positionHandler := handlers.NewPositionHandler(createPosUC, updatePosUC, deletePosUC, getPosUC, listPosUC)
        areaEstudoHandler := handlers.NewAreaEstudoHandler(createAreaUC, updateAreaUC, deleteAreaUC, getAreaUC, listAreaUC)
        municipalityHandler := handlers.NewMunicipalityHandler(createMunicipalityUC, updateMunicipalityUC, deleteMunicipalityUC, findMunicipalityByIDUC, listMunicipalityUC)
        distritoHandler := handlers.NewDistrictHandler(createDistrictUC, updateDistrictUC, deleteDistrictUC, findDistrictUC, listDistrictUC)
        employeeHandler := handlers.NewEmployeeHandler(createEmployeeUC, updateEmployeeUC, deleteEmployeeUC, findEmployeeUC, listEmployeeUC)
        dependentHandler := handlers.NewDependentHandler(createDependentUC, updateDependentUC, deleteDependentUC, findDependentUC, listDependentUC)
        //        searchHandler := handlers.NewSearchHandler(searchMunicipalityUC, searchDepartmentUC, searchPositionUC, searchProvinceUC, searchAreaEstudoUC, searchDistrito, searchEmployee)
        supervisorHandler := handlers.NewSupervisorHandler(createSupervisorUC, updateSupervisorUC, deleteSupervisorUC, getSupervisorUC, listSupervisorUC)
        educationHandler := handlers.NewEducationHandler(createEducationUC, updateEducationUC, deleteEducationUC, getEducationUC, listEducationUC)
        documentHandler := handlers.NewDocumentHandler(createDocumentUC, updateDocumentUC, deleteDocumentUC, getDocumentUC, listDocumentsUC)
        empStatusHandler := handlers.NewEmployeeStatusHandler(createEmployeeStatusUC, updateEmployeeStatusUC, deleteEmployeeStatusUC, getEmployeeStatusUC, listEmployeeStatusUC)
        workHandler := handlers.NewWorkHandler(createWorkUC, updateWorkUC, deleteWorkUC, getWorkUC, listWorkUC)

        // Iniciar servidor
        r := router.SetupRouter(
                provinceHandler,
                areaEstudoHandler,
                departmentHandler,
                positionHandler,
                municipalityHandler,
                //                searchHandler,
                distritoHandler,
                employeeHandler,
                dependentHandler,
                documentHandler,
                educationHandler,
                empStatusHandler,
                supervisorHandler,
                workHandler)

        r.Use(cors.Default())

        log.Println("Servidor iniciado na porta 8080")
        r.Run(":8080")
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
